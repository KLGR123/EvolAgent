### Development Step 22: BFS on Grid to Get 11th Two-Cell Move Landing Cell’s Hex Color

**Description**: Perform a breadth-first search on workspace/adjacency_cardinal.json starting from the START coordinate from workspace/start_end_coordinates.json to find the shortest path to the END coordinate; then identify the coordinate at index 11 in the resulting path (representing the landing cell after the eleventh two-cell move) and retrieve its 6-digit hex fill_color from workspace/grid_data.json.

**Use Cases**:
- Indoor warehouse robot path planning to retrieve inventory: performing BFS on the facility grid to find the shortest route and then extracting the 11th landing cell’s color-coded zone for optimized pick-up scheduling
- Emergency evacuation route mapping in a high-rise building: running BFS from each floor’s stairwell to the ground exit, then identifying the 11th corridor segment’s safety-zone color for dynamic signage updates
- Automated agricultural drone flight planning: computing the BFS route across a crop-field grid to systematically survey plants, then retrieving the 11th waypoint’s soil-type color classification to adjust sensor calibration
- Facility maintenance scheduling in a chemical plant: finding the shortest inspection path through pipe junctions via BFS and extracting the 11th segment’s hazard-level color code to prioritize safety checks
- Theme-park visitor guidance: calculating the BFS walking path between attractions on a park map, then highlighting the 11th tile’s themed-zone color in the mobile app for targeted promotions
- Data-center cabling optimization: using BFS on rack adjacency graphs to plan cable runs from core switches to servers, then extracting the 11th rack’s zone color to avoid thermal hotspots
- Urban drone delivery route planning: executing BFS on a city grid to determine optimal flight paths, then retrieving the 11th waypoint’s airspace-classification color for compliance with local regulations

```
import os
import json

# Step 1: Locate workspace directory
cwd = os.getcwd()
workspace_dirs = [d for d in os.listdir(cwd) if os.path.isdir(d) and d.startswith('workspace')]
if not workspace_dirs:
    raise FileNotFoundError(f"No workspace directory found in {cwd}")
workspace_dir = os.path.join(cwd, 'workspace') if 'workspace' in workspace_dirs else os.path.join(cwd, workspace_dirs[0])
print(f"Using workspace directory: {workspace_dir}\n")
print(f"Files: {os.listdir(workspace_dir)}\n")

# Step 2: Load and parse START/END
se_path = os.path.join(workspace_dir, 'start_end_coordinates.json')
print(f"Loading START/END from: {se_path}")
with open(se_path,'r') as f:
    se = json.load(f)
print(f"Raw content: {se}\n")
# Determine formats
if 'START' in se:
    v = se['START']
elif 'start' in se:
    v = se['start']
else:
    raise KeyError("Missing START/start in JSON")
if isinstance(v, dict) and 'row' in v and 'col' in v:
    start = (int(v['row']), int(v['col']))
elif isinstance(v,(list,tuple)) and len(v)==2:
    start = (int(v[0]), int(v[1]))
else:
    raise ValueError(f"Unrecognized START format: {v}")
# END
if 'END' in se:
    v = se['END']
elif 'end' in se:
    v = se['end']
else:
    raise KeyError("Missing END/end in JSON")
if isinstance(v, dict) and 'row' in v and 'col' in v:
    end = (int(v['row']), int(v['col']))
elif isinstance(v,(list,tuple)) and len(v)==2:
    end = (int(v[0]), int(v[1]))
else:
    raise ValueError(f"Unrecognized END format: {v}")
print(f"Parsed START: {start}")
print(f"Parsed END:   {end}\n")

# Step 3: Load adjacency_cardinal.json
adj_path = os.path.join(workspace_dir, 'adjacency_cardinal.json')
print(f"Loading adjacency graph: {adj_path}")
with open(adj_path,'r') as f:
    adj_raw = json.load(f)
print(f"Nodes in raw adjacency: {len(adj_raw)}\nSample: {list(adj_raw.items())[:2]}\n")
# Build tuple-based adjacency
adj = {}
for k, nbrs in adj_raw.items():
    r,c = map(int, k.split(','))
    node = (r,c)
    nbr_list = []
    for n in nbrs:
        if isinstance(n,str):
            rr,cc = map(int,n.split(','))
            nbr_list.append((rr,cc))
        elif isinstance(n,(list,tuple)):
            nbr_list.append((int(n[0]),int(n[1])))
        else:
            raise ValueError(f"Bad neighbor: {n}")
    adj[node] = nbr_list
print(f"Built adjacency for {len(adj)} nodes.\n")

# Step 4: BFS with local deque import
def bfs_shortest_path(adj, start, end):
    from collections import deque
    print("Imported deque inside BFS function")
    q = deque([start])
    visited = {start}
    parent = {start: None}
    while q:
        cur = q.popleft()
        if cur == end:
            print("Reached END in BFS")
            break
        for nb in adj.get(cur, []):
            if nb not in visited:
                visited.add(nb)
                parent[nb] = cur
                q.append(nb)
    if end not in parent:
        print(f"No path from {start} to {end}")
        return []
    path = []
    node = end
    while node is not None:
        path.append(node)
        node = parent[node]
    return list(reversed(path))

print(f"Running BFS from {start} to {end}...\n")
path = bfs_shortest_path(adj, start, end)
print(f"Path length: {len(path)}")
print(f"First 12: {path[:12]}\n")

# Step 5: Extract index 11
idx = 11
if len(path) <= idx:
    raise IndexError(f"Path length {len(path)} < required index {idx}")
landing = path[idx]
print(f"Landing at index {idx}: {landing}\n")

# Step 6: Load grid_data.json and inspect sample
gd_path = os.path.join(workspace_dir, 'grid_data.json')
print(f"Loading grid data: {gd_path}")
with open(gd_path,'r') as f:
    grid = json.load(f)
print(f"Total grid entries: {len(grid)}\nSample entry: {grid[0]}\n")

# Step 7: Find fill_color
color = None
for cell in grid:
    if 'row' in cell and 'col' in cell:
        coord = (int(cell['row']), int(cell['col']))
    elif 'coordinate' in cell:
        coord = tuple(map(int, cell['coordinate']))
    else:
        continue
    if coord == landing:
        color = cell.get('fill_color') or cell.get('color')
        break
if not color:
    raise ValueError(f"No fill_color for {landing}")
print(f"Found fill_color: {color}\n")

# Step 8: Save result
out = {
    'landing_index': idx,
    'landing_coordinate': list(landing),
    'fill_color': color
}
out_path = os.path.join(workspace_dir, 'landing_cell_and_color.json')
with open(out_path,'w') as f:
    json.dump(out, f, indent=2)
print(f"Result written to: {out_path}\n")

print("===== FINAL ANSWER =====")
print(f"Index: {idx}\nCoordinate: {landing}\nFill color: {color}")
print("========================")
```