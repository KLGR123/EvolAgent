### Development Step 20: BFS Shortest Path and Retrieve 11th Move Landing Cell Hex Color

**Description**: Perform a breadth-first search on workspace/adjacency_cardinal.json starting from the START coordinate from workspace/start_end_coordinates.json to find the shortest path to the END coordinate; then identify the coordinate at index 11 in the resulting path (representing the landing cell after the eleventh two-cell move) and retrieve its 6-digit hex fill_color from workspace/grid_data.json.

**Use Cases**:
- Autonomous warehouse robotics navigation: compute the shortest route between loading dock and packing station, identify the robot’s 11th waypoint, and retrieve its floor tile color code from the facility grid for dynamic route marking.
- Agricultural drone sampling: plan a grid-based flight path from field entry to exit, find the 11th GPS coordinate in the optimal route, and fetch its soil-type hex color from GIS data to trigger targeted soil analysis.
- Interactive museum guide system: map visitor flow across exhibit rooms, determine the 11th room on the shortest path from the entrance to the special exhibit, and pull its exhibit-theme color for on-screen wayfinding cues.
- Video game level design QA: verify the NPC’s path through a dungeon from spawn to exit, locate the 11th room in the BFS-computed path, and extract the room’s background hex color from level metadata for visual consistency checks.
- Emergency evacuation planning: simulate the quickest escape route in a building floorplan, identify the 11th corridor segment on the BFS path, and retrieve its wall-paint color code to validate visibility under smoke conditions.
- Urban pedestrian flow analysis: model the shortest walking route between two city squares, pick the 11th intersection in that path, and obtain its land-use zoning color from the city grid to assess commercial vs. residential foot traffic.
- Environmental field research: chart the most direct transect across a habitat grid, select the 11th survey point, and look up its vegetation-cover hex color from satellite grid data for biodiversity sampling.

```
import os
import json
import glob

# Step 1: Locate the workspace directory dynamically (handles names like 'workspace' or 'workspace_<uuid>').
cwd = os.getcwd()
workspace_dirs = [d for d in os.listdir(cwd) if os.path.isdir(d) and d.startswith('workspace')]
if not workspace_dirs:
    raise FileNotFoundError(f"No workspace directory found in {cwd}")
# Prefer exact 'workspace' if it exists, else take the first match
if 'workspace' in workspace_dirs:
    workspace_dir = os.path.join(cwd, 'workspace')
else:
    workspace_dir = os.path.join(cwd, workspace_dirs[0])
print(f"Using workspace directory: {workspace_dir}\n")

# List files for confirmation
files = os.listdir(workspace_dir)
print(f"Files in workspace: {files}\n")

# Step 2: Load and parse start/end coordinates
start_end_path = os.path.join(workspace_dir, 'start_end_coordinates.json')
print(f"Loading start/end coordinates from: {start_end_path}")
with open(start_end_path, 'r') as f:
    start_end = json.load(f)
print(f"Raw content: {start_end}\n")

# Determine START coordinate
if 'start' in start_end or 'START' in start_end:
    key = 'start' if 'start' in start_end else 'START'
    val = start_end[key]
    if isinstance(val, dict) and 'row' in val and 'col' in val:
        start_coord = (int(val['row']), int(val['col']))
    elif isinstance(val, (list, tuple)) and len(val) == 2:
        start_coord = (int(val[0]), int(val[1]))
    else:
        raise ValueError(f"Unrecognized format for {key}: {val}")
else:
    raise KeyError("Could not find 'start' or 'START' in start_end_coordinates.json")

# Determine END coordinate
if 'end' in start_end or 'END' in start_end:
    key = 'end' if 'end' in start_end else 'END'
    val = start_end[key]
    if isinstance(val, dict) and 'row' in val and 'col' in val:
        end_coord = (int(val['row']), int(val['col']))
    elif isinstance(val, (list, tuple)) and len(val) == 2:
        end_coord = (int(val[0]), int(val[1]))
    else:
        raise ValueError(f"Unrecognized format for {key}: {val}")
else:
    raise KeyError("Could not find 'end' or 'END' in start_end_coordinates.json")

print(f"Parsed START: {start_coord}")
print(f"Parsed END:   {end_coord}\n")

# Step 3: Load adjacency_cardinal.json
adj_path = os.path.join(workspace_dir, 'adjacency_cardinal.json')
print(f"Loading adjacency graph from: {adj_path}")
with open(adj_path, 'r') as f:
    adjacency_raw = json.load(f)
print(f"Total adjacency nodes: {len(adjacency_raw)}\n")

# Build adjacency list mapping tuple->list of tuples
adjacency = {}
for key_str, nbrs in adjacency_raw.items():
    r_str, c_str = key_str.split(',')
    node = (int(r_str), int(c_str))
    parsed = []
    for n in nbrs:
        if isinstance(n, str):
            rr, cc = n.split(',')
            parsed.append((int(rr), int(cc)))
        elif isinstance(n, (list, tuple)) and len(n) == 2:
            parsed.append((int(n[0]), int(n[1])))
        else:
            raise ValueError(f"Bad neighbor format: {n}")
    adjacency[node] = parsed
print(f"Built adjacency list with {len(adjacency)} entries.\n")

# Step 4: BFS shortest path with local import of deque
from collections import deque

def bfs_shortest_path(adj, start, end):
    print(f"Starting BFS from {start} to {end}")
    queue = deque([start])
    visited = {start}
    parent = {start: None}
    while queue:
        cur = queue.popleft()
        if cur == end:
            print("Reached END in BFS")
            break
        for nb in adj.get(cur, []):
            if nb not in visited:
                visited.add(nb)
                parent[nb] = cur
                queue.append(nb)
    # reconstruct path
    if end not in parent:
        return []
    path = []
    node = end
    while node is not None:
        path.append(node)
        node = parent[node]
    path.reverse()
    return path

path = bfs_shortest_path(adjacency, start_coord, end_coord)
print(f"BFS path length: {len(path)}")
print(f"First 12 coords of path: {path[:12]}\n")

# Step 5: Identify 11th index (0-based) landing cell
idx = 11
if len(path) <= idx:
    raise IndexError(f"Path too short ({len(path)}) for index {idx}")
landing = path[idx]
print(f"Coordinate at index {idx}: {landing}\n")

# Step 6: Load grid_data.json
grid_path = os.path.join(workspace_dir, 'grid_data.json')
print(f"Loading grid data from: {grid_path}")
with open(grid_path, 'r') as f:
    grid = json.load(f)
print(f"Total grid entries: {len(grid)}\n")

# Step 7: Find fill_color for landing
fill = None
for cell in grid:
    if 'row' in cell and 'col' in cell:
        coord = (int(cell['row']), int(cell['col']))
    elif 'coordinate' in cell and isinstance(cell['coordinate'], (list, tuple)):
        coord = (int(cell['coordinate'][0]), int(cell['coordinate'][1]))
    else:
        continue
    if coord == landing:
        fill = cell.get('fill_color') or cell.get('color')
        break
if fill is None:
    raise ValueError(f"No color found for coordinate {landing}")
print(f"Found color at {landing}: {fill}\n")

# Step 8: Save result to eleventh_move_result.json (overwrite existing)
out_path = os.path.join(workspace_dir, 'eleventh_move_result.json')
result = {
    'landing_index': idx,
    'landing_coordinate': list(landing),
    'fill_color': fill
}
with open(out_path, 'w') as f:
    json.dump(result, f, indent=2)
print(f"Result written to: {out_path}\n")

# Final summary
print("===== FINAL ANSWER =====")
print(f"Index: {idx}")
print(f"Coordinate: {landing}")
print(f"Fill color: {fill}")
print("========================")
```