### Development Step 12: Find 11th-move cell and its hex color via BFS on legal two-cell move graph

**Description**: Construct adjacency graph of legal two-cell moves using workspace/grid_data.json and workspace/start_end_coordinates.json and perform a breadth-first search from the START cell to locate the shortest path to the END cell enforcing no immediate backtracking; identify the coordinate of the cell landed on after the 11th move along the resulting path; extract that cell’s 6-digit hex fill color from workspace/grid_data.json.

**Use Cases**:
- Warehouse AGV route optimization and floor‐marker color verification for industrial logistics
- Autonomous indoor drone waypoint planning and floor‐marker localization for smart warehousing
- Tile-based game level path validation and timed event trigger placement for puzzle video games
- PCB assembly head movement planning and solder-mask inspection at specific placement steps for electronics manufacturing
- Greenhouse robot navigation and soil-moisture sensor sampling after fixed moves for precision agriculture
- Educational STEM tool for knight-move puzzle solving with stepwise feedback in classroom learning
- Digital pathology slide scanning path planning and stain-color sampling at a critical step for medical research analysis

```
import os
import json
from collections import deque

# 1) File paths
workspace = 'workspace'
grid_path = os.path.join(workspace, 'grid_data.json')
coords_path = os.path.join(workspace, 'start_end_coordinates.json')

# 2) Load grid_data.json
print(f"Loading grid_data.json from {grid_path}")
with open(grid_path, 'r', encoding='utf-8') as f:
    grid = json.load(f)
print(f"Total cells in grid: {len(grid)}\n")

# 3) Load start/end coordinates
print(f"Loading start/end coords from {coords_path}")
with open(coords_path, 'r', encoding='utf-8') as f:
    se = json.load(f)
start = (se['START']['row'], se['START']['col'])
end   = (se['END']['row'],   se['END']['col'])
print(f"START at {start}, END at {end}\n")

# 4) Build cell_map and define passable set as only GREEN ('92D050') + blank START/END ('')
PASSABLE_COLORS = {'92D050', ''}
cell_map = {}
passable = set()
for cell in grid:
    coord = (cell['row'], cell['col'])
    cell_map[coord] = cell
    if cell.get('fill_color', '') in PASSABLE_COLORS:
        passable.add(coord)
print(f"PASSABLE_COLORS = {PASSABLE_COLORS}")
print(f"Passable cells count: {len(passable)} / {len(grid)} total\n")

# 5) Adjacency builder
def build_adj(passable_set, moves, mid_check):
    adj = {c: [] for c in passable_set}
    for (r, c) in passable_set:
        nbrs = []
        for dr, dc in moves:
            dest = (r + dr, c + dc)
            if dest not in passable_set:
                continue
            if mid_check:
                mid = (r + dr//2, c + dc//2)
                if mid not in passable_set:
                    continue
            nbrs.append(dest)
        adj[(r, c)] = nbrs
    return adj

# 6) Define move scenarios
cardinal = [( 2, 0), (-2, 0), (0,  2), (0, -2)]
diagonal = [( 2, 2), ( 2, -2), (-2, 2), (-2, -2)]
scenarios = [
    ('A: 2-step cardinal, mid-check',              cardinal,             True),
    ('B: 2-step cardinal+diagonal, mid-check',      cardinal+diagonal,    True),
    ('C: 2-step cardinal, NO mid-check',            cardinal,             False),
    ('D: 2-step cardinal+diagonal, NO mid-check',   cardinal+diagonal,    False),
]

chosen = None
for name, moves, midc in scenarios:
    print(f"Testing scenario {name}")
    adj = build_adj(passable, moves, midc)
    print(f"  START neighbors: {adj.get(start, [])}")
    print(f"  END   neighbors: {adj.get(end,   [])}")
    # simple BFS
    vis = {start}
    dq = deque([start])
    while dq:
        cur = dq.popleft()
        for nb in adj[cur]:
            if nb not in vis:
                vis.add(nb)
                dq.append(nb)
    reachable = end in vis
    print(f"  Reachable count: {len(vis)}, END reachable: {reachable}\n")
    if reachable:
        chosen = (name, adj)
        break

if not chosen:
    print("ERROR: No scenario connects START to END with GREEN+blank passable. Aborting.")
    exit(1)

scenario_name, adjacency = chosen
print(f"Using scenario '{scenario_name}' for no-backtracking BFS.\n")

# 7) BFS shortest path forbidding immediate backtracking
queue = deque([(start, None, [start])])
seen  = {(start, None)}
path_to_end = None
while queue:
    cur, prev, path = queue.popleft()
    if cur == end:
        path_to_end = path
        break
    for nb in adjacency[cur]:
        if nb == prev:
            continue
        st = (nb, cur)
        if st not in seen:
            seen.add(st)
            queue.append((nb, cur, path + [nb]))

if path_to_end is None:
    print("ERROR: No no-backtracking path found even though basic BFS succeeded.")
    exit(1)

moves_count = len(path_to_end) - 1
print(f"Found shortest path with {moves_count} moves.")
print(f"Full path: {path_to_end}\n")

# 8) Extract 11th move
if moves_count < 11:
    print(f"ERROR: Only {moves_count} moves; cannot get 11th move.")
    exit(1)
coord11 = path_to_end[11]
hex11   = cell_map[coord11].get('fill_color', '')
print(f"Coordinate after 11th move: {coord11}")
print(f"Fill color at that cell: {hex11}\n")

# 9) Save results
result = {
    'scenario': scenario_name,
    '11th_move_coordinate': {'row': coord11[0], 'col': coord11[1]},
    'fill_color': hex11,
    'total_moves': moves_count
}
out_path = os.path.join(workspace, 'eleventh_move_result.json')
with open(out_path, 'w', encoding='utf-8') as f:
    json.dump(result, f, indent=2)
print(f"Results saved to {out_path}")
```