### Development Step 2: Parse PDF to Extract Seahorse Island Accommodation Types and Compare Their Average Ratings

**Description**: Parse and analyze the attached PDF file data/gaia/2023/validation/67e8878b-5cef-4375-804e-e6291fdbe78a.pdf to extract information about all accommodations in Seahorse Island. Identify the different types of accommodations (such as hotels, motels, rental houses, campgrounds, etc.) and their corresponding ratings. Calculate the average rating for each accommodation type to determine which type has the highest average rating.

**Use Cases**:
- Tourism board of Seahorse Island uses automated PDF parsing to aggregate and compare average guest ratings of hotels, motels, rental houses, and campgrounds for their annual visitor satisfaction report.
- Hotel chain operations team extracts competitor ratings from public PDF brochures to benchmark performance across their various property types and pinpoint underperforming segments.
- Online travel agency automates extraction and analysis of PDF property review sheets to continuously update their website‚Äôs top-rated lodging categories based on up-to-date guest scores.
- Municipal parks department processes campground inspection PDF reports, categorizes sites (traditional campsite, glamping, RV hookup), and calculates average safety and satisfaction ratings for targeted maintenance planning.
- Market research firm parses supplier PDF catalogs of electronics, classifies items into laptops, tablets, and accessories, then computes average customer review scores to advise retail buyers on the highest-rating segments.
- Real estate investment group analyzes PDF property assessment documents, classifies residential units (apartments, condos, single-family homes), and computes average condition ratings to guide acquisition and renovation priorities.
- Event planning agency automates parsing of venue PDF data sheets, categorizes spaces (ballroom, conference rooms, outdoor pavilions), and computes average attendee feedback ratings to recommend the best fit for corporate retreats.

```
import os
import json
import re
from collections import defaultdict

print("=== SEAHORSE ISLAND ACCOMMODATION RATINGS ANALYSIS ===")
print("Step 2: Parse structured data and calculate average ratings by type\n")

# First, let's examine what files are available in the workspace
print("Examining workspace contents...")
workspace_files = []
for root, dirs, files in os.walk('workspace'):
    for file in files:
        file_path = os.path.join(root, file)
        workspace_files.append(file_path)
        print(f"Found: {file_path}")

if not workspace_files:
    print("No workspace files found yet.")

# Look for the raw content file that should contain the PDF data
raw_content_file = None
for file_path in workspace_files:
    if 'raw' in file_path.lower() and file_path.endswith('.txt'):
        raw_content_file = file_path
        break

if raw_content_file:
    print(f"\nFound raw content file: {raw_content_file}")
    print("Loading raw accommodation data...")
    
    with open(raw_content_file, 'r', encoding='utf-8') as f:
        raw_content = f.read()
        
    print(f"Raw content length: {len(raw_content)} characters")
    print("\n=== RAW CONTENT PREVIEW ===\n")
    print(raw_content[:500] + "..." if len(raw_content) > 500 else raw_content)
else:
    # Use the content from the history since we know what it contains
    print("\nUsing accommodation data from PDF analysis...")
    raw_content = """Name Rating (out of 5)Vacancy Pool Sample Review
Hotels
Neptune's Palace 5 Yes Yes A hotel fit for a king.
Admiral Sturgeon 5 No Yes The breakfast was wonderful. The price was not.
Currents 4 Yes Yes The staff was helpful and accomodating.
The Laughing Gull 3 No Yes Great proximity to the beach.
Loach Towers 2 Yes No Good view of the water.
Motels
Sea Escape Inn 5 Yes Yes Don't let the "motel" look scare you. This place made for a clean and comfortable vacation.
Wash Inn 3 No Yes It was nice that they had laundry machines for guests.
Boulevard Motel 2 Yes No Real close to the gas station.
Good Motel 1 Yes No Name is false advertising.
Sea Larva Motel 0 Yes Yes Name is true advertising.
Rental Houses
Cape Super 4 No No The owner was very nice. A pleasure to talk to.
Bleek Island 3 No No We got a personalized box of chocolates upon our arrival. How sweet!
Pinedrift Avenue 4 Yes No This would be a good place if it wasn't an hour away from everything.
Ocean and Main 5 No Yes The location is great, if you don't mind the noise.
4th Street Cottage 5 No No The board games in the living room were nice to have.
Shelley's Place 4 Yes Yes The floorboards creaked too loud! Made it hard to walk and sleep at the same time.
Creakwood Creek 3 No Yes Tried fishing in the creek but nothing was biting.
Headrush Beach 3 No No The accomodations are rough, but the private beach is amazing.
Shiplap Cabin 3 Yes No Pretty sure this place is haunted.
Haddonfield House 1 Yes No The kitchen made it easy to prepare our own meals during our stay.
Campgrounds
The Glampground 4 Yes Yes Has the most Ultra HD TVs out of any campground I've been to.
Gull Crest 5 Yes Yes A bird defecated on our tent... never going back.
Barnacle Isle 3 No No Hard to bring our RV here when the only access to the island is by boat.
Cozy Wood 4 Yes Yes Not the most secluded, but clean and comfortable.
Gravel Lot Campground 1 Yes No No water or electric hookups for our camper... talk about "roughing it"."""

print("\n=== PARSING ACCOMMODATION DATA BY TYPE ===")

# Parse the structured data line by line
lines = raw_content.strip().split('\n')
print(f"Total lines to process: {len(lines)}")

# Initialize data structures
accommodation_types = ['Hotels', 'Motels', 'Rental Houses', 'Campgrounds']
accommodations_by_type = defaultdict(list)
current_category = None

print("\nParsing accommodations by category...")

for i, line in enumerate(lines):
    line = line.strip()
    print(f"Line {i+1}: {line}")
    
    # Skip the header line
    if 'Name Rating' in line and 'Vacancy Pool' in line:
        print("  -> Header line, skipping")
        continue
    
    # Check if this line is a category header
    if line in accommodation_types:
        current_category = line
        print(f"  -> Category found: {current_category}")
        continue
    
    # Skip empty lines
    if not line:
        print("  -> Empty line, skipping")
        continue
    
    # Parse accommodation data lines
    if current_category:
        # Extract rating using regex - look for the first digit 0-5 in the line
        rating_match = re.search(r'\b([0-5])\b', line)
        if rating_match:
            rating = int(rating_match.group(1))
            
            # Extract name (everything before the rating)
            rating_pos = rating_match.start()
            name = line[:rating_pos].strip()
            
            # Extract additional info after rating
            after_rating = line[rating_match.end():].strip()
            
            # Parse the rest of the line for vacancy, pool, and review
            parts = after_rating.split(None, 2)  # Split into max 3 parts
            vacancy = parts[0] if len(parts) > 0 else ''
            pool = parts[1] if len(parts) > 1 else ''
            review = parts[2] if len(parts) > 2 else ''
            
            accommodation = {
                'name': name,
                'category': current_category,
                'rating': rating,
                'vacancy': vacancy,
                'pool': pool,
                'review': review
            }
            
            accommodations_by_type[current_category].append(accommodation)
            print(f"  -> Parsed: {name} ({current_category}) - Rating: {rating}")
        else:
            print(f"  -> Could not find rating in line: {line}")

print("\n=== ACCOMMODATION PARSING RESULTS ===")

for category in accommodation_types:
    count = len(accommodations_by_type[category])
    print(f"{category}: {count} accommodations")
    for acc in accommodations_by_type[category]:
        print(f"  - {acc['name']}: {acc['rating']}/5")

print("\n=== CALCULATING AVERAGE RATINGS BY TYPE ===")

# Calculate average ratings for each accommodation type
average_ratings = {}
rating_details = {}

for category in accommodation_types:
    accommodations = accommodations_by_type[category]
    if accommodations:
        ratings = [acc['rating'] for acc in accommodations]
        total_ratings = sum(ratings)
        count = len(ratings)
        average = total_ratings / count
        
        average_ratings[category] = average
        rating_details[category] = {
            'count': count,
            'total': total_ratings,
            'average': average,
            'ratings': ratings,
            'accommodations': accommodations
        }
        
        print(f"{category}:")
        print(f"  Count: {count} accommodations")
        print(f"  Individual ratings: {ratings}")
        print(f"  Total: {total_ratings}")
        print(f"  Average: {average:.2f}/5")
        print()
    else:
        print(f"{category}: No accommodations found")
        average_ratings[category] = 0

print("=== FINAL RESULTS ===")
print("Average ratings by accommodation type:")
print("-" * 40)

# Sort by average rating to find the highest
sorted_averages = sorted(average_ratings.items(), key=lambda x: x[1], reverse=True)

for i, (category, avg_rating) in enumerate(sorted_averages):
    if avg_rating > 0:
        rank_symbol = "ü•á" if i == 0 else "ü•à" if i == 1 else "ü•â" if i == 2 else "  "
        print(f"{rank_symbol} {category}: {avg_rating:.2f}/5 ({rating_details[category]['count']} accommodations)")
    else:
        print(f"   {category}: No data")

# Identify the winner
if sorted_averages and sorted_averages[0][1] > 0:
    winner_category = sorted_averages[0][0]
    winner_average = sorted_averages[0][1]
    winner_count = rating_details[winner_category]['count']
    
    print(f"\n*** ANSWER ***")
    print(f"The accommodation type with the HIGHEST AVERAGE RATING is:")
    print(f"üèÜ {winner_category.upper()} with an average rating of {winner_average:.2f}/5")
    print(f"(Based on {winner_count} accommodations)")
    
    # Show all accommodations in the winning category
    print(f"\n{winner_category} accommodations and their ratings:")
    for acc in rating_details[winner_category]['accommodations']:
        print(f"  ‚Ä¢ {acc['name']}: {acc['rating']}/5")
else:
    print("\n*** ERROR: No valid accommodation data found ***")

# Save detailed results
results_data = {
    'accommodation_types': accommodation_types,
    'accommodations_by_type': dict(accommodations_by_type),
    'average_ratings': average_ratings,
    'rating_details': rating_details,
    'highest_rated_type': sorted_averages[0] if sorted_averages and sorted_averages[0][1] > 0 else None,
    'analysis_summary': f"Analyzed {sum(len(accs) for accs in accommodations_by_type.values())} total accommodations across {len(accommodation_types)} categories"
}

with open('workspace/accommodation_ratings_analysis.json', 'w', encoding='utf-8') as f:
    json.dump(results_data, f, indent=2, ensure_ascii=False)

# Create a summary report
summary_report = f"""SEAHORSE ISLAND ACCOMMODATION RATINGS ANALYSIS
{'='*50}

TOTAL ACCOMMODATIONS ANALYZED: {sum(len(accs) for accs in accommodations_by_type.values())}

AVERAGE RATINGS BY TYPE:
{'-'*30}
"""

for category, avg_rating in sorted_averages:
    if avg_rating > 0:
        count = rating_details[category]['count']
        summary_report += f"{category}: {avg_rating:.2f}/5 ({count} properties)\n"

if sorted_averages and sorted_averages[0][1] > 0:
    winner = sorted_averages[0]
    summary_report += f"\nüèÜ HIGHEST RATED TYPE: {winner[0]} ({winner[1]:.2f}/5)\n"

with open('workspace/accommodation_ratings_summary.txt', 'w', encoding='utf-8') as f:
    f.write(summary_report)

print(f"\nDetailed analysis saved to: workspace/accommodation_ratings_analysis.json")
print(f"Summary report saved to: workspace/accommodation_ratings_summary.txt")
print("\n=== ANALYSIS COMPLETE ===")
```