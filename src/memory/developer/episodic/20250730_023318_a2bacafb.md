### Development Step 9: Trace connections between LOTR outbound links and ASOIAF inbound links (July 3, 2023 archive)

**Description**: Access the archived Wikipedia page for 'A Song of Ice and Fire' (book series) as it appeared at the end of July 3, 2023. Use the same Wayback Machine approach to retrieve the specific version from that date. Extract all inbound links and cross-reference them with the previously extracted outbound links from The Lord of the Rings page to identify direct connections. If no direct connection exists, systematically trace potential multi-step paths by examining intermediate pages that were linked from LOTR, particularly focusing on the high-priority fantasy/literature connections like 'International Fantasy Award', 'High fantasy', and other genre-related pages that might contain links to George R.R. Martin's work.

**Use Cases**:
- Academic literary network mapping for digital humanities: tracing interlinkages between “A Song of Ice and Fire” and “The Lord of the Rings” Wikipedia pages to build an interactive citation graph for a university research project on fantasy genre evolution.
- Publishing rights due diligence: extracting and cross-referencing archived inbound and outbound links between major fantasy properties to identify shared awards or events (e.g., International Fantasy Award) before negotiating translation or adaptation deals.
- Content recommendation engine training: gathering historical link structures from archived Wikipedia pages to generate a genre-cohesive graph dataset used by an eBook platform’s machine learning model for suggesting new fantasy titles to readers.
- SEO competitive analysis for fan websites: analyzing archived snapshots of high-traffic fantasy franchise pages to understand cross-linking strategies and inbound link patterns, then applying those insights to optimize site architecture and backlink outreach.
- Library digital preservation audit: archiving and processing critical Wikipedia pages at specific historical timestamps to document changes in public domain knowledge and maintain a verifiable record of metadata for long-term cultural heritage stewardship.
- Journalistic background research automation: retrieving and parsing archived versions of franchise pages to quickly map direct and multi-step connections between authors and awards, powering a fact-checking tool for entertainment news articles.
- Tour planning for pop-culture travelers: extracting location-related inbound links (e.g., filming sites, regional inspirations) from archived fantasy franchise pages to compile custom itineraries for fans visiting real-world destinations tied to their favorite book universes.

```
import os
import requests
from bs4 import BeautifulSoup
import json
from urllib.parse import urljoin, urlparse
import re
from datetime import datetime

print('=== ACCESSING ARCHIVED WIKIPEDIA PAGE: A SONG OF ICE AND FIRE ===\n')
print('Objective: Retrieve the Wikipedia page as it appeared on July 3, 2023')
print('Target URL: https://en.wikipedia.org/wiki/A_Song_of_Ice_and_Fire')
print('Target Date: July 3, 2023\n')

# The URL of the Wikipedia page to retrieve
url = "https://en.wikipedia.org/wiki/A_Song_of_Ice_and_Fire"

# The date we want to retrieve (end of July 3, 2023)
date = "20230703"

print(f'Checking Wayback Machine availability for: {url}')
print(f'Target date: {date} (July 3, 2023)\n')

# Check if the webpage is available in the Wayback Machine
api_url = f"https://archive.org/wayback/available?url={url}&timestamp={date}"
print(f'Wayback Machine API URL: {api_url}')

try:
    avail_response = requests.get(api_url, timeout=20)
    print(f'API Response Status: {avail_response.status_code}')
    
    if avail_response.status_code == 200:
        avail_data = avail_response.json()
        print(f'API Response Data: {avail_data}')
        
        if "archived_snapshots" in avail_data and "closest" in avail_data["archived_snapshots"]:
            closest = avail_data["archived_snapshots"]["closest"]
            print(f'\nClosest snapshot info: {closest}')
            
            if closest["available"]:
                archive_url = closest["url"]
                archive_date = closest["timestamp"]
                print(f'\n✓ Archived version found!')
                print(f'Archive URL: {archive_url}')
                print(f'Archive timestamp: {archive_date}')
                print(f'Formatted date: {archive_date[:4]}-{archive_date[4:6]}-{archive_date[6:8]} {archive_date[8:10]}:{archive_date[10:12]}:{archive_date[12:14]}')
            else:
                print(f"\n❌ No archived version found for {url} on {date}")
                exit()
        else:
            print(f"\n❌ No archived snapshots data found for {url}")
            exit()
    else:
        print(f"\n❌ Error checking archive availability: {avail_response.status_code}")
        print(f"Response text: {avail_response.text[:200]}...")
        exit()
except Exception as e:
    print(f"\n❌ Exception while checking archive availability: {str(e)}")
    exit()

print(f'\n=== DOWNLOADING ARCHIVED PAGE ===\n')

# Headers to mimic a real browser request
headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
    'Accept-Language': 'en-US,en;q=0.5',
    'Accept-Encoding': 'gzip, deflate',
    'Connection': 'keep-alive',
    'Upgrade-Insecure-Requests': '1',
}

try:
    print(f'Downloading archived page from: {archive_url}')
    response = requests.get(archive_url, headers=headers, timeout=30)
    response.raise_for_status()
    
    print(f'✓ Successfully downloaded archived page')
    print(f'Status code: {response.status_code}')
    print(f'Content length: {len(response.content):,} bytes')
    print(f'Content type: {response.headers.get("Content-Type", "unknown")}')
    
except Exception as e:
    print(f"❌ Error downloading archived page: {str(e)}")
    exit()

# Parse the HTML content
print(f'\n=== PARSING HTML CONTENT ===\n')

soup = BeautifulSoup(response.content, 'html.parser')

# Remove Wayback Machine navigation elements
print('Removing Wayback Machine navigation elements...')
for element in soup.find_all(class_=lambda x: x and 'wayback' in x.lower()):
    element.decompose()

# Remove script and style tags for cleaner text extraction
for element in soup(["script", "style"]):
    element.decompose()

# Get basic page information
title = soup.find('title')
if title:
    page_title = title.get_text().strip()
    print(f'Page Title: {page_title}')

# Find the main content area
main_content = soup.find('div', {'id': 'mw-content-text'}) or soup.find('div', {'class': 'mw-content-ltr'})
if main_content:
    print(f'✓ Found main content area')
else:
    print(f'⚠️ Main content area not found, using full page')
    main_content = soup

# Extract the page text for analysis
page_text = main_content.get_text()
lines = (line.strip() for line in page_text.splitlines())
chunks = (phrase.strip() for line in lines for phrase in line.split("  "))
clean_text = ' '.join(chunk for chunk in chunks if chunk)

print(f'\nPage text length: {len(clean_text):,} characters')
print(f'First 500 characters: {clean_text[:500]}...')

# Extract all inbound links (links pointing TO other pages)
print(f'\n=== EXTRACTING INBOUND LINKS ===\n')

# Find all links in the main content
all_links = main_content.find_all('a', href=True)
print(f'Total links found: {len(all_links)}')

# Filter for Wikipedia article links
wikipedia_links = []
for link in all_links:
    href = link.get('href')
    if href:
        # Convert relative URLs to absolute
        if href.startswith('/'):
            href = urljoin('https://en.wikipedia.org', href)
        
        # Filter for Wikipedia article links
        if 'en.wikipedia.org/wiki/' in href and ':' not in href.split('/')[-1]:
            # Remove anchors and query parameters
            clean_href = href.split('#')[0].split('?')[0]
            
            # Get link text
            link_text = link.get_text().strip()
            
            # Extract article title from URL
            article_title = clean_href.split('/')[-1].replace('_', ' ')
            
            wikipedia_links.append({
                'url': clean_href,
                'article_title': article_title,
                'link_text': link_text,
                'original_href': link.get('href')
            })

# Remove duplicates while preserving order
seen_urls = set()
unique_links = []
for link in wikipedia_links:
    if link['url'] not in seen_urls:
        seen_urls.add(link['url'])
        unique_links.append(link)

print(f'Wikipedia article links found: {len(unique_links)}')

# Display first 20 links for verification
print(f'\nFirst 20 Wikipedia links:')
for i, link in enumerate(unique_links[:20], 1):
    print(f'{i:2d}. {link["article_title"]} -> {link["url"]}')

if len(unique_links) > 20:
    print(f'    ... and {len(unique_links) - 20} more links')

# Create comprehensive data structure
archived_page_data = {
    'extraction_info': {
        'extracted_date': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'source_url': url,
        'archive_url': archive_url,
        'archive_date': archive_date,
        'formatted_archive_date': f'{archive_date[:4]}-{archive_date[4:6]}-{archive_date[6:8]} {archive_date[8:10]}:{archive_date[10:12]}:{archive_date[12:14]}',
        'page_title': page_title if 'page_title' in locals() else 'Unknown',
        'content_length': len(clean_text),
        'total_links_found': len(all_links),
        'wikipedia_links_count': len(unique_links)
    },
    'inbound_links': unique_links,
    'page_content': {
        'title': page_title if 'page_title' in locals() else 'Unknown',
        'text_preview': clean_text[:1000] + '...' if len(clean_text) > 1000 else clean_text,
        'full_text_length': len(clean_text)
    }
}

# Save the extracted data
output_file = 'workspace/asoiaf_wikipedia_archived_july_3_2023.json'
with open(output_file, 'w', encoding='utf-8') as f:
    json.dump(archived_page_data, f, indent=2, ensure_ascii=False)

print(f'\n=== EXTRACTION COMPLETE ===\n')
print(f'✓ A Song of Ice and Fire Wikipedia page successfully archived and processed')
print(f'✓ Archive date: {archived_page_data["extraction_info"]["formatted_archive_date"]}')
print(f'✓ Total inbound links extracted: {len(unique_links)}')
print(f'✓ Page content length: {len(clean_text):,} characters')
print(f'✓ Data saved to: {output_file}')

# Now let's check if we have the LOTR outbound links for comparison
print(f'\n=== CHECKING FOR LOTR OUTBOUND LINKS FILE ===\n')

# Check workspace directory for LOTR links file
workspace_files = os.listdir('workspace')
lotr_files = [f for f in workspace_files if 'lotr' in f.lower() or 'lord_of_the_rings' in f.lower()]

print(f'Workspace files: {workspace_files}')
print(f'LOTR-related files: {lotr_files}')

if lotr_files:
    print(f'\n✓ Found LOTR file(s) for comparison: {lotr_files}')
    print(f'Next step: Load and cross-reference the links to find direct connections')
else:
    print(f'\n⚠️ No LOTR outbound links file found in workspace')
    print(f'Will need to extract LOTR links first, or proceed with manual analysis')

print(f'\n=== SUMMARY ===\n')
print(f'Successfully retrieved A Song of Ice and Fire Wikipedia page from July 3, 2023')
print(f'Extracted {len(unique_links)} inbound links for cross-referencing')
print(f'Ready for connection analysis with LOTR outbound links')
```