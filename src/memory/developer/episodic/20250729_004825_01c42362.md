### Development Step 5: Hamiltonian Cycle Detection in Earlâ€™s Graph of 49 Adjacent Green Plots

**Description**: Solve the Hamiltonian path problem to determine if Earl can walk through every plot he owns exactly once and return to his starting plot without backtracking. Using the identified 49 green plots from the previous analysis, construct a graph where each plot is a node and edges connect adjacent plots (horizontally and vertically neighboring cells). Apply graph theory algorithms to check if a Hamiltonian cycle exists in Earl's connected land area, considering movement constraints between adjacent plots only.

**Use Cases**:
- Agricultural field inspection routing to walk through each crop plot exactly once and return to the barn without backtracking
- Warehouse AGV path planning to visit every pallet position in a grid-based storage area and cycle back to the charging station
- Urban street-sweeping route optimization to cover all blocks in a neighborhood exactly once and return to the depot
- Drone flight itinerary for precision agriculture, ensuring each survey plot is captured once before returning to base
- Museum guide-robot tour sequencing to present every exhibit in a gallery without revisiting any room and end at the entrance
- Solar farm maintenance walk-through scheduling so a technician can inspect each panel in sequence and return to the control hut
- PCB assembly robot routing to apply solder paste on all component pads exactly once and return to its home position
- Hospital cleaning robot cycle planning to sanitize each patient room once per shift and return to its docking station

```
import os
import json
from collections import defaultdict, deque

# Load Earl's plot data from the analysis file
analysis_file = 'workspace/earl_smith_complete_analysis.json'

print("Loading Earl's 49 green plots for Hamiltonian path analysis...")
with open(analysis_file, 'r') as f:
    data = json.load(f)

# Extract the green cell plot data
green_plots = data['green_cells']
print(f"Number of Earl's plots: {len(green_plots)}")

# Extract coordinates and create a list of plot positions
plot_coordinates = []
plot_lookup = {}  # Maps (row, col) to plot index

print("\nExtracting plot coordinates:")
for i, plot in enumerate(green_plots):
    row = plot['row']
    col = plot['col']
    address = plot['address']
    plot_coordinates.append((row, col))
    plot_lookup[(row, col)] = i
    print(f"Plot {i}: {address} at ({row}, {col})")

print(f"\nTotal plots extracted: {len(plot_coordinates)}")

# Build adjacency graph - connect horizontally and vertically adjacent plots
print("\nBuilding adjacency graph (connecting neighboring plots)...")
print("Two plots are adjacent if they differ by exactly 1 in row OR column (not diagonal)")

# Create adjacency list representation
adjacency_list = defaultdict(list)

# For each plot, check if its neighbors exist in Earl's plots
for i, (row, col) in enumerate(plot_coordinates):
    # Check 4 possible neighbors: up, down, left, right
    neighbors = [
        (row - 1, col),  # up
        (row + 1, col),  # down
        (row, col - 1),  # left
        (row, col + 1)   # right
    ]
    
    adjacent_count = 0
    for neighbor_row, neighbor_col in neighbors:
        if (neighbor_row, neighbor_col) in plot_lookup:
            neighbor_index = plot_lookup[(neighbor_row, neighbor_col)]
            adjacency_list[i].append(neighbor_index)
            adjacent_count += 1
    
    print(f"Plot {i} at ({row}, {col}) has {adjacent_count} adjacent plots: {adjacency_list[i]}")

# Analyze graph connectivity
print("\n" + "="*70)
print("GRAPH ANALYSIS:")

total_edges = sum(len(neighbors) for neighbors in adjacency_list.values()) // 2
print(f"Total plots (nodes): {len(plot_coordinates)}")
print(f"Total edges: {total_edges}")
print(f"Average degree: {2 * total_edges / len(plot_coordinates):.2f}")

# Check if the graph is connected (required for Hamiltonian cycle)
def is_connected(adj_list, num_nodes):
    """Check if the graph is connected using BFS"""
    if num_nodes == 0:
        return True
    
    visited = [False] * num_nodes
    queue = deque([0])  # Start from node 0
    visited[0] = True
    visited_count = 1
    
    while queue:
        node = queue.popleft()
        for neighbor in adj_list[node]:
            if not visited[neighbor]:
                visited[neighbor] = True
                queue.append(neighbor)
                visited_count += 1
    
    return visited_count == num_nodes

connected = is_connected(adjacency_list, len(plot_coordinates))
print(f"\nGraph connectivity: {'CONNECTED' if connected else 'DISCONNECTED'}")

if not connected:
    print("*** Graph is not connected - Hamiltonian cycle is IMPOSSIBLE ***")
    print("Earl cannot walk through all plots and return to start without backtracking")
else:
    print("Graph is connected - proceeding with Hamiltonian cycle analysis...")

# Save the graph data for Hamiltonian analysis
graph_data = {
    'plot_coordinates': plot_coordinates,
    'plot_lookup': {f'{row},{col}': idx for (row, col), idx in plot_lookup.items()},
    'adjacency_list': {str(k): v for k, v in adjacency_list.items()},
    'graph_stats': {
        'num_nodes': len(plot_coordinates),
        'num_edges': total_edges,
        'is_connected': connected,
        'average_degree': 2 * total_edges / len(plot_coordinates)
    }
}

with open('workspace/earl_hamiltonian_graph.json', 'w') as f:
    json.dump(graph_data, f, indent=2)

print(f"\nGraph data saved to workspace/earl_hamiltonian_graph.json")
print("Ready for Hamiltonian cycle detection algorithm!")
```