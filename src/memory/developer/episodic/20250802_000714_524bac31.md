### Development Step 2: Find Picnic Location by Decrypting Caesar Cipher “Zsmxsm sc sx Zyvilsec Zvkjk.”

**Description**: Decrypt the Caesar cipher message 'Zsmxsm sc sx Zyvilsec Zvkjk.' by testing different shift values to find the correct decryption that reveals a readable English location for the picnic meeting place.

**Use Cases**:
- Decrypting encoded treasure hunt clues in a museum’s mobile app, where visitors solve Caesar-ciphered messages to unlock exhibit content
- Automated analysis of intercepted low-level communications by a small investigative team, quickly filtering out gibberish and highlighting readable location hints
- Educational coding platform feature that demonstrates classical ciphers, auto-brute-forces student-submitted strings, and identifies likely English outputs
- Escape-room game backend tool to validate and test multiple shift variations of puzzle messages, ensuring only one shift yields a coherent meeting spot clue
- Forensic analyst routine for scanning suspects’ digital notes, running Caesar shifts to detect concealed meeting addresses or drop-zone instructions
- Historical archive research assistant to batch-decrypt letters with unknown shifts, flagging those containing readable greetings or place names for further study
- ARG (Alternate Reality Game) content pipeline that auto-validates community-submitted encrypted hints, scoring each shift for common words and proper nouns
- Automated quality check in a spy-novel writing software that ensures any in-story Caesar-ciphered passages resolve to plausible English location descriptions

```
# Caesar cipher decryption - fixing variable scope issue
# The message to decrypt: 'Zsmxsm sc sx Zyvilsec Zvkjk.'

cipher_message = 'Zsmxsm sc sx Zyvilsec Zvkjk.'

print('=== CAESAR CIPHER DECRYPTION ANALYSIS ===')
print(f'Encrypted message: "{cipher_message}"')
print(f'Message length: {len(cipher_message)} characters')
print()

# Function to decrypt Caesar cipher with given shift
def caesar_decrypt(text, shift):
    result = ''
    for char in text:
        if char.isalpha():
            # Determine if uppercase or lowercase
            is_upper = char.isupper()
            # Convert to lowercase for processing
            char = char.lower()
            # Apply shift (subtract for decryption)
            shifted_char = chr((ord(char) - ord('a') - shift) % 26 + ord('a'))
            # Restore original case
            if is_upper:
                shifted_char = shifted_char.upper()
            result += shifted_char
        else:
            # Keep non-alphabetic characters unchanged (spaces, punctuation)
            result += char
    return result

# Define word lists outside the loop to avoid scope issues
common_words = ['the', 'is', 'in', 'at', 'on', 'to', 'of', 'and', 'a', 'an', 'for', 'with', 'picnic']
location_words = ['park', 'street', 'avenue', 'road', 'place', 'square', 'center', 'garden', 'plaza', 'court']

print('Testing all possible shift values (1-25):')
print('=' * 60)

decryption_results = []

for shift in range(1, 26):
    decrypted = caesar_decrypt(cipher_message, shift)
    print(f'Shift {shift:2d}: "{decrypted}"')
    decryption_results.append({
        'shift': shift,
        'decrypted_text': decrypted
    })
    
    # Check if this looks like readable English
    # Look for common English words and patterns
    words = decrypted.lower().replace('.', '').split()
    
    # Check for readable patterns
    has_common_words = any(word in common_words for word in words)
    has_location_words = any(word in location_words for word in words)
    
    if has_common_words or has_location_words:
        print(f'    *** Potentially readable: Contains recognizable words ***')
        found_common = [word for word in words if word in common_words]
        found_location = [word for word in words if word in location_words]
        if found_common:
            print(f'        Common words found: {found_common}')
        if found_location:
            print(f'        Location words found: {found_location}')

print('\n' + '=' * 60)
print('DETAILED ANALYSIS OF ALL CANDIDATES:')
print('=' * 60)

# Analyze each result for English-like characteristics
for result in decryption_results:
    shift = result['shift']
    text = result['decrypted_text']
    words = text.lower().replace('.', '').split()
    
    # Score based on English characteristics
    score = 0
    analysis = []
    
    # Check for common English words
    common_found = [word for word in words if word in common_words]
    if common_found:
        score += len(common_found) * 2
        analysis.append(f'Common words: {common_found}')
    
    # Check for location-related words
    location_found = [word for word in words if word in location_words]
    if location_found:
        score += len(location_found) * 3
        analysis.append(f'Location words: {location_found}')
    
    # Check for proper capitalization patterns (likely place names)
    capitalized_words = [word for word in text.split() if word and word[0].isupper() and len(word) > 1]
    if len(capitalized_words) >= 2:
        score += 2
        analysis.append(f'Capitalized words (likely proper nouns): {capitalized_words}')
    
    # Check for reasonable word lengths and structure
    if words and all(1 <= len(word) <= 12 for word in words):
        score += 1
        analysis.append('Reasonable word lengths')
    
    # Check for sentence structure patterns
    if len(words) >= 4 and len(words) <= 8:  # Reasonable sentence length
        score += 1
        analysis.append('Good sentence length')
    
    # Display results with any score
    if score > 0:
        print(f'\nShift {shift} (Score: {score}): "{text}"')
        for note in analysis:
            print(f'    - {note}')
        
        # If this looks very promising, mark it
        if score >= 4:
            print(f'    *** HIGHLY LIKELY CANDIDATE ***')
        elif score >= 2:
            print(f'    *** POSSIBLE CANDIDATE ***')

print('\n' + '=' * 60)
print('MANUAL INSPECTION FOR LOCATION PATTERNS:')
print('=' * 60)

# Look specifically for patterns that suggest a meeting location
print('Looking for results that form coherent English sentences about a picnic location...')

for result in decryption_results:
    text = result['decrypted_text']
    shift = result['shift']
    words = text.lower().replace('.', '').split()
    
    # Look for patterns that suggest a location description
    if 'is' in words and 'at' in words:
        print(f'\nShift {shift}: "{text}"')
        print('    Contains "is" and "at" - typical location description pattern')
        
        # Check if it makes sense as a location
        if len(words) >= 4:
            print(f'    Sentence structure: {" ".join(words)}')
            if any(word in location_words for word in words):
                print('    *** CONTAINS LOCATION WORDS - STRONG CANDIDATE ***')
    
    # Look for other location patterns
    elif len(words) >= 4 and any(char.isupper() for char in text if char.isalpha()):
        # Check if it has proper nouns (capitalized words) which could be place names
        capitalized = [word for word in text.split() if word and word[0].isupper()]
        if len(capitalized) >= 2:
            print(f'\nShift {shift}: "{text}"')
            print(f'    Multiple proper nouns: {capitalized} - could be place names')

print('\n' + '=' * 60)
print('FINAL ANALYSIS - TOP CANDIDATES:')
print('=' * 60)

# Find the most promising candidates
top_candidates = []
for result in decryption_results:
    text = result['decrypted_text']
    shift = result['shift']
    words = text.lower().replace('.', '').split()
    
    # Calculate final score
    final_score = 0
    reasons = []
    
    # High value for common English patterns
    if 'is' in words and 'at' in words:
        final_score += 5
        reasons.append('Contains "is at" pattern')
    
    # High value for location words
    location_found = [word for word in words if word in location_words]
    if location_found:
        final_score += 4
        reasons.append(f'Location words: {location_found}')
    
    # Value for common words
    common_found = [word for word in words if word in common_words]
    if common_found:
        final_score += len(common_found)
        reasons.append(f'Common words: {common_found}')
    
    # Value for proper sentence structure
    if 4 <= len(words) <= 7:
        final_score += 2
        reasons.append('Good sentence length')
    
    if final_score >= 5:
        top_candidates.append({
            'shift': shift,
            'text': text,
            'score': final_score,
            'reasons': reasons
        })

# Sort by score
top_candidates.sort(key=lambda x: x['score'], reverse=True)

if top_candidates:
    print('\nTOP CANDIDATES (sorted by likelihood):')
    for i, candidate in enumerate(top_candidates, 1):
        print(f'\n{i}. Shift {candidate["shift"]} (Score: {candidate["score"]}): "{candidate["text"]}"')
        for reason in candidate['reasons']:
            print(f'    - {reason}')
        
        if i == 1:  # Mark the top candidate
            print('    *** MOST LIKELY ANSWER ***')
else:
    print('\nNo clear top candidates found. Manual review of all results needed.')

# Save all results for reference
with open('workspace/caesar_decryption_results.txt', 'w') as f:
    f.write('Caesar Cipher Decryption Results\n')
    f.write('=' * 40 + '\n\n')
    f.write(f'Original encrypted message: "{cipher_message}"\n\n')
    f.write('All decryption attempts:\n')
    f.write('-' * 30 + '\n')
    
    for result in decryption_results:
        f.write(f'Shift {result["shift"]:2d}: "{result["decrypted_text"]}"\n')
    
    f.write('\n\nTop Candidates Analysis:\n')
    f.write('-' * 30 + '\n')
    if top_candidates:
        for i, candidate in enumerate(top_candidates, 1):
            f.write(f'{i}. Shift {candidate["shift"]} (Score: {candidate["score"]}): "{candidate["text"]}"\n')
            for reason in candidate['reasons']:
                f.write(f'    - {reason}\n')
            f.write('\n')
    else:
        f.write('No clear top candidates identified.\n')
    
    f.write('\nAnalysis complete. Review results for the correct picnic location.\n')

print(f'\nAll decryption results saved to: workspace/caesar_decryption_results.txt')
print('\n=== DECRYPTION ANALYSIS COMPLETE ===')
```