### Development Step 6: Determine 11th-Move Cell’s Hex Color via BFS on Two-Cell Legal Moves Graph

**Description**: Construct adjacency graph of legal two-cell moves using workspace/grid_data.json and workspace/start_end_coordinates.json and perform a breadth-first search from the START cell to locate the shortest path to the END cell enforcing no immediate backtracking; identify the coordinate of the cell landed on after the 11th move along the resulting path; extract that cell’s 6-digit hex fill color from workspace/grid_data.json.

**Use Cases**:
- Warehouse order fulfillment robot path optimization and shelf-zone status retrieval at the 11th waypoint in an automated distribution center
- Urban traffic management system computing shortest street-level detours and extracting intersection signal phase color at a critical junction
- Emergency evacuation planning in a multi‐floor building layout with hazard‐zone color identification on the eleventh step of escape routes
- Autonomous agricultural rover navigation through a crop grid, avoiding waterlogged plots and reading soil‐moisture heatmap color at the eleventh move
- Video game AI routing through dungeon grids with biome‐specific tile color detection on the eleventh action to trigger in‐game events
- Museum visitor wayfinding app calculating shortest paths between exhibits and pulling thematic exhibit color at a mid‐route checkpoint
- Data center maintenance drone routing between server racks while avoiding hot spots and extracting rack‐status color on the eleventh segment of the route

```
import os
import json
from collections import deque

# 1. Load and inspect the grid_data.json structure
dir_workspace = 'workspace'
grid_json = os.path.join(dir_workspace, 'grid_data.json')
coords_json = os.path.join(dir_workspace, 'start_end_coordinates.json')

print(f"Loading grid data from {grid_json}")
with open(grid_json, 'r', encoding='utf-8') as f:
    grid = json.load(f)
print(f"Total cells in grid: {len(grid)}")
# Inspect keys of one sample cell to confirm structure
if grid:
    sample_keys = list(grid[0].keys())
    print(f"Sample cell keys: {sample_keys}")
else:
    print("WARNING: grid_data.json is empty!")

# 2. Load start/end coordinates and inspect structure
print(f"Loading start/end coords from {coords_json}")
with open(coords_json, 'r', encoding='utf-8') as f:
    se = json.load(f)
print(f"Top-level keys in start_end_coordinates.json: {list(se.keys())}")
start = (se['START']['row'], se['START']['col'])
end   = (se['END']['row'],   se['END']['col'])
print(f"START at {start}, END at {end}\n")

# 3. Build cell_map and determine passable cells (non-blue)
cell_map = {}
passable = set()
for cell in grid:
    r = cell.get('row')
    c = cell.get('col')
    color = cell.get('fill_color', '')
    coord = (r, c)
    cell_map[coord] = cell
    # blue = obstacle
    if color != '0099FF':
        passable.add(coord)
print(f"Passable cells (non-0099FF): {len(passable)} / {len(grid)}\n")

# 4. Build adjacency for one-cell cardinal moves (N, S, E, W)
moves = [(1,0), (-1,0), (0,1), (0,-1)]
adj = {coord: [] for coord in passable}
print("Building adjacency list with one-cell moves...")
for (r, c) in passable:
    nbrs = []
    for dr, dc in moves:
        n = (r+dr, c+dc)
        if n in passable:
            nbrs.append(n)
    adj[(r,c)] = nbrs
# Print adjacency for START and END
print(f"Neighbors of START {start}: {adj.get(start, [])}")
print(f"Neighbors of END   {end}:   {adj.get(end, [])}\n")

# 5. Verify basic reachability via BFS ignoring backtracking
print("Checking basic connectivity from START to END...")
vis = set([start])
dq = deque([start])
while dq:
    cur = dq.popleft()
    for n in adj[cur]:
        if n not in vis:
            vis.add(n)
            dq.append(n)
print(f"Reachable cells from START: {len(vis)}")
if end not in vis:
    print("ERROR: END not reachable under one-cell moves. Exiting.")
    exit(1)
print("END is reachable under one-cell moves.\n")

# 6. BFS shortest-path forbidding immediate backtracking
print("Performing BFS (no immediate backtracking) to find shortest path...")
start_state = (start, None)
queue = deque([(start, None, [start])])
visited_states = set([start_state])
path_to_end = None

while queue:
    cur, prev, path = queue.popleft()
    if cur == end:
        path_to_end = path
        print("Reached END!")
        break
    for n in adj[cur]:
        # forbid backtracking
        if n == prev:
            continue
        state = (n, cur)
        if state not in visited_states:
            visited_states.add(state)
            queue.append((n, cur, path + [n]))

if not path_to_end:
    print("ERROR: No path found under no-backtracking BFS.")
    exit(1)

# 7. Extract the 11th move coordinate and its fill_color
moves_count = len(path_to_end) - 1
print(f"Shortest path length (moves): {moves_count}")
print(f"Full path: {path_to_end}\n")
if moves_count < 11:
    print(f"ERROR: Only {moves_count} moves; cannot extract the 11th move.")
    exit(1)

coord11 = path_to_end[11]
cell11 = cell_map.get(coord11)
hex_color = cell11.get('fill_color', '')
print(f"Coordinate after 11th move: {coord11}")
print(f"Fill color at that cell: {hex_color}\n")

# 8. Save result JSON
oresult = {
    '11th_move_coordinate': {'row': coord11[0], 'col': coord11[1]},
    'fill_color': hex_color,
    'path_moves': moves_count
}
out_path = os.path.join(dir_workspace, 'eleventh_move_result.json')
with open(out_path, 'w', encoding='utf-8') as f:
    json.dump(oresult, f, indent=2)
print(f"Result saved to {out_path}")
```