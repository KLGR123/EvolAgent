### Development Step 4: Greedy Interval Covering for Minimum Cell Tower Placement for Seven Houses

**Description**: Solve the minimum cell phone tower coverage optimization problem using the analyzed house positions from data/gaia/2023/validation/389793a7-ca17-4e82-81cb-2b3a2391b4b9.txt. Apply the greedy algorithm approach for the interval covering problem: (1) Convert each house position to a coverage interval showing all possible tower locations that can reach that house within 4-mile radius, (2) Sort intervals by their end points, (3) Use greedy selection to find minimum towers by repeatedly choosing the rightmost position that covers the leftmost uncovered house, (4) Verify the solution covers all 7 houses and calculate the final minimum number of towers needed.

**Use Cases**:
- Rural broadband expansion scenario: determine optimal tower placement along a 60-mile country road to ensure each farmhouse is within a 4-mile service radius while minimizing infrastructure costs
- Urban 5G microcell network design: optimize small-cell placement along a downtown high-traffic corridor to guarantee apartment buildings on every block fall within the 4-mile coverage window
- Emergency response communication planning: rapidly compute the minimum number of portable towers to deploy along a hurricane-impacted coastline so all temporary shelters lie within 4 miles of a signal source
- Large outdoor event connectivity: plan temporary tower locations around a multi-field music festival site to ensure every vendor booth and stage area stays within a 4-mile coverage radius with minimal equipment
- Pipeline monitoring gateway deployment: calculate optimal sensor gateway positions along a 100-mile oil pipeline so every pressure and flow sensor station is no more than 4 miles from a communication node
- Military field communications: determine placement of mobile radio units along a linear patrol route to maintain continuous 4-mile coverage for all outposts and moving units
- Wildlife tracking network setup: optimize base station locations along migratory bird corridors so all GPS-equipped birds remain within a 4-mile communication range

```
# Step 2: Parse the visual map to extract house positions and convert to 1D coordinates
import os

# Read the house positions data
data_file = 'data/gaia/2023/validation/389793a7-ca17-4e82-81cb-2b3a2391b4b9.txt'

with open(data_file, 'r', encoding='utf-8') as f:
    content = f.read()

print("Parsing house positions from visual map...")
print("Original content:")
print(content)
print("\n" + "="*60)

# Split into lines and analyze the structure
lines = content.strip().split('\n')
print(f"Processing {len(lines)} lines...")

# Extract house positions - focus on lines containing 'H'
house_positions_2d = []
for line_num, line in enumerate(lines):
    print(f"\nLine {line_num + 1}: '{line}'")
    
    # Find all 'H' positions in this line
    for char_pos, char in enumerate(line):
        if char == 'H':
            house_positions_2d.append((line_num, char_pos))
            print(f"  Found house at (row={line_num}, col={char_pos})")

print(f"\nFound {len(house_positions_2d)} houses total:")
for i, (row, col) in enumerate(house_positions_2d, 1):
    print(f"House {i}: row {row}, column {col}")

# Convert 2D positions to 1D positions for the cell tower problem
# For a typical cell tower problem, we consider houses along a straight road
# We can use the column positions as the 1D coordinates along the road
# If houses are on different rows, we need to project them onto a single line

print("\nConverting to 1D positions for cell tower optimization...")
print("Using column positions as 1D coordinates along the road:")

house_positions_1d = []
for i, (row, col) in enumerate(house_positions_2d, 1):
    house_positions_1d.append(col)
    print(f"House {i}: 1D position = {col}")

# Sort positions for easier processing
house_positions_1d.sort()
print(f"\nSorted house positions: {house_positions_1d}")
print(f"Number of houses: {len(house_positions_1d)}")

# Save the extracted positions to workspace
import json

house_data = {
    'original_2d_positions': house_positions_2d,
    '1d_positions_sorted': house_positions_1d,
    'num_houses': len(house_positions_1d),
    'tower_range': 4  # 4-mile radius as mentioned in the problem
}

with open('workspace/house_positions.json', 'w') as f:
    json.dump(house_data, f, indent=2)

print(f"\nHouse position data saved to workspace/house_positions.json")

# Now convert each house to a coverage interval
print("\n" + "="*60)
print("STEP 2: Converting houses to coverage intervals")
print("Each house needs to be covered by a tower within 4-mile radius")
print("For house at position x, a tower can be placed anywhere in [x-4, x+4]")

coverage_intervals = []
for i, house_pos in enumerate(house_positions_1d, 1):
    # Coverage interval: [house_pos - 4, house_pos + 4]
    interval_start = house_pos - 4
    interval_end = house_pos + 4
    coverage_intervals.append((interval_start, interval_end, i))
    print(f"House {i} at position {house_pos}: Tower can be placed in [{interval_start}, {interval_end}]")

print(f"\nGenerated {len(coverage_intervals)} coverage intervals:")
for start, end, house_id in coverage_intervals:
    print(f"Interval for House {house_id}: [{start}, {end}]")

# Save coverage intervals
interval_data = {
    'house_positions': house_positions_1d,
    'coverage_intervals': coverage_intervals,
    'tower_range': 4,
    'problem_description': 'Minimum cell phone tower coverage - each house must be within 4 miles of a tower'
}

with open('workspace/coverage_intervals.json', 'w') as f:
    json.dump(interval_data, f, indent=2)

print(f"\nCoverage intervals saved to workspace/coverage_intervals.json")
print("Ready for greedy algorithm implementation in next step!")
```