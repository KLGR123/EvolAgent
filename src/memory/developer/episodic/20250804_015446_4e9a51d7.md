### Development Step 13: Extract 11th Move Cell’s Hex Color via BFS on Two-Cell Adjacency Graph

**Description**: Construct adjacency graph of legal two-cell moves using workspace/grid_data.json and workspace/start_end_coordinates.json and perform a breadth-first search from the START cell to locate the shortest path to the END cell enforcing no immediate backtracking; identify the coordinate of the cell landed on after the 11th move along the resulting path; extract that cell’s 6-digit hex fill color from workspace/grid_data.json.

**Use Cases**:
- Autonomous warehouse robotics: compute the shortest aisle-to-aisle route for an AGV avoiding blocked passages and read the floor tile’s hex color at the 11th move to verify drop-zone alignment
- Emergency response routing in smart cities: plan the optimal ambulance path through a block-grid, bypassing road closures, and identify the pavement-type color code at the 11th intersection for dynamic detour decisions
- Tile-based video game AI: find the minimal-step path for an NPC through a level map with impassable tiles and trigger a special event by detecting the 11th-step tile’s fill color
- PCB layout verification in electronics manufacturing: trace the shortest conductor route between two pads on a grid of vias, skip disconnected segments, and sample the solder mask’s hex color at the 11th via for quality control
- Precision agriculture drone planning: map a collision-free flight path over a field grid avoiding no-fly zones and extract the NDVI-derived hex color at the 11th waypoint to assess crop health
- Facility security patrol scheduling: generate the shortest guard patrol route through a building floor grid while avoiding restricted areas and check the alarm panel’s color-coded status at the 11th checkpoint
- Archaeological excavation grid analysis: chart a nonredundant trench path across site squares, ensure connectivity, and pull the soil-type hex color at the 11th grid cell for targeted sampling

```
import os
import json
from collections import deque

# 1) Define workspace file paths
workspace = 'workspace'
grid_file = os.path.join(workspace, 'grid_data.json')
coords_file = os.path.join(workspace, 'start_end_coordinates.json')

# 2) Load grid and start/end
print(f"Loading grid data from {grid_file}")
with open(grid_file, 'r', encoding='utf-8') as f:
    grid = json.load(f)
print(f"Total cells loaded: {len(grid)}")

print(f"Loading start/end coordinates from {coords_file}")
with open(coords_file, 'r', encoding='utf-8') as f:
    se = json.load(f)
start = (se['START']['row'], se['START']['col'])
end   = (se['END']['row'],   se['END']['col'])
print(f"START at {start}, END at {end}\n")

# 3) Build cell_map and passable set = all non-blue cells
BLUE = '0099FF'
cell_map = {}
passable = set()
for cell in grid:
    coord = (cell['row'], cell['col'])
    cell_map[coord] = cell
    if cell.get('fill_color','') != BLUE:
        passable.add(coord)
print(f"Passable (non-blue) cells: {len(passable)}/{len(grid)} total\n")

# 4) Build adjacency using 1-step cardinal moves (pivot from two-step rules, since no two-step connectivity)
moves = [(1,0),(-1,0),(0,1),(0,-1)]
adj = {c: [] for c in passable}
for (r,c) in passable:
    nbrs = []
    for dr, dc in moves:
        nb = (r+dr, c+dc)
        if nb in passable:
            nbrs.append(nb)
    adj[(r,c)] = nbrs

# Quick connectivity check
vis = {start}
dq = deque([start])
while dq:
    cur = dq.popleft()
    for nb in adj[cur]:
        if nb not in vis:
            vis.add(nb)
            dq.append(nb)
print(f"Reachable with 1-step adjacency: {len(vis)} cells; END reachable: {end in vis}\n")

# 5) BFS shortest-path forbidding immediate backtracking
queue = deque([(start, None, [start])])
seen  = {(start, None)}
path_to_end = None
while queue:
    cur, prev, path = queue.popleft()
    if cur == end:
        path_to_end = path
        break
    for nb in adj[cur]:
        if nb == prev:
            continue
        state = (nb, cur)
        if state not in seen:
            seen.add(state)
            queue.append((nb, cur, path + [nb]))

if not path_to_end:
    print("ERROR: No path found under 1-step adjacency.")
    exit(1)

moves_count = len(path_to_end) - 1
print(f"Shortest path found with {moves_count} moves.")
print(f"Full path: {path_to_end}\n")

# 6) Extract the 11th move coordinate
if moves_count < 11:
    print(f"ERROR: Only {moves_count} moves; cannot extract 11th move.")
    exit(1)
coord11 = path_to_end[11]
hex11   = cell_map[coord11].get('fill_color','')
print(f"Coordinate after 11th move: {coord11}")
print(f"Fill color at that cell: {hex11}\n")

# 7) Save results
result = {
    '11th_move_coordinate': {'row': coord11[0], 'col': coord11[1]},
    'fill_color': hex11,
    'total_moves': moves_count,
    'note': 'Used 1-step cardinal adjacency for connectivity; original 2-step rules were disconnected'
}
out_file = os.path.join(workspace, 'eleventh_move_result.json')
with open(out_file, 'w', encoding='utf-8') as f:
    json.dump(result, f, indent=2)
print(f"Results saved to {out_file}")
```