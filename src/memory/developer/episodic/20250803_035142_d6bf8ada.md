### Development Step 2: Newton's Method to Four-Decimal Convergence for f(x)=x³+4x²−3x+8 from x₀=−5

**Description**: Implement Newton's Method for the function f(x) = x³ + 4x² - 3x + 8 starting with x₀ = -5. Calculate the derivative f'(x) = 3x² + 8x - 3 and apply the iterative formula xₙ₊₁ = xₙ - f(xₙ)/f'(xₙ). Continue iterations until finding the smallest n where xₙ = xₙ₊₁ when both values are rounded to four decimal places. Track each iteration's values and identify when convergence occurs at the specified precision level.

**Use Cases**:
- Aerospace control system calibration for determining the equilibrium pitch angle by finding the real root of a cubic lift‐force polynomial
- Chemical reactor steady‐state analysis to solve the cubic rate equation for reactant concentration convergence during process optimization
- Analog circuit design validation for locating the operating point in transistor models governed by a cubic current‐voltage characteristic
- Structural engineering beam deflection assessment by computing the root of a cubic bending equation to ensure safety compliance under load
- Robotics inverse kinematics refinement to find actuator joint angles from a cubic displacement equation for precise end‐effector positioning
- Pharmaceutical dissolution modeling to determine the concentration root in a cubic solubility equation for formulating controlled‐release tablets
- Financial model calibration to solve the cubic polynomial arising in yield curve fitting and achieve convergence at target precision
- Computer graphics ray‐surface intersection computation for cubic Bézier patches to accurately render complex curved surfaces

```
# Newton's Method Implementation - Fixed Scoping Issue
# Define functions in global scope and implement iterative formula

import math

# Define the function f(x) = x³ + 4x² - 3x + 8
def f(x):
    """Calculate f(x) = x³ + 4x² - 3x + 8"""
    return x**3 + 4*x**2 - 3*x + 8

# Define the derivative f'(x) = 3x² + 8x - 3
def f_prime(x):
    """Calculate f'(x) = 3x² + 8x - 3"""
    return 3*x**2 + 8*x - 3

print("=== NEWTON'S METHOD IMPLEMENTATION ===")
print("Function: f(x) = x³ + 4x² - 3x + 8")
print("Derivative: f'(x) = 3x² + 8x - 3")
print("Starting point: x₀ = -5")
print("Convergence criteria: x_n = x_(n+1) when rounded to 4 decimal places")
print()

# Initialize variables
x0 = -5
x_current = x0
n = 0
iterations = []

print("Iteration Progress:")
print("n\tx_n\t\t\tf(x_n)\t\t\tf'(x_n)\t\t\tx_(n+1)\t\t\tRounded x_n\tRounded x_(n+1)\tConverged?")
print("-" * 130)

# Newton's Method iterations
while True:
    # Calculate function value and derivative at current point
    fx = f(x_current)
    fpx = f_prime(x_current)
    
    print(f"Step {n}: Evaluating at x = {x_current:.8f}")
    print(f"  f({x_current:.8f}) = {fx:.8f}")
    print(f"  f'({x_current:.8f}) = {fpx:.8f}")
    
    # Check if derivative is zero (would cause division by zero)
    if abs(fpx) < 1e-15:
        print(f"\nError: Derivative is nearly zero at x = {x_current}")
        print("Newton's method cannot continue from this point")
        break
    
    # Calculate next iteration using Newton's formula: x_(n+1) = x_n - f(x_n)/f'(x_n)
    x_next = x_current - fx / fpx
    print(f"  Newton's formula: x_{n+1} = {x_current:.8f} - ({fx:.8f})/({fpx:.8f}) = {x_next:.8f}")
    
    # Round both values to 4 decimal places for convergence check
    x_current_rounded = round(x_current, 4)
    x_next_rounded = round(x_next, 4)
    
    print(f"  Rounded values: x_{n} = {x_current_rounded:.4f}, x_{n+1} = {x_next_rounded:.4f}")
    
    # Store iteration data
    iteration_data = {
        'n': n,
        'x_n': x_current,
        'f_x_n': fx,
        'f_prime_x_n': fpx,
        'x_n_plus_1': x_next,
        'x_n_rounded': x_current_rounded,
        'x_n_plus_1_rounded': x_next_rounded,
        'converged': x_current_rounded == x_next_rounded
    }
    iterations.append(iteration_data)
    
    # Display iteration in table format
    converged_status = "YES" if x_current_rounded == x_next_rounded else "NO"
    print(f"{n}\t{x_current:.10f}\t{fx:.10f}\t{fpx:.10f}\t{x_next:.10f}\t{x_current_rounded:.4f}\t\t{x_next_rounded:.4f}\t\t{converged_status}")
    
    # Check convergence: x_n = x_(n+1) when rounded to 4 decimal places
    if x_current_rounded == x_next_rounded:
        print(f"\n*** CONVERGENCE ACHIEVED AT STEP n = {n} ***")
        print(f"x_{n} rounded to 4 decimal places: {x_current_rounded:.4f}")
        print(f"x_{n+1} rounded to 4 decimal places: {x_next_rounded:.4f}")
        print(f"Since {x_current_rounded:.4f} = {x_next_rounded:.4f}, convergence is achieved.")
        print(f"\nThe smallest n where x_n = x_(n+1) when rounded to 4 decimal places is: n = {n}")
        
        convergence_step = n
        final_x = x_current_rounded
        break
    
    # Move to next iteration
    x_current = x_next
    n += 1
    print(f"  Moving to next iteration: x_{n} = {x_current:.8f}")
    print()
    
    # Safety check to prevent infinite loops
    if n > 50:
        print(f"\nWarning: Maximum iterations (50) reached without convergence")
        convergence_step = None
        final_x = None
        break

print(f"\n=== DETAILED ANALYSIS ===")
print(f"Total iterations performed: {len(iterations)}")
print(f"Starting point: x₀ = {x0}")

if convergence_step is not None:
    print(f"Convergence achieved at step: n = {convergence_step}")
    print(f"Final convergent value: x = {final_x:.4f}")
    
    # Verify this is indeed close to a root by checking f(x)
    final_fx = f(final_x)
    print(f"\nVerification: f({final_x:.4f}) = {final_fx:.8f}")
    
    if abs(final_fx) < 0.1:
        print(f"✓ This is a good approximation of a root (f(x) ≈ 0)")
    else:
        print(f"⚠ This may not be exactly a root, but it's where the method converged")
    
    # Show the progression of values
    print(f"\n=== CONVERGENCE PROGRESSION ===")
    print("Step\tx_n (full precision)\t\tx_n (rounded)\tDifference from previous")
    print("-" * 80)
    
    for i, iteration in enumerate(iterations):
        if i == 0:
            diff = "N/A (initial)"
        else:
            diff = f"{abs(iteration['x_n_rounded'] - iterations[i-1]['x_n_rounded']):.4f}"
        
        print(f"{iteration['n']}\t{iteration['x_n']:.12f}\t{iteration['x_n_rounded']:.4f}\t\t{diff}")
        
        if iteration['converged']:
            print(f"\t*** CONVERGENCE: x_{iteration['n']} = x_{iteration['n']+1} = {iteration['x_n_rounded']:.4f} ***")
            break
else:
    print("Convergence was not achieved within the iteration limit")

# Save detailed results to workspace
print(f"\n=== SAVING RESULTS ===")

with open('workspace/newtons_method_detailed_results.txt', 'w') as f:
    f.write("Newton's Method - Detailed Results\n")
    f.write("=" * 50 + "\n\n")
    f.write(f"Function: f(x) = x³ + 4x² - 3x + 8\n")
    f.write(f"Derivative: f'(x) = 3x² + 8x - 3\n")
    f.write(f"Starting point: x₀ = {x0}\n")
    f.write(f"Convergence criteria: x_n = x_(n+1) when rounded to 4 decimal places\n\n")
    
    if convergence_step is not None:
        f.write(f"RESULT: Convergence achieved at step n = {convergence_step}\n")
        f.write(f"Final value: x = {final_x:.4f}\n")
        f.write(f"Verification: f({final_x:.4f}) = {f(final_x):.8f}\n\n")
    else:
        f.write("RESULT: Convergence not achieved within iteration limit\n\n")
    
    f.write("Detailed Iteration Log:\n")
    f.write("n\tx_n\t\t\t\tf(x_n)\t\t\t\tf'(x_n)\t\t\t\tx_(n+1)\t\t\t\tRounded x_n\tRounded x_(n+1)\tConverged\n")
    f.write("-" * 150 + "\n")
    
    for iteration in iterations:
        f.write(f"{iteration['n']}\t{iteration['x_n']:.12f}\t{iteration['f_x_n']:.12f}\t{iteration['f_prime_x_n']:.12f}\t{iteration['x_n_plus_1']:.12f}\t{iteration['x_n_rounded']:.4f}\t\t{iteration['x_n_plus_1_rounded']:.4f}\t\t{'YES' if iteration['converged'] else 'NO'}\n")
        
        if iteration['converged']:
            f.write(f"\n*** CONVERGENCE ACHIEVED AT STEP n = {iteration['n']} ***\n")
            break

print(f"Detailed results saved to: workspace/newtons_method_detailed_results.txt")

# Final summary
print(f"\n=== FINAL ANSWER ===")
if convergence_step is not None:
    print(f"The smallest n where x_n = x_(n+1) when both values are rounded to 4 decimal places is: n = {convergence_step}")
    print(f"At this step: x_{convergence_step} = x_{convergence_step+1} = {final_x:.4f}")
else:
    print("Convergence was not achieved - method may need different starting point or more iterations")

print(f"\nNewton's Method execution completed successfully!")
```