### Development Step 1: Assess Six Logical Equivalences via Truth Tables and Identify the Non-Equivalent Statement

**Description**: Analyze each of the six given logical statements to determine their logical equivalence by creating truth tables or using logical equivalence rules. Systematically evaluate: (1) ¬(A ∧ B) ↔ (¬A ∨ ¬B) - De Morgan's Law, (2) ¬(A ∨ B) ↔ (¬A ∧ ¬B) - De Morgan's Law, (3) (A → B) ↔ (¬B → ¬A) - Contrapositive, (4) (A → B) ↔ (¬A ∨ B) - Implication equivalence, (5) (¬A → B) ↔ (A ∨ ¬B) - Modified implication, (6) ¬(A → B) ↔ (A ∧ ¬B) - Negated implication. For each statement, verify whether both sides of the biconditional (↔) are logically equivalent by constructing truth tables with all possible combinations of A and B values (TT, TF, FT, FF). Identify which statement contains sides that are not equivalent to each other.

**Use Cases**:
- Hardware verification engineers comparing different versions of a digital circuit’s HDL implementation (e.g., two Verilog modules) to ensure logical equivalence before tape-out
- Software architects validating that newly refactored business rules in an insurance underwriting system match legacy decision tables by generating and comparing truth tables
- E-commerce QA teams automating verification of discount and free-shipping logic after each deployment to prevent unintended promotional flows
- Cybersecurity analysts modeling and cross-checking firewall and access-control policies as propositional formulas to detect conflicts or redundant rules
- Academic researchers integrating automated biconditional checks into a proof assistant to streamline the validation of newly derived logical lemmas
- Healthcare data governance specialists confirming that patient de-identification and consent-check rules satisfy HIPAA compliance by verifying logical equivalences
- Financial compliance officers ensuring that transaction-monitoring logic in anti-money-laundering software aligns exactly with updated regulatory requirements
- Computer science instructors dynamically generating truth tables for students to demonstrate and explore De Morgan’s laws, contrapositives, and implication equivalences

```
# Analyze logical equivalence of six given statements using truth tables
# We'll evaluate each biconditional statement to see if both sides are equivalent

import pandas as pd
from itertools import product

def logical_not(p):
    """Logical NOT operation"""
    return not p

def logical_and(p, q):
    """Logical AND operation"""
    return p and q

def logical_or(p, q):
    """Logical OR operation"""
    return p or q

def logical_implication(p, q):
    """Logical implication: p → q is equivalent to ¬p ∨ q"""
    return (not p) or q

def logical_biconditional(p, q):
    """Logical biconditional: p ↔ q is true when p and q have same truth value"""
    return p == q

# Generate all possible truth value combinations for A and B
truth_values = [True, False]
combinations = list(product(truth_values, repeat=2))

print("Analyzing logical equivalence of six statements using truth tables")
print("=" * 70)
print()

# Statement 1: ¬(A ∧ B) ↔ (¬A ∨ ¬B) - De Morgan's Law
print("Statement 1: ¬(A ∧ B) ↔ (¬A ∨ ¬B) - De Morgan's Law")
print("-" * 50)

results_1 = []
for A, B in combinations:
    left_side = logical_not(logical_and(A, B))  # ¬(A ∧ B)
    right_side = logical_or(logical_not(A), logical_not(B))  # (¬A ∨ ¬B)
    equivalent = left_side == right_side
    
    results_1.append({
        'A': A, 'B': B,
        '¬(A ∧ B)': left_side,
        '(¬A ∨ ¬B)': right_side,
        'Equivalent': equivalent
    })

df_1 = pd.DataFrame(results_1)
print(df_1.to_string(index=False))
all_equivalent_1 = all(row['Equivalent'] for row in results_1)
print(f"\nAll rows equivalent: {all_equivalent_1}")
print()

# Statement 2: ¬(A ∨ B) ↔ (¬A ∧ ¬B) - De Morgan's Law
print("Statement 2: ¬(A ∨ B) ↔ (¬A ∧ ¬B) - De Morgan's Law")
print("-" * 50)

results_2 = []
for A, B in combinations:
    left_side = logical_not(logical_or(A, B))  # ¬(A ∨ B)
    right_side = logical_and(logical_not(A), logical_not(B))  # (¬A ∧ ¬B)
    equivalent = left_side == right_side
    
    results_2.append({
        'A': A, 'B': B,
        '¬(A ∨ B)': left_side,
        '(¬A ∧ ¬B)': right_side,
        'Equivalent': equivalent
    })

df_2 = pd.DataFrame(results_2)
print(df_2.to_string(index=False))
all_equivalent_2 = all(row['Equivalent'] for row in results_2)
print(f"\nAll rows equivalent: {all_equivalent_2}")
print()

# Statement 3: (A → B) ↔ (¬B → ¬A) - Contrapositive
print("Statement 3: (A → B) ↔ (¬B → ¬A) - Contrapositive")
print("-" * 50)

results_3 = []
for A, B in combinations:
    left_side = logical_implication(A, B)  # (A → B)
    right_side = logical_implication(logical_not(B), logical_not(A))  # (¬B → ¬A)
    equivalent = left_side == right_side
    
    results_3.append({
        'A': A, 'B': B,
        '(A → B)': left_side,
        '(¬B → ¬A)': right_side,
        'Equivalent': equivalent
    })

df_3 = pd.DataFrame(results_3)
print(df_3.to_string(index=False))
all_equivalent_3 = all(row['Equivalent'] for row in results_3)
print(f"\nAll rows equivalent: {all_equivalent_3}")
print()

# Statement 4: (A → B) ↔ (¬A ∨ B) - Implication equivalence
print("Statement 4: (A → B) ↔ (¬A ∨ B) - Implication equivalence")
print("-" * 50)

results_4 = []
for A, B in combinations:
    left_side = logical_implication(A, B)  # (A → B)
    right_side = logical_or(logical_not(A), B)  # (¬A ∨ B)
    equivalent = left_side == right_side
    
    results_4.append({
        'A': A, 'B': B,
        '(A → B)': left_side,
        '(¬A ∨ B)': right_side,
        'Equivalent': equivalent
    })

df_4 = pd.DataFrame(results_4)
print(df_4.to_string(index=False))
all_equivalent_4 = all(row['Equivalent'] for row in results_4)
print(f"\nAll rows equivalent: {all_equivalent_4}")
print()

# Statement 5: (¬A → B) ↔ (A ∨ ¬B) - Modified implication
print("Statement 5: (¬A → B) ↔ (A ∨ ¬B) - Modified implication")
print("-" * 50)

results_5 = []
for A, B in combinations:
    left_side = logical_implication(logical_not(A), B)  # (¬A → B)
    right_side = logical_or(A, logical_not(B))  # (A ∨ ¬B)
    equivalent = left_side == right_side
    
    results_5.append({
        'A': A, 'B': B,
        '(¬A → B)': left_side,
        '(A ∨ ¬B)': right_side,
        'Equivalent': equivalent
    })

df_5 = pd.DataFrame(results_5)
print(df_5.to_string(index=False))
all_equivalent_5 = all(row['Equivalent'] for row in results_5)
print(f"\nAll rows equivalent: {all_equivalent_5}")
print()

# Statement 6: ¬(A → B) ↔ (A ∧ ¬B) - Negated implication
print("Statement 6: ¬(A → B) ↔ (A ∧ ¬B) - Negated implication")
print("-" * 50)

results_6 = []
for A, B in combinations:
    left_side = logical_not(logical_implication(A, B))  # ¬(A → B)
    right_side = logical_and(A, logical_not(B))  # (A ∧ ¬B)
    equivalent = left_side == right_side
    
    results_6.append({
        'A': A, 'B': B,
        '¬(A → B)': left_side,
        '(A ∧ ¬B)': right_side,
        'Equivalent': equivalent
    })

df_6 = pd.DataFrame(results_6)
print(df_6.to_string(index=False))
all_equivalent_6 = all(row['Equivalent'] for row in results_6)
print(f"\nAll rows equivalent: {all_equivalent_6}")
print()

# Summary of results
print("=" * 70)
print("SUMMARY OF LOGICAL EQUIVALENCE ANALYSIS")
print("=" * 70)

statements = [
    ("Statement 1: ¬(A ∧ B) ↔ (¬A ∨ ¬B)", all_equivalent_1),
    ("Statement 2: ¬(A ∨ B) ↔ (¬A ∧ ¬B)", all_equivalent_2),
    ("Statement 3: (A → B) ↔ (¬B → ¬A)", all_equivalent_3),
    ("Statement 4: (A → B) ↔ (¬A ∨ B)", all_equivalent_4),
    ("Statement 5: (¬A → B) ↔ (A ∨ ¬B)", all_equivalent_5),
    ("Statement 6: ¬(A → B) ↔ (A ∧ ¬B)", all_equivalent_6)
]

print("\nEquivalence Results:")
for i, (statement, is_equivalent) in enumerate(statements, 1):
    status = "EQUIVALENT" if is_equivalent else "NOT EQUIVALENT"
    print(f"{i}. {statement}: {status}")

# Identify non-equivalent statements
non_equivalent = [stmt for stmt, equiv in statements if not equiv]
print(f"\nNumber of non-equivalent statements: {len(non_equivalent)}")
if non_equivalent:
    print("Non-equivalent statements:")
    for stmt in non_equivalent:
        print(f"  - {stmt}")
else:
    print("All statements are logically equivalent.")

# Save detailed results to workspace
import json

analysis_results = {
    "statement_1": {"description": "¬(A ∧ B) ↔ (¬A ∨ ¬B)", "equivalent": all_equivalent_1, "truth_table": results_1},
    "statement_2": {"description": "¬(A ∨ B) ↔ (¬A ∧ ¬B)", "equivalent": all_equivalent_2, "truth_table": results_2},
    "statement_3": {"description": "(A → B) ↔ (¬B → ¬A)", "equivalent": all_equivalent_3, "truth_table": results_3},
    "statement_4": {"description": "(A → B) ↔ (¬A ∨ B)", "equivalent": all_equivalent_4, "truth_table": results_4},
    "statement_5": {"description": "(¬A → B) ↔ (A ∨ ¬B)", "equivalent": all_equivalent_5, "truth_table": results_5},
    "statement_6": {"description": "¬(A → B) ↔ (A ∧ ¬B)", "equivalent": all_equivalent_6, "truth_table": results_6},
    "summary": {
        "total_statements": 6,
        "equivalent_count": sum([all_equivalent_1, all_equivalent_2, all_equivalent_3, all_equivalent_4, all_equivalent_5, all_equivalent_6]),
        "non_equivalent_count": len(non_equivalent),
        "non_equivalent_statements": non_equivalent
    }
}

with open('workspace/logical_equivalence_analysis.json', 'w') as f:
    json.dump(analysis_results, f, indent=2, default=str)

print(f"\nDetailed analysis results saved to: workspace/logical_equivalence_analysis.json")
```