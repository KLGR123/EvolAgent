### Development Step 2: Maximum Simultaneous Bird Species Identification and Count in YouTube Video Analysis

**Description**: Access and analyze the YouTube video at https://www.youtube.com/watch?v=L1vXCYZAYYM to identify and count bird species visible simultaneously throughout the video. Download the video content, examine it systematically to detect when multiple bird species appear on camera at the same time, and determine the maximum number of different bird species visible in any single moment or frame.

**Use Cases**:
- Wildlife documentary production quality control, verifying the diversity of bird species shown together in key scenes for accurate narration and editing
- Ornithological field research, quantifying species co-occurrence in remote video footage to support ecological studies on interspecies interactions
- Environmental impact assessment for Antarctic expeditions, documenting simultaneous bird species presence to evaluate habitat health and biodiversity
- Automated educational content creation, generating visual examples of multiple bird species for biology lesson plans and interactive classroom materials
- Tourism marketing for nature reserves, selecting video highlights that showcase the greatest diversity of bird species to attract eco-tourists
- AI model training dataset preparation, extracting frames with multiple bird species for use in computer vision algorithms focused on species identification
- Social media campaign analytics for conservation organizations, identifying moments with high species diversity to maximize engagement in wildlife awareness posts
- Museum exhibit curation, sourcing video stills that feature several bird species together for interactive displays and informational panels

```
import os
import subprocess
import json
from datetime import datetime
import cv2
import numpy as np

print("=== BIRD SPECIES ANALYSIS: FRAME EXTRACTION AND ANALYSIS ===\n")

# Check workspace directory and locate video file
workspace_dir = "workspace"
if not os.path.exists(workspace_dir):
    print(f"Error: Workspace directory {workspace_dir} not found")
    exit()

print("=== STEP 1: INSPECTING WORKSPACE CONTENTS ===\n")

# List all files in workspace
workspace_files = []
for filename in os.listdir(workspace_dir):
    full_path = os.path.join(workspace_dir, filename)
    if os.path.isfile(full_path):
        file_size = os.path.getsize(full_path)
        workspace_files.append((filename, full_path, file_size))
        size_mb = file_size / (1024 * 1024)
        print(f"  - {filename} ({size_mb:.2f} MB)")

# Find the downloaded video file
video_file = None
video_id = "L1vXCYZAYYM"

for filename, full_path, size in workspace_files:
    if video_id in filename and any(filename.lower().endswith(ext) for ext in ['.mp4', '.mkv', '.webm', '.avi']):
        video_file = full_path
        print(f"\n*** FOUND VIDEO FILE: {filename} ***")
        print(f"File size: {size / (1024 * 1024):.2f} MB")
        break

if not video_file:
    print("\n*** ERROR: No video file found ***")
    print("Available files:")
    for filename, _, _ in workspace_files:
        print(f"  - {filename}")
    exit()

# Check if we have video info file and inspect its structure first
info_file = None
for filename, full_path, _ in workspace_files:
    if filename.endswith('_info.json'):
        info_file = full_path
        break

if info_file:
    print(f"\n=== INSPECTING VIDEO INFO FILE STRUCTURE ===\n")
    print(f"Info file: {os.path.basename(info_file)}")
    
    # First inspect the JSON structure before loading
    print("Inspecting JSON file structure...")
    with open(info_file, 'r') as f:
        try:
            video_info = json.load(f)
            print(f"JSON loaded successfully with {len(video_info)} top-level keys")
            print("Top-level keys (first 10):")
            for i, key in enumerate(list(video_info.keys())[:10]):
                value_type = type(video_info[key]).__name__
                if isinstance(video_info[key], str):
                    preview = video_info[key][:50] + "..." if len(video_info[key]) > 50 else video_info[key]
                    print(f"  {key}: {value_type} - '{preview}'")
                else:
                    print(f"  {key}: {value_type}")
            
            if len(video_info) > 10:
                print(f"  ... and {len(video_info) - 10} more keys")
            
        except json.JSONDecodeError as e:
            print(f"Error loading JSON: {e}")
            video_info = {}
    
    # Extract key information safely
    print("\nKey video information:")
    print(f"  Title: {video_info.get('title', 'Unknown')}")
    print(f"  Duration: {video_info.get('duration', 0)} seconds")
    print(f"  Uploader: {video_info.get('uploader', 'Unknown')}")
    description = video_info.get('description', '')
    if description:
        print(f"  Description preview: {str(description)[:200]}...")
else:
    print("\nNo video info file found")
    video_info = {}

print(f"\n=== STEP 2: VIDEO ANALYSIS SETUP ===\n")
print(f"Target video: {os.path.basename(video_file)}")
print(f"Objective: Count maximum bird species visible simultaneously")
print(f"Expected species from description: Emperor Penguins, Adelie Penguins, Giant Petrels")
print(f"Analysis approach: Frame extraction at regular intervals for bird detection")

# Load video with OpenCV for analysis
print(f"\n=== STEP 3: LOADING VIDEO FOR FRAME EXTRACTION ===\n")

try:
    cap = cv2.VideoCapture(video_file)
    
    if not cap.isOpened():
        print(f"Error: Could not open video file {video_file}")
        exit()
    
    # Get video properties
    fps = cap.get(cv2.CAP_PROP_FPS)
    total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    duration = total_frames / fps if fps > 0 else 0
    
    print(f"Video properties:")
    print(f"  Resolution: {width}x{height}")
    print(f"  FPS: {fps:.2f}")
    print(f"  Total frames: {total_frames}")
    print(f"  Duration: {duration:.1f} seconds ({duration/60:.1f} minutes)")
    
    print(f"\n=== STEP 4: FRAME EXTRACTION STRATEGY ===\n")
    
    # Extract frames at regular intervals for bird species analysis
    # For a ~2-minute video about penguins, extract frames every 2 seconds for comprehensive coverage
    frame_interval_seconds = 2.0
    frame_interval = int(fps * frame_interval_seconds) if fps > 0 else 60
    
    print(f"Frame extraction strategy:")
    print(f"  Interval: Every {frame_interval_seconds} seconds ({frame_interval} frames)")
    expected_frames = max(1, total_frames // frame_interval) if total_frames > 0 else 10
    print(f"  Expected frames to extract: {expected_frames}")
    
    # Create frames directory
    frames_dir = os.path.join(workspace_dir, "extracted_frames")
    os.makedirs(frames_dir, exist_ok=True)
    print(f"  Frames directory: {frames_dir}")
    
    print(f"\n=== STEP 5: EXTRACTING FRAMES FOR BIRD ANALYSIS ===\n")
    
    extracted_frames = []
    frame_number = 0
    
    while True:
        ret, frame = cap.read()
        if not ret:
            print(f"End of video reached at frame {frame_number}")
            break
        
        # Extract frame at specified intervals
        if frame_number % frame_interval == 0:
            timestamp = frame_number / fps if fps > 0 else frame_number * 0.033  # Assume ~30fps if fps is 0
            frame_filename = f"frame_{frame_number:06d}_t{timestamp:.1f}s.jpg"
            frame_path = os.path.join(frames_dir, frame_filename)
            
            # Save frame
            success = cv2.imwrite(frame_path, frame)
            
            if success:
                frame_info = {
                    'frame_number': frame_number,
                    'timestamp': timestamp,
                    'filename': frame_filename,
                    'path': frame_path
                }
                extracted_frames.append(frame_info)
                
                print(f"Extracted frame {len(extracted_frames)}: {frame_filename} (t={timestamp:.1f}s)")
            else:
                print(f"Failed to save frame {frame_number}")
        
        frame_number += 1
        
        # Safety check to prevent infinite loops
        if frame_number > 20000:  # Reasonable limit for frame processing
            print(f"Reached frame limit safety check at frame {frame_number}")
            break
    
    cap.release()
    
    print(f"\n*** FRAME EXTRACTION COMPLETE ***")
    print(f"Total frames processed: {frame_number}")
    print(f"Total frames extracted: {len(extracted_frames)}")
    
    # Save frame extraction summary
    extraction_summary = {
        'video_file': os.path.basename(video_file),
        'video_properties': {
            'width': width,
            'height': height,
            'fps': fps,
            'total_frames': total_frames,
            'duration_seconds': duration
        },
        'extraction_settings': {
            'interval_seconds': frame_interval_seconds,
            'interval_frames': frame_interval,
            'frames_extracted': len(extracted_frames)
        },
        'extracted_frames': extracted_frames,
        'frames_directory': frames_dir,
        'extraction_timestamp': datetime.now().isoformat(),
        'next_step': 'Analyze frames for bird species detection and counting'
    }
    
    summary_file = os.path.join(workspace_dir, f"{video_id}_frame_extraction_summary.json")
    with open(summary_file, 'w') as f:
        json.dump(extraction_summary, f, indent=2)
    
    print(f"\nFrame extraction summary saved to: {os.path.basename(summary_file)}")
    
    print(f"\n=== STEP 6: INITIAL FRAME ANALYSIS FOR BIRD DETECTION ===\n")
    
    # Analyze a few sample frames to understand content
    sample_frames = extracted_frames[:min(3, len(extracted_frames))]  # Analyze first 3 frames as samples
    
    for i, frame_info in enumerate(sample_frames):
        print(f"\nAnalyzing sample frame {i+1}: {frame_info['filename']}")
        
        # Load frame for analysis
        frame_path = frame_info['path']
        frame = cv2.imread(frame_path)
        
        if frame is not None:
            print(f"  Frame loaded successfully: {frame.shape[1]}x{frame.shape[0]} pixels")
            print(f"  Timestamp: {frame_info['timestamp']:.1f} seconds")
            print(f"  File size: {os.path.getsize(frame_path) / 1024:.1f} KB")
            
            # Basic color analysis to understand frame content for bird detection
            mean_color = np.mean(frame, axis=(0, 1))
            print(f"  Average BGR color: ({mean_color[0]:.1f}, {mean_color[1]:.1f}, {mean_color[2]:.1f})")
            
            # Convert to HSV for better color analysis (useful for bird species detection)
            hsv_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
            mean_hsv = np.mean(hsv_frame, axis=(0, 1))
            print(f"  Average HSV: H={mean_hsv[0]:.1f}, S={mean_hsv[1]:.1f}, V={mean_hsv[2]:.1f}")
            
            # Basic brightness and contrast analysis
            gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            brightness = np.mean(gray_frame)
            contrast = np.std(gray_frame)
            print(f"  Brightness: {brightness:.1f}, Contrast: {contrast:.1f}")
            
            # Look for potential bird-like features (high contrast areas that might be birds)
            # This is a preliminary analysis - full bird detection will come in next phase
            high_contrast_pixels = np.sum(np.abs(gray_frame - brightness) > contrast)
            print(f"  High contrast pixels (potential bird features): {high_contrast_pixels}")
            
        else:
            print(f"  Error: Could not load frame {frame_path}")
    
    print(f"\n=== FRAME EXTRACTION PHASE COMPLETE ===\n")
    print(f"Summary:")
    print(f"  Video analyzed: {os.path.basename(video_file)} (penguin documentary)")
    print(f"  Frames extracted: {len(extracted_frames)} frames at {frame_interval_seconds}s intervals")
    print(f"  Frames saved to: {frames_dir}")
    print(f"  Video duration: {duration:.1f} seconds")
    print(f"  Next phase: Implement bird species detection and simultaneous counting")
    
    # List all created files
    print(f"\nFiles created in workspace:")
    for filename in os.listdir(workspace_dir):
        full_path = os.path.join(workspace_dir, filename)
        if os.path.isfile(full_path):
            size_mb = os.path.getsize(full_path) / (1024 * 1024)
            print(f"  - {filename} ({size_mb:.2f} MB)")
    
    print(f"\nFrames directory contents:")
    if os.path.exists(frames_dir):
        frame_files = os.listdir(frames_dir)
        print(f"  Total frame files: {len(frame_files)}")
        for i, frame_file in enumerate(frame_files[:5]):  # Show first 5 frames
            frame_path = os.path.join(frames_dir, frame_file)
            size_kb = os.path.getsize(frame_path) / 1024
            print(f"  - {frame_file} ({size_kb:.1f} KB)")
        
        if len(frame_files) > 5:
            print(f"  ... and {len(frame_files) - 5} more frame files")
    else:
        print("  Frames directory not found")
        
except Exception as e:
    print(f"\n*** ERROR DURING VIDEO PROCESSING ***")
    print(f"Error: {str(e)}")
    import traceback
    print(f"Full error details: {traceback.format_exc()}")

print("\n*** FRAME EXTRACTION COMPLETE ***")
print("Ready for next phase: Bird species detection and simultaneous counting analysis")
```