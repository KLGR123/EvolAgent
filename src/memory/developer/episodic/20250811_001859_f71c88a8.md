### Development Step 8: Solve an anagram to reveal a famous 100-letter line from Shakespeare's Hamlet.

**Description**: Solve the anagram by rearranging the letters from 'in one of The Bard's best thought of tragedies are insistent hero Hamlet queries on two fronts about how life turns rotten' to find the original Shakespeare line from Hamlet that this phrase represents. Focus on identifying one of Shakespeare's most well-known lines from the tragedy, ensuring all 100 letters are used exactly once in the rearrangement.

**Use Cases**:
- University literature professors creating challenging anagram-based assessments to test students’ knowledge of classic texts and critical thinking skills
- Escape room designers incorporating complex literary anagram puzzles that require solvers to reconstruct famous quotes for game progression
- Digital humanities researchers verifying the authenticity of historical manuscripts by matching scrambled or fragmented text to canonical literary sources
- Automated grading systems for online Shakespeare courses that check student-submitted anagram solutions against original play lines for accuracy
- Educational app developers building interactive games where users solve anagrams to unlock famous passages from classic literature
- Publishers and editors using automated tools to detect and reconstruct misprinted or jumbled lines in digitized versions of public domain works
- Trivia competition organizers generating unique, high-difficulty questions by scrambling iconic literary quotes for contestants to solve
- Museum curators designing interactive exhibits where visitors unscramble anagrams to reveal and learn about significant literary quotations

```
import os
import json
from collections import Counter

print('=== FINAL ANAGRAM SOLVER - SHAKESPEARE HAMLET QUOTE ===')
print('Solving the professor\'s anagram challenge with corrected approach\n')

# Load the anagram data from workspace files
analysis_file = None
for root, dirs, files in os.walk('workspace'):
    for file in files:
        if 'professor_anagram_analysis.json' in file:
            analysis_file = os.path.join(root, file)
            break
    if analysis_file:
        break

if analysis_file and os.path.exists(analysis_file):
    print(f'Loading anagram data from: {analysis_file}')
    with open(analysis_file, 'r', encoding='utf-8') as f:
        analysis_data = json.load(f)
    
    anagram_phrase = analysis_data.get('anagram_phrase_clean', '')
    letters_only = analysis_data.get('letters_only', '')
    letter_frequency = analysis_data.get('letter_frequency', {})
else:
    print('Using known anagram from PLAN:')
    anagram_phrase = 'in one of The Bard\'s best thought of tragedies are insistent hero Hamlet queries on two fronts about how life turns rotten'
    letters_only = ''.join(c.lower() for c in anagram_phrase if c.isalpha())
    letter_frequency = dict(Counter(letters_only))

print(f'Anagram phrase: "{anagram_phrase}"')
print(f'Letters only: "{letters_only}"')
print(f'Letter count: {len(letters_only)}')
print(f'Required letter frequency: {letter_frequency}')

print('\n=== COMPREHENSIVE HAMLET QUOTE TESTING ===')
print('Testing the most likely variations of the famous "To be or not to be" soliloquy...')

# Based on the letter frequency analysis and previous attempts, let's try more targeted variations
# We need exactly: a=5, b=3, d=2, e=13, f=4, g=2, h=6, i=6, l=2, m=1, n=8, o=11, q=1, r=8, s=8, t=14, u=4, w=2

hamlet_quotes_to_test = [
    # The most famous line with different word choices to match letter frequencies
    'To be or not to be that is the question whether tis nobler in the mind to suffer the slings and arrows of outrageous fortune',
    'To be or not to be that is the question whether it is nobler in the mind to suffer the slings and arrows of outrageous fortune',
    'To be or not to be that is the question whether tis nobler in the mind to suffer the slings and arrows of outrageous fate',
    'To be or not to be that is the question whether tis nobler in the mind to suffer the stings and arrows of outrageous fortune',
    'To be or not to be that is the question whether tis nobler in the mind to suffer the slings and darts of outrageous fortune',
    
    # Try with different prepositions and articles
    'To be or not to be that is the question whether tis nobler in mind to suffer the slings and arrows of outrageous fortune',
    'To be or not to be that is the question whether tis nobler in a mind to suffer the slings and arrows of outrageous fortune',
    'To be or not to be that is the question whether tis nobler in the mind to suffer slings and arrows of outrageous fortune',
    
    # Try the continuation with "or to take arms"
    'To be or not to be that is the question whether tis nobler in the mind to suffer or to take arms against a sea of troubles',
    'To be or not to be that is the question whether tis nobler in the mind to suffer or take arms against a sea of troubles',
    'To be or not to be that is the question whether it is nobler in the mind to suffer or to take arms against a sea of troubles',
    'To be or not to be that is the question whether tis nobler in the mind to suffer or to take up arms against a sea of troubles',
    
    # Try with different adjectives
    'To be or not to be that is the question whether tis nobler in the mind to suffer the slings and arrows of cruel fortune',
    'To be or not to be that is the question whether tis nobler in the mind to suffer the slings and arrows of harsh fortune',
    'To be or not to be that is the question whether tis nobler in the mind to suffer the slings and arrows of wicked fortune',
    
    # Try with "and by opposing end them" continuation
    'To be or not to be that is the question whether tis nobler in the mind to suffer or to take arms and by opposing end them',
    'To be or not to be that is the question whether tis nobler in the mind to suffer or take arms and by opposing end them',
    
    # Try variations with different word order
    'To be or not to be that is the question whether in the mind tis nobler to suffer the slings and arrows of outrageous fortune',
    'To be or not to be that is the question whether tis in the mind nobler to suffer the slings and arrows of outrageous fortune',
]

print(f'Testing {len(hamlet_quotes_to_test)} comprehensive variations:')

solution_found = False
for i, quote in enumerate(hamlet_quotes_to_test, 1):
    quote_letters = ''.join(c.lower() for c in quote if c.isalpha())
    quote_frequency = dict(Counter(quote_letters))
    
    print(f'\n{i}. "{quote[:65]}..."')
    print(f'   Letters: {len(quote_letters)}')
    
    if len(quote_letters) == len(letters_only):
        print(f'   *** LENGTH MATCH! ({len(quote_letters)} letters) ***')
        
        if quote_frequency == letter_frequency:
            print(f'   *** PERFECT ANAGRAM MATCH FOUND! ***')
            print(f'   🎉 SOLUTION: "{quote}"')
            
            # Save the solution
            solution_data = {
                'professor_anagram': anagram_phrase,
                'shakespeare_original': quote,
                'source': 'Hamlet Act 3, Scene 1 - The famous "To be or not to be" soliloquy',
                'description': 'One of Shakespeare\'s most well-known lines from Hamlet',
                'verification': {
                    'anagram_letters': letters_only,
                    'solution_letters': quote_letters,
                    'both_have_100_letters': True,
                    'letter_frequencies_match': True,
                    'anagram_frequency': letter_frequency,
                    'solution_frequency': quote_frequency
                },
                'context': 'One of The Bard\'s most famous lines from his best-known tragedy',
                'professor_reward': 'Automatic A on next week\'s quiz'
            }
            
            with open('workspace/shakespeare_anagram_solution.json', 'w', encoding='utf-8') as f:
                json.dump(solution_data, f, indent=2)
            
            print(f'   ✅ Final solution saved to: workspace/shakespeare_anagram_solution.json')
            solution_found = True
            break
        else:
            print(f'   Letter frequencies don\'t match exactly')
            # Show the key differences for debugging
            differences = []
            for letter in sorted(set(letter_frequency.keys()) | set(quote_frequency.keys())):
                need = letter_frequency.get(letter, 0)
                have = quote_frequency.get(letter, 0)
                if need != have:
                    diff = have - need
                    differences.append(f'{letter}: need {need}, have {have} ({diff:+d})')
            if differences:
                print(f'   Differences: {differences[:4]}...')
    else:
        print(f'   Length: {len(quote_letters)} (need {len(letters_only)})')

if not solution_found:
    print('\n=== MANUAL ANAGRAM CONSTRUCTION (FIXED) ===')
    print('Building the quote systematically using exact letter frequencies...')
    
    # Start with the known base and calculate remaining letters correctly
    base_quote = "To be or not to be that is the question"
    base_letters = ''.join(c.lower() for c in base_quote if c.isalpha())
    base_frequency = Counter(base_letters)
    
    print(f'\nBase quote: "{base_quote}"')
    print(f'Base letters used: {len(base_letters)}')
    print(f'Remaining letters needed: {len(letters_only) - len(base_letters)}')
    
    # Calculate remaining letters after the base (fixed the elements() error)
    remaining_frequency = Counter(letters_only)
    for letter, count in base_frequency.items():
        remaining_frequency[letter] -= count
    
    # Remove letters with zero or negative counts and convert back to Counter for elements()
    remaining_frequency = Counter({k: v for k, v in remaining_frequency.items() if v > 0})
    remaining_letters = ''.join(sorted(remaining_frequency.elements()))
    
    print(f'Remaining letters: "{remaining_letters}"')
    print(f'Remaining frequency: {dict(remaining_frequency)}')
    print(f'Remaining letter count: {len(remaining_letters)}')
    
    # Analyze what words we can make with remaining letters
    print('\nAnalyzing possible words from remaining letters:')
    
    # Common words that might appear in the continuation
    possible_words = ['whether', 'tis', 'nobler', 'in', 'the', 'mind', 'to', 'suffer', 'slings', 'arrows', 'outrageous', 'fortune', 'or', 'take', 'arms', 'against', 'sea', 'troubles', 'and', 'by', 'opposing', 'end', 'them']
    
    constructible_words = []
    temp_remaining = Counter(remaining_frequency)
    
    for word in possible_words:
        word_letters = Counter(word.lower())
        # Check if we can construct this word from remaining letters
        if all(temp_remaining[letter] >= count for letter, count in word_letters.items()):
            constructible_words.append(word)
            # Temporarily remove these letters
            for letter, count in word_letters.items():
                temp_remaining[letter] -= count
            print(f'Can construct: "{word}" - remaining after: {sum(temp_remaining.values())} letters')
    
    print(f'\nConstructible words: {constructible_words}')
    
    # Try to build complete quotes using constructible words
    if constructible_words:
        print('\nTrying to build complete quotes with constructible words...')
        
        # Try different combinations of the constructible words
        common_continuations = [
            ' whether tis nobler in the mind to suffer the slings and arrows of outrageous fortune',
            ' whether tis nobler in the mind to suffer or to take arms against a sea of troubles',
            ' whether tis nobler in the mind to suffer or take arms against a sea of troubles and by opposing end them'
        ]
        
        for continuation in common_continuations:
            full_quote = base_quote + continuation
            full_letters = ''.join(c.lower() for c in full_quote if c.isalpha())
            full_frequency = dict(Counter(full_letters))
            
            print(f'\nTesting constructed quote: "{full_quote}"')
            print(f'Length: {len(full_letters)} (need {len(letters_only)})')
            
            if len(full_letters) == len(letters_only):
                print('*** LENGTH MATCHES! ***')
                if full_frequency == letter_frequency:
                    print('*** PERFECT FREQUENCY MATCH! ***')
                    print(f'🎉 CONSTRUCTED SOLUTION: "{full_quote}"')
                    
                    # Save the constructed solution
                    solution_data = {
                        'professor_anagram': anagram_phrase,
                        'shakespeare_original': full_quote,
                        'source': 'Hamlet Act 3, Scene 1',
                        'description': 'The famous "To be or not to be" soliloquy',
                        'method': 'Constructed using systematic letter frequency analysis',
                        'verification': {
                            'anagram_letters': letters_only,
                            'solution_letters': full_letters,
                            'both_have_100_letters': True,
                            'letter_frequencies_match': True,
                            'anagram_frequency': letter_frequency,
                            'solution_frequency': full_frequency
                        }
                    }
                    
                    with open('workspace/shakespeare_anagram_constructed.json', 'w', encoding='utf-8') as f:
                        json.dump(solution_data, f, indent=2)
                    
                    print(f'Constructed solution saved to: workspace/shakespeare_anagram_constructed.json')
                    solution_found = True
                    break
                else:
                    print('Letter frequencies don\'t match')
                    # Show differences
                    diffs = []
                    for letter in sorted(set(letter_frequency.keys()) | set(full_frequency.keys())):
                        need = letter_frequency.get(letter, 0)
                        have = full_frequency.get(letter, 0)
                        if need != have:
                            diffs.append(f'{letter}: {need}→{have}')
                    print(f'Differences: {diffs[:5]}...')

print('\n*** ANAGRAM SOLVING COMPLETE ***')

if solution_found:
    print('\n🎉 SUCCESS: Found the original Shakespeare line!')
    print('\nFINAL ANSWER:')
    print('The professor\'s anagram represents one of Shakespeare\'s most famous lines from Hamlet.')
else:
    print('\n⚠️  Solution not found in current test set.')
    print('The exact Shakespeare line requires precise letter frequency matching.')
    print('\nBased on analysis, this is definitely from the "To be or not to be" soliloquy.')
    print('The solution uses exactly 100 letters with the specific frequency distribution.')

print('\nSUMMARY:')
print(f'- Professor\'s anagram: "{anagram_phrase}"')
print(f'- Contains exactly {len(letters_only)} letters')
print(f'- Required letter frequency: {letter_frequency}')
print(f'- Task: Find the original Shakespeare line from Hamlet')
print(f'- Context: One of The Bard\'s most well-known lines')
print(f'- Source: "To be or not to be" soliloquy from Hamlet Act 3, Scene 1')
print(f'- Reward: Automatic A on next week\'s quiz')
```