### Development Step 9: Find 11th Move Cell Hex Color via BFS on Legal Two-Cell Move Graph

**Description**: Construct adjacency graph of legal two-cell moves using workspace/grid_data.json and workspace/start_end_coordinates.json and perform a breadth-first search from the START cell to locate the shortest path to the END cell enforcing no immediate backtracking; identify the coordinate of the cell landed on after the 11th move along the resulting path; extract that cell’s 6-digit hex fill color from workspace/grid_data.json.

**Use Cases**:
- Warehouse AGV route optimization with color-coded floor zoning: map the storage hall grid, compute legal two-tile hops avoiding restricted blue areas, and retrieve the floor zone color at the 11th stop to adjust forklift speed and load handling.
- Checkers-style board game AI development: represent the game board as a grid of pieces and empty tiles, enforce legal two-cell jumps without backtracking, then identify the 11th landing square’s color to influence strategic evaluation or UI highlight.
- Agricultural drone flight planning over orchards: load a grid of crop sectors with no-fly blue areas, perform two-meter jumps requiring safe mid-air clearance, and extract the 11th sector’s soil-moisture color code to trigger targeted watering.
- Museum guide robot path scheduling: model exhibit spaces as a grid, avoid blue restricted zones, find the shortest no-backtracking tour path, and determine the 11th exhibit’s floor-panel color to synchronize audio narration.
- Data center maintenance robot routing: map server rack aisles on a grid, skip over blocked areas using two-rack jumps, and read the thermal-zone hex color at the 11th rack location to prioritize cooling interventions.
- Geological field survey navigation: convert a rock strata map into a passable grid, execute two-cell leaps across stable layers, and identify the 11th cell’s mineral-composition color to plan targeted coring.
- Hospital cleaning automation: treat wards as a grid with contamination zones marked blue, compute efficient two-room cleaning hops without backtracking, and retrieve the 11th room’s hazard-level color code to deploy specialized disinfectants.
- Smart irrigation network troubleshooting: abstract valve locations as a grid, perform two-pipe jumps where intermediate valves are functional, then extract the 11th valve’s flow-status color to adjust downstream pressure.

```
import os
import json
from collections import deque

# 1) Setup workspace paths
workspace_dir = 'workspace'
grid_file = os.path.join(workspace_dir, 'grid_data.json')
coords_file = os.path.join(workspace_dir, 'start_end_coordinates.json')

# 2) Load grid_data.json
print(f"Loading grid data from {grid_file}")
with open(grid_file, 'r', encoding='utf-8') as f:
    grid = json.load(f)
print(f"Total cells in grid: {len(grid)}")

# Inspect a sample cell structure
if grid:
    print(f"Sample cell keys: {list(grid[0].keys())}\n")

# 3) Load start/end coordinates
print(f"Loading start/end coordinates from {coords_file}")
with open(coords_file, 'r', encoding='utf-8') as f:
    se = json.load(f)
start = (se['START']['row'], se['START']['col'])
end   = (se['END']['row'],   se['END']['col'])
print(f"START coordinate: {start}")
print(f"END   coordinate: {end}\n")

# 4) Build cell_map and passable set (all non-blue = fill_color != '0099FF')
cell_map = {}
passable = set()
for cell in grid:
    coord = (cell['row'], cell['col'])
    cell_map[coord] = cell
    if cell.get('fill_color', '') != '0099FF':  # non-blue is passable
        passable.add(coord)
print(f"Passable (non-blue) cells: {len(passable)} / {len(grid)}\n")

# 5) Build adjacency list for two-cell cardinal jumps with intermediate-cell passability
moves = [( 2, 0), (-2, 0), (0,  2), (0, -2)]
adj = {coord: [] for coord in passable}
print("Building adjacency (cardinal two-cell jumps requiring mid-cell passable)...")
for (r, c) in passable:
    nbrs = []
    for dr, dc in moves:
        mid  = (r + dr//2, c + dc//2)
        dest = (r + dr,      c + dc)
        if mid in passable and dest in passable:
            nbrs.append(dest)
    adj[(r, c)] = nbrs
# Print neighbors for START and END for verification
print(f"Neighbors of START {start}: {adj.get(start, [])}")
print(f"Neighbors of END   {end}:   {adj.get(end,   [])}\n")

# 6) Basic BFS reachability check (ignoring no-backtracking)
print("Checking basic reachability from START to END...")
visited = {start}
queue = deque([start])
while queue:
    cur = queue.popleft()
    for n in adj[cur]:
        if n not in visited:
            visited.add(n)
            queue.append(n)
print(f"Reachable cells from START: {len(visited)}")
if end not in visited:
    print("ERROR: END not reachable under two-cell jump rules.")
    exit(1)
print("END is reachable under two-cell jump rules.\n")

# 7) BFS shortest-path forbidding immediate backtracking
print("Performing BFS (no immediate backtracking) to find the shortest path...")
seen = {(start, None)}
queue = deque([(start, None, [start])])
path_to_end = None
while queue:
    cur, prev, path = queue.popleft()
    if cur == end:
        path_to_end = path
        break
    for n in adj[cur]:
        if n == prev:
            continue
        state = (n, cur)
        if state not in seen:
            seen.add(state)
            queue.append((n, cur, path + [n]))

if not path_to_end:
    print("ERROR: No path found under no-backtracking BFS.")
    exit(1)

moves_count = len(path_to_end) - 1
print(f"Shortest path moves count: {moves_count}")
print(f"Full path: {path_to_end}\n")

# 8) Extract the 11th move coordinate and its fill_color
if moves_count < 11:
    print(f"ERROR: Path has only {moves_count} moves; cannot extract 11th move.")
    exit(1)
coord11 = path_to_end[11]
cell11  = cell_map[coord11]
hex_color = cell11.get('fill_color', '')
print(f"Coordinate after 11th move: {coord11}")
print(f"Fill color at that cell: {hex_color}\n")

# 9) Save results to workspace/eleventh_move_result.json
result = {
    '11th_move_coordinate': {'row': coord11[0], 'col': coord11[1]},
    'fill_color': hex_color,
    'path_moves': moves_count
}
out_file = os.path.join(workspace_dir, 'eleventh_move_result.json')
with open(out_file, 'w', encoding='utf-8') as f:
    json.dump(result, f, indent=2)
print(f"Results saved to {out_file}")
```