### Development Step 7: Solve an anagram to reveal a famous 100-letter line from Shakespeare’s Hamlet using all letters once.

**Description**: Solve the anagram by rearranging the letters from 'in one of The Bard's best thought of tragedies are insistent hero Hamlet queries on two fronts about how life turns rotten' to find the original Shakespeare line from Hamlet that this phrase represents. Focus on identifying one of Shakespeare's most well-known lines from the tragedy, ensuring all 100 letters are used exactly once in the rearrangement.

**Use Cases**:
- Literary scholarship: Verifying the authenticity of Shakespearean quotations in academic research by matching anagrams to original text.
- Educational technology: Creating interactive classroom puzzles where students solve anagrams to learn famous literary lines.
- Digital humanities: Automating the identification and reconstruction of scrambled literary passages for corpus analysis projects.
- Museum exhibit design: Generating engaging displays that challenge visitors to decode anagrams of iconic quotes using systematic algorithms.
- Publishing workflow: Ensuring accurate reproduction of classic texts by cross-checking anagrammed promotional material against the source.
- Game development: Integrating advanced anagram solvers into word-based puzzle games featuring historical literature.
- Copyright and plagiarism detection: Analyzing reworded or disguised Shakespearean content to confirm proper attribution in digital media.
- Archival restoration: Reconstructing damaged or incomplete manuscripts by matching letter frequencies to known literary works.

```
import os
import json
from collections import Counter
import itertools

print('=== ADVANCED ANAGRAM SOLVER FOR HAMLET QUOTE ===')
print('Using systematic letter frequency matching to find the exact Shakespeare line\n')

# Load the anagram data from workspace files
analysis_file = None
for root, dirs, files in os.walk('workspace'):
    for file in files:
        if 'professor_anagram_analysis.json' in file:
            analysis_file = os.path.join(root, file)
            break
    if analysis_file:
        break

if analysis_file and os.path.exists(analysis_file):
    print(f'Loading anagram data from: {analysis_file}')
    with open(analysis_file, 'r', encoding='utf-8') as f:
        analysis_data = json.load(f)
    
    anagram_phrase = analysis_data.get('anagram_phrase_clean', '')
    letters_only = analysis_data.get('letters_only', '')
    letter_frequency = analysis_data.get('letter_frequency', {})
else:
    print('Using known anagram from PLAN:')
    anagram_phrase = 'in one of The Bard\'s best thought of tragedies are insistent hero Hamlet queries on two fronts about how life turns rotten'
    letters_only = ''.join(c.lower() for c in anagram_phrase if c.isalpha())
    letter_frequency = dict(Counter(letters_only))

print(f'Anagram phrase: "{anagram_phrase}"')
print(f'Letters only: "{letters_only}"')
print(f'Letter count: {len(letters_only)}')
print(f'Required letter frequency: {letter_frequency}')

print('\n=== SYSTEMATIC HAMLET QUOTE VARIATIONS ===')
print('Testing multiple variations of famous Hamlet quotes with exactly 100 letters...')

# Based on the letter frequency analysis, let's try more targeted variations
# We need: a=5, b=3, d=2, e=13, f=4, g=2, h=6, i=6, l=2, m=1, n=8, o=11, q=1, r=8, s=8, t=14, u=4, w=2

hamlet_quote_variations = [
    # The classic "To be or not to be" with different completions to get exactly 100 letters
    'To be or not to be that is the question whether tis nobler in the mind to suffer the slings and arrows of outrageous fortune',
    'To be or not to be that is the question whether it is nobler in the mind to suffer the slings and arrows of outrageous fortune',
    'To be or not to be that is the question whether tis nobler in the mind to suffer the slings and arrows of outrageous fate',
    'To be or not to be that is the question whether tis nobler in mind to suffer the slings and arrows of outrageous fortune',
    'To be or not to be that is the question whether tis nobler in the mind to suffer slings and arrows of outrageous fortune',
    
    # Try with different word choices that might match the frequency
    'To be or not to be that is the question whether it be nobler in the mind to suffer the slings and arrows of outrageous fortune',
    'To be or not to be that is the question whether tis nobler in the mind to suffer the slings and arrows of fortune outrageous',
    'To be or not to be that is the question whether tis nobler in the mind to suffer the slings and arrows of cruel fortune',
    'To be or not to be that is the question whether tis nobler in the mind to suffer the slings and arrows of harsh fortune',
    
    # Try variations with "'tis" vs "it is" and other word substitutions
    'To be or not to be that is the question whether tis nobler in the mind to suffer the stings and arrows of outrageous fortune',
    'To be or not to be that is the question whether tis nobler in the mind to suffer the slings and darts of outrageous fortune',
    'To be or not to be that is the question whether tis nobler in the mind to suffer the slings and arrows of wicked fortune',
    
    # Try with different article usage
    'To be or not to be that is the question whether tis nobler in mind to suffer slings and arrows of outrageous fortune',
    'To be or not to be that is the question whether tis nobler in a mind to suffer the slings and arrows of outrageous fortune',
    
    # Try the continuation of the soliloquy
    'To be or not to be that is the question whether tis nobler in the mind to suffer or to take arms against a sea of troubles',
    'To be or not to be that is the question whether tis nobler in the mind to suffer or take arms against a sea of troubles',
    'To be or not to be that is the question whether tis nobler in the mind to suffer or to take up arms against a sea of troubles',
]

print(f'Testing {len(hamlet_quote_variations)} variations of Hamlet quotes:')

solution_found = False
for i, quote in enumerate(hamlet_quote_variations, 1):
    quote_letters = ''.join(c.lower() for c in quote if c.isalpha())
    quote_frequency = dict(Counter(quote_letters))
    
    print(f'\n{i}. "{quote[:60]}..."')
    print(f'   Letters: {len(quote_letters)}')
    
    if len(quote_letters) == len(letters_only):
        print(f'   *** LENGTH MATCH! ({len(quote_letters)} letters) ***')
        
        if quote_frequency == letter_frequency:
            print(f'   *** PERFECT ANAGRAM MATCH FOUND! ***')
            print(f'   🎉 SOLUTION: "{quote}"')
            
            # Save the solution
            solution_data = {
                'professor_anagram': anagram_phrase,
                'shakespeare_original': quote,
                'source': 'Hamlet Act 3, Scene 1 - The famous soliloquy',
                'description': 'To be or not to be soliloquy - one of Shakespeare\'s most well-known lines',
                'verification': {
                    'anagram_letters': letters_only,
                    'solution_letters': quote_letters,
                    'both_have_100_letters': True,
                    'letter_frequencies_match': True,
                    'anagram_frequency': letter_frequency,
                    'solution_frequency': quote_frequency
                },
                'context': 'One of The Bard\'s most famous lines from his best-known tragedy'
            }
            
            with open('workspace/hamlet_anagram_solution_final.json', 'w', encoding='utf-8') as f:
                json.dump(solution_data, f, indent=2)
            
            print(f'   ✅ Final solution saved to: workspace/hamlet_anagram_solution_final.json')
            solution_found = True
            break
        else:
            print(f'   Letter frequencies don\'t match')
            # Show the most significant differences
            differences = []
            for letter in sorted(set(letter_frequency.keys()) | set(quote_frequency.keys())):
                need = letter_frequency.get(letter, 0)
                have = quote_frequency.get(letter, 0)
                if need != have:
                    differences.append(f'{letter}: need {need}, have {have}')
            if differences:
                print(f'   Key differences: {differences[:3]}...')
    else:
        print(f'   Length: {len(quote_letters)} (need {len(letters_only)})')

if not solution_found:
    print('\n=== CONSTRUCTIVE ANAGRAM APPROACH ===')
    print('Building the quote systematically using the exact letter frequencies...')
    
    # Let's try to construct the quote more systematically
    # We know it starts with "To be or not to be that is the question"
    base_quote = "To be or not to be that is the question"
    base_letters = ''.join(c.lower() for c in base_quote if c.isalpha())
    base_frequency = Counter(base_letters)
    
    print(f'\nBase quote: "{base_quote}"')
    print(f'Base letters used: {len(base_letters)}')
    print(f'Remaining letters needed: {len(letters_only) - len(base_letters)}')
    
    # Calculate remaining letters after the base
    remaining_frequency = Counter(letters_only)
    for letter, count in base_frequency.items():
        remaining_frequency[letter] -= count
    
    # Remove letters with zero or negative counts
    remaining_frequency = {k: v for k, v in remaining_frequency.items() if v > 0}
    remaining_letters = ''.join(remaining_frequency.elements())
    
    print(f'Remaining letters: "{remaining_letters}"')
    print(f'Remaining frequency: {dict(remaining_frequency)}')
    
    # Try to complete the quote with the remaining letters
    print('\nTrying to complete with remaining letters...')
    
    # Common continuations of the "To be or not to be" soliloquy
    continuations = [
        ' whether tis nobler in the mind to suffer the slings and arrows of outrageous fortune',
        ' whether it is nobler in the mind to suffer the slings and arrows of outrageous fortune',
        ' whether tis nobler in the mind to suffer or to take arms against a sea of troubles',
        ' whether tis nobler in mind to suffer the slings and arrows of outrageous fortune',
        ' whether tis nobler in the mind to suffer the stings and arrows of outrageous fortune'
    ]
    
    for continuation in continuations:
        full_quote = base_quote + continuation
        full_letters = ''.join(c.lower() for c in full_quote if c.isalpha())
        full_frequency = dict(Counter(full_letters))
        
        print(f'\nTrying: "{full_quote}"')
        print(f'Length: {len(full_letters)}')
        
        if len(full_letters) == len(letters_only) and full_frequency == letter_frequency:
            print(f'*** PERFECT MATCH FOUND! ***')
            print(f'🎉 SOLUTION: "{full_quote}"')
            
            # Save the solution
            solution_data = {
                'professor_anagram': anagram_phrase,
                'shakespeare_original': full_quote,
                'source': 'Hamlet Act 3, Scene 1',
                'description': 'The famous "To be or not to be" soliloquy',
                'verification': {
                    'anagram_letters': letters_only,
                    'solution_letters': full_letters,
                    'both_have_100_letters': True,
                    'letter_frequencies_match': True,
                    'anagram_frequency': letter_frequency,
                    'solution_frequency': full_frequency
                }
            }
            
            with open('workspace/hamlet_anagram_solution_constructed.json', 'w', encoding='utf-8') as f:
                json.dump(solution_data, f, indent=2)
            
            print(f'Solution saved to: workspace/hamlet_anagram_solution_constructed.json')
            solution_found = True
            break

if not solution_found:
    print('\n=== MANUAL LETTER ANALYSIS ===')
    print('Analyzing the specific letter distribution to find the exact match...')
    
    # Let's look at the unusual letters that might give us clues
    print(f'\nUnusual letter counts in our anagram:')
    print(f'- q: {letter_frequency.get("q", 0)} (appears in "question")')
    print(f'- w: {letter_frequency.get("w", 0)} (might be in "arrows" or "outrageous")')
    print(f'- m: {letter_frequency.get("m", 0)} (might be in "mind" or "arms")')
    print(f'- g: {letter_frequency.get("g", 0)} (might be in "outrageous" or "against")')
    
    # The high frequency letters
    print(f'\nHigh frequency letters:')
    print(f'- t: {letter_frequency.get("t", 0)} (very high - suggests multiple "to", "that", "the")')
    print(f'- e: {letter_frequency.get("e", 0)} (very high - common in English)')
    print(f'- o: {letter_frequency.get("o", 0)} (high - suggests "or", "not", "of")')
    print(f'- n: {letter_frequency.get("n", 0)} (high - suggests "not", "in", "and")')
    print(f'- r: {letter_frequency.get("r", 0)} (high - suggests "or", "arrows")')
    print(f'- s: {letter_frequency.get("s", 0)} (high - suggests "is", "slings")')
    
    print('\nBased on letter analysis, this is definitely the "To be or not to be" soliloquy.')
    print('The exact wording must match the specific letter frequencies given.')

print('\n*** ANAGRAM SOLVING COMPLETE ***')
if solution_found:
    print('\n🎉 SUCCESS: Found the original Shakespeare line!')
else:
    print('\n⚠️  No exact match found in tested variations.')
    print('The solution requires the precise wording that matches the letter frequency distribution.')

print('\nSUMMARY:')
print(f'- Professor\'s anagram: "{anagram_phrase}"')
print(f'- Contains exactly {len(letters_only)} letters')
print(f'- Task: Find the original Shakespeare line from Hamlet')
print(f'- Context: One of The Bard\'s most well-known lines')
print(f'- Expected source: "To be or not to be" soliloquy from Hamlet Act 3, Scene 1')
```