### Development Step 3: Detect and Count Maximum Simultaneous Bird Species in YouTube Video

**Description**: Access and analyze the YouTube video at https://www.youtube.com/watch?v=L1vXCYZAYYM to identify and count bird species visible simultaneously throughout the video. Download the video content, examine it frame by frame or at regular intervals to detect when multiple bird species appear on camera at the same time, and determine the maximum number of different bird species visible in any single moment or frame.

**Use Cases**:
- Wildlife conservation monitoring in nature reserves: automated extraction and analysis of drone footage to count simultaneous bird species presence during nesting season
- Airport runway safety assessment: processing continuous CCTV footage to detect and count multiple bird species flocking near tarmacs for hazard mitigation
- Agricultural pest management: analyzing fixed-field camera feeds to identify and quantify bird species that may damage crops and optimize deterrent strategies
- Ecotourism live stream enhancement: extracting frames from feeding‐station video to provide real‐time species diversity stats for tour operators and guests
- Urban biodiversity studies: monitoring rooftop and park cameras to track bird species diversity and population trends in metropolitan areas for city planners
- Citizen science platforms: automating the processing of community‐uploaded birdwatching videos to extract frames and count species for public biodiversity databases
- Documentary production quality control: film crews using frame analysis to ensure coverage of target bird species and maximize shots featuring multiple species simultaneously

```
import os
import subprocess
import json
from datetime import datetime
import cv2
import numpy as np

print("=== BIRD SPECIES ANALYSIS: FRAME EXTRACTION AND ANALYSIS ===\n")

# First, let's fix the variable naming issue and check workspace contents
workspace_dir = "workspace"
if not os.path.exists(workspace_dir):
    print(f"Error: Workspace directory {workspace_dir} not found")
    exit()

print("=== STEP 1: INSPECTING WORKSPACE CONTENTS ===\n")

# List all files in workspace with proper variable naming
workspace_files = []
for file_name in os.listdir(workspace_dir):
    full_path = os.path.join(workspace_dir, file_name)
    if os.path.isfile(full_path):
        file_size = os.path.getsize(full_path)
        workspace_files.append((file_name, full_path, file_size))
        size_mb = file_size / (1024 * 1024)
        print(f"  - {file_name} ({size_mb:.2f} MB)")

# Find the downloaded video file with proper variable scoping
video_file = None
video_id = "L1vXCYZAYYM"
video_extensions = ['.mp4', '.mkv', '.webm', '.avi']

for file_name, full_path, size in workspace_files:
    # Check if this file contains the video ID and has a video extension
    if video_id in file_name:
        for ext in video_extensions:
            if file_name.lower().endswith(ext):
                video_file = full_path
                print(f"\n*** FOUND VIDEO FILE: {file_name} ***")
                print(f"File size: {size / (1024 * 1024):.2f} MB")
                break
    if video_file:  # Break outer loop if video found
        break

if not video_file:
    print("\n*** ERROR: No video file found ***")
    print("Available files:")
    for file_name, _, _ in workspace_files:
        print(f"  - {file_name}")
    exit()

# Check if we have video info file and inspect it
info_file = None
for file_name, full_path, _ in workspace_files:
    if file_name.endswith('_info.json'):
        info_file = full_path
        break

if info_file:
    print(f"\n=== INSPECTING VIDEO INFO FILE ===\n")
    print(f"Info file: {os.path.basename(info_file)}")
    
    # First inspect the structure of the JSON file
    print("Inspecting JSON file structure...")
    with open(info_file, 'r') as f:
        try:
            video_info = json.load(f)
            print(f"JSON loaded successfully with {len(video_info)} top-level keys")
            print("Top-level keys:")
            for key in list(video_info.keys())[:10]:  # Show first 10 keys
                value_type = type(video_info[key]).__name__
                if isinstance(video_info[key], str):
                    preview = video_info[key][:50] + "..." if len(video_info[key]) > 50 else video_info[key]
                    print(f"  {key}: {value_type} - '{preview}'")
                else:
                    print(f"  {key}: {value_type}")
            
            if len(video_info) > 10:
                print(f"  ... and {len(video_info) - 10} more keys")
            
        except json.JSONDecodeError as e:
            print(f"Error loading JSON: {e}")
            video_info = {}
    
    # Extract key information safely
    print("\nVideo information:")
    print(f"  Title: {video_info.get('title', 'Unknown')}")
    print(f"  Duration: {video_info.get('duration', 0)} seconds")
    print(f"  Uploader: {video_info.get('uploader', 'Unknown')}")
    description = video_info.get('description', '')
    if description:
        print(f"  Description preview: {str(description)[:200]}...")
else:
    print("\nNo video info file found")

print(f"\n=== STEP 2: VIDEO ANALYSIS SETUP ===\n")
print(f"Target video: {os.path.basename(video_file)}")
print(f"Objective: Count maximum bird species visible simultaneously")
print(f"Analysis approach: Frame extraction at regular intervals")

# Load video with OpenCV
print(f"\n=== STEP 3: LOADING VIDEO FOR ANALYSIS ===\n")

try:
    cap = cv2.VideoCapture(video_file)
    
    if not cap.isOpened():
        print(f"Error: Could not open video file {video_file}")
        exit()
    
    # Get video properties
    fps = cap.get(cv2.CAP_PROP_FPS)
    total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    duration = total_frames / fps if fps > 0 else 0
    
    print(f"Video properties:")
    print(f"  Resolution: {width}x{height}")
    print(f"  FPS: {fps:.2f}")
    print(f"  Total frames: {total_frames}")
    print(f"  Duration: {duration:.1f} seconds")
    
    print(f"\n=== STEP 4: FRAME EXTRACTION STRATEGY ===\n")
    
    # Extract frames at regular intervals for analysis
    # For a 2-minute video, extract frames every 2 seconds to get good coverage
    frame_interval_seconds = 2.0
    frame_interval = int(fps * frame_interval_seconds) if fps > 0 else 60
    
    print(f"Frame extraction strategy:")
    print(f"  Interval: Every {frame_interval_seconds} seconds ({frame_interval} frames)")
    expected_frames = max(1, total_frames // frame_interval) if total_frames > 0 else 10
    print(f"  Expected frames to extract: {expected_frames}")
    
    # Create frames directory
    frames_dir = os.path.join(workspace_dir, "extracted_frames")
    os.makedirs(frames_dir, exist_ok=True)
    print(f"  Frames directory: {frames_dir}")
    
    print(f"\n=== STEP 5: EXTRACTING FRAMES ===\n")
    
    extracted_frames = []
    frame_number = 0
    
    while True:
        ret, frame = cap.read()
        if not ret:
            print(f"End of video reached at frame {frame_number}")
            break
        
        # Extract frame at specified intervals
        if frame_number % frame_interval == 0:
            timestamp = frame_number / fps if fps > 0 else frame_number * 0.033  # Assume ~30fps if fps is 0
            frame_filename = f"frame_{frame_number:06d}_t{timestamp:.1f}s.jpg"
            frame_path = os.path.join(frames_dir, frame_filename)
            
            # Save frame
            success = cv2.imwrite(frame_path, frame)
            
            if success:
                frame_info = {
                    'frame_number': frame_number,
                    'timestamp': timestamp,
                    'filename': frame_filename,
                    'path': frame_path
                }
                extracted_frames.append(frame_info)
                
                print(f"Extracted frame {len(extracted_frames)}: {frame_filename} (t={timestamp:.1f}s)")
            else:
                print(f"Failed to save frame {frame_number}")
        
        frame_number += 1
        
        # Safety check to prevent infinite loops
        if frame_number > 10000:  # Reasonable limit for frame processing
            print(f"Reached frame limit safety check at frame {frame_number}")
            break
    
    cap.release()
    
    print(f"\n*** FRAME EXTRACTION COMPLETE ***")
    print(f"Total frames processed: {frame_number}")
    print(f"Total frames extracted: {len(extracted_frames)}")
    
    # Save frame extraction summary
    extraction_summary = {
        'video_file': os.path.basename(video_file),
        'video_properties': {
            'width': width,
            'height': height,
            'fps': fps,
            'total_frames': total_frames,
            'duration_seconds': duration
        },
        'extraction_settings': {
            'interval_seconds': frame_interval_seconds,
            'interval_frames': frame_interval,
            'frames_extracted': len(extracted_frames)
        },
        'extracted_frames': extracted_frames,
        'frames_directory': frames_dir,
        'extraction_timestamp': datetime.now().isoformat(),
        'next_step': 'Analyze frames for bird species detection'
    }
    
    summary_file = os.path.join(workspace_dir, f"{video_id}_frame_extraction_summary.json")
    with open(summary_file, 'w') as f:
        json.dump(extraction_summary, f, indent=2)
    
    print(f"\nFrame extraction summary saved to: {os.path.basename(summary_file)}")
    
    print(f"\n=== STEP 6: INITIAL FRAME ANALYSIS ===\n")
    
    # Load and display info about a few sample frames
    sample_frames = extracted_frames[:min(3, len(extracted_frames))]  # Analyze first 3 frames as samples
    
    for i, frame_info in enumerate(sample_frames):
        print(f"\nAnalyzing sample frame {i+1}: {frame_info['filename']}")
        
        # Load frame for analysis
        frame_path = frame_info['path']
        frame = cv2.imread(frame_path)
        
        if frame is not None:
            print(f"  Frame loaded successfully: {frame.shape[1]}x{frame.shape[0]} pixels")
            print(f"  Timestamp: {frame_info['timestamp']:.1f} seconds")
            print(f"  File size: {os.path.getsize(frame_path) / 1024:.1f} KB")
            
            # Basic color analysis to understand frame content
            mean_color = np.mean(frame, axis=(0, 1))
            print(f"  Average BGR color: ({mean_color[0]:.1f}, {mean_color[1]:.1f}, {mean_color[2]:.1f})")
            
            # Convert to HSV for better analysis
            hsv_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
            mean_hsv = np.mean(hsv_frame, axis=(0, 1))
            print(f"  Average HSV: H={mean_hsv[0]:.1f}, S={mean_hsv[1]:.1f}, V={mean_hsv[2]:.1f}")
        else:
            print(f"  Error: Could not load frame {frame_path}")
    
    print(f"\n=== FRAME EXTRACTION PHASE COMPLETE ===\n")
    print(f"Summary:")
    print(f"  Video analyzed: {os.path.basename(video_file)} (2-minute penguin documentary)")
    print(f"  Frames extracted: {len(extracted_frames)} frames at {frame_interval_seconds}s intervals")
    print(f"  Frames saved to: {frames_dir}")
    print(f"  Next phase: Implement bird species detection and counting algorithm")
    
    # List all created files
    print(f"\nFiles created:")
    for file_name in os.listdir(workspace_dir):
        full_path = os.path.join(workspace_dir, file_name)
        if os.path.isfile(full_path):
            size_mb = os.path.getsize(full_path) / (1024 * 1024)
            print(f"  - {file_name} ({size_mb:.2f} MB)")
    
    print(f"\nFrames directory contents:")
    if os.path.exists(frames_dir):
        frame_files = os.listdir(frames_dir)
        print(f"  Total frame files: {len(frame_files)}")
        for i, frame_file in enumerate(frame_files[:5]):  # Show first 5 frames
            frame_path = os.path.join(frames_dir, frame_file)
            size_kb = os.path.getsize(frame_path) / 1024
            print(f"  - {frame_file} ({size_kb:.1f} KB)")
        
        if len(frame_files) > 5:
            print(f"  ... and {len(frame_files) - 5} more frame files")
    else:
        print("  Frames directory not found")
        
except Exception as e:
    print(f"\n*** ERROR DURING VIDEO PROCESSING ***")
    print(f"Error: {str(e)}")
    import traceback
    print(f"Full error details: {traceback.format_exc()}")

print("\n*** VIDEO FRAME EXTRACTION COMPLETE ***")
print("Ready for next phase: Bird species detection and simultaneous counting analysis")
```