### Development Step 3: Calculate Pace of Eliud Kipchoge’s Marathon World Record Performance

**Description**: Search for Eliud Kipchoge's marathon world record time to determine his record-making pace. Find the official time from his world record performance and calculate his pace in terms of distance per hour or time per kilometer/mile.

**Use Cases**:
- Automated sports broadcast analytics comparing live marathon leader splits against Eliud Kipchoge’s official 2:01:09 world record pace, with real-time min/km and km/h overlays
- Fitness app feature that retrieves Kipchoge’s validated Berlin 2018 record time to set personalized pace targets and push notifications for amateur marathon trainees
- Sports marketing team tool for scraping and filtering official athletics sources, verifying world record claims before designing promotional graphics
- Exercise physiology research pipeline that programmatically extracts official marathon speeds to model human endurance thresholds in academic studies
- Running route planner that calculates expected finish times for user-defined distances based on Kipchoge’s record pace per mile and per kilometer
- Treadmill calibration script for sports equipment manufacturers using official world record pace metrics to confirm speedometer accuracy
- Athletics event organiser software generating spectator pace charts and split time boards, anchored on the verified Berlin Marathon 2018 world record
- Sports journalism fact-checker automating validation of reported marathon times against IAAF-recognized records and computing comparative pace statistics

```
import json
import os
from bs4 import BeautifulSoup
import re

print('=== CORRECTING ELIUD KIPCHOGE MARATHON WORLD RECORD IDENTIFICATION ===\n')
print('Issue: Previous analysis incorrectly identified 2:00:25 from Breaking2 event as official record')
print('Breaking2 was an unofficial time trial with pacers and special conditions')
print('Solution: Filter out unofficial times and identify the actual official world record\n')

# First, let's inspect the saved analysis to understand the structure
analysis_file = 'workspace/kipchoge_world_record_analysis.json'

if os.path.exists(analysis_file):
    print('=== STEP 1: INSPECTING PREVIOUS ANALYSIS ===\n')
    
    with open(analysis_file, 'r') as f:
        previous_analysis = json.load(f)
    
    print('Previous analysis structure:')
    for key, value in previous_analysis.items():
        if isinstance(value, dict):
            print(f'  {key}: Dictionary with keys: {list(value.keys())}')
        elif isinstance(value, list):
            print(f'  {key}: List with {len(value)} items')
        else:
            print(f'  {key}: {value}')
    
    print(f'\nPrevious (incorrect) result:')
    print(f'  Time identified: {previous_analysis.get("world_record_time", "Unknown")}')
    print(f'  Source: {previous_analysis.get("source", "Unknown")}')
else:
    print('Previous analysis file not found')

print('\n=== STEP 2: RE-ANALYZING HTML SOURCES FOR OFFICIAL RECORD ===\n')

# Re-examine the HTML files with better filtering logic
html_files = [
    'workspace/kipchoge_source_2_wikipedia_marathon_world_record.html',
    'workspace/kipchoge_source_3_runners_world_kipchoge_record.html'
]

official_record_candidates = []

for html_file in html_files:
    if not os.path.exists(html_file):
        print(f'File not found: {html_file}')
        continue
    
    source_name = 'Wikipedia' if 'wikipedia' in html_file else 'Runner\'s World'
    print(f'\n--- RE-ANALYZING {source_name.upper()} ---')
    
    with open(html_file, 'r', encoding='utf-8') as f:
        html_content = f.read()
    
    soup = BeautifulSoup(html_content, 'html.parser')
    text_content = soup.get_text()
    
    # Split into lines for context analysis
    lines = text_content.split('\n')
    
    # Look for official marathon world records, excluding Breaking2
    for line in lines:
        line_lower = line.lower().strip()
        
        # Skip Breaking2 references (unofficial)
        if 'breaking2' in line_lower or 'breaking 2' in line_lower:
            continue
        
        # Look for official world record indicators
        if ('kipchoge' in line_lower and 
            ('world record' in line_lower or 'marathon record' in line_lower) and
            ('berlin' in line_lower or 'official' in line_lower or 'iaaf' in line_lower or 'world athletics' in line_lower)):
            
            # Extract marathon time from this line
            marathon_time_pattern = r'\b2:[0-5][0-9]:[0-5][0-9]\b'
            time_matches = re.findall(marathon_time_pattern, line)
            
            if time_matches:
                for time_match in time_matches:
                    print(f'\n*** OFFICIAL RECORD CANDIDATE FOUND ***')
                    print(f'Source: {source_name}')
                    print(f'Time: {time_match}')
                    print(f'Context: {line.strip()[:300]}...')
                    
                    # Determine confidence based on context keywords
                    confidence = 'high'
                    if 'berlin' in line_lower and ('2018' in line or 'iaaf' in line_lower or 'world athletics' in line_lower):
                        confidence = 'very_high'
                    
                    official_record_candidates.append({
                        'source': source_name,
                        'time': time_match,
                        'context': line.strip(),
                        'confidence': confidence,
                        'keywords': [kw for kw in ['berlin', '2018', 'iaaf', 'world athletics', 'official'] if kw in line_lower]
                    })
    
    # Also specifically look for the Berlin 2018 record (2:01:09)
    if '2:01:09' in text_content:
        print(f'\n*** SPECIFIC SEARCH: 2:01:09 in {source_name} ***')
        
        for line in lines:
            if '2:01:09' in line and 'kipchoge' in line.lower():
                line_lower = line.lower()
                
                # Skip if it's Breaking2 related
                if 'breaking2' not in line_lower and 'breaking 2' not in line_lower:
                    print(f'Context: {line.strip()[:300]}...')
                    
                    confidence = 'high'
                    if 'berlin' in line_lower and '2018' in line:
                        confidence = 'very_high'
                    
                    official_record_candidates.append({
                        'source': source_name,
                        'time': '2:01:09',
                        'context': line.strip(),
                        'confidence': confidence,
                        'keywords': [kw for kw in ['berlin', '2018', 'iaaf', 'world athletics'] if kw in line_lower]
                    })
                    break

print(f'\n=== STEP 3: ANALYZING OFFICIAL RECORD CANDIDATES ===\n')
print(f'Found {len(official_record_candidates)} official record candidates:')

for i, candidate in enumerate(official_record_candidates, 1):
    print(f'\nCandidate {i}:')
    print(f'  Source: {candidate["source"]}')
    print(f'  Time: {candidate["time"]}')
    print(f'  Confidence: {candidate["confidence"]}')
    print(f'  Keywords: {candidate["keywords"]}')
    print(f'  Context: {candidate["context"][:200]}...')

# Determine the official world record
if official_record_candidates:
    # Count frequency and prioritize by confidence
    from collections import Counter, defaultdict
    
    time_counts = Counter([c['time'] for c in official_record_candidates])
    confidence_scores = defaultdict(list)
    
    for candidate in official_record_candidates:
        confidence_scores[candidate['time']].append(candidate['confidence'])
    
    print(f'\n=== OFFICIAL RECORD ANALYSIS ===\n')
    print('Time frequency and confidence analysis:')
    
    for time, count in time_counts.most_common():
        confidences = confidence_scores[time]
        max_confidence = max(confidences)
        print(f'  {time}: appears {count} times, max confidence: {max_confidence}')
    
    # Select the most credible official record
    # Priority: very_high confidence, then frequency, then high confidence
    very_high_candidates = [c for c in official_record_candidates if c['confidence'] == 'very_high']
    
    if very_high_candidates:
        # Use most frequent among very_high confidence
        very_high_times = [c['time'] for c in very_high_candidates]
        most_frequent_very_high = Counter(very_high_times).most_common(1)[0][0]
        official_record = next(c for c in very_high_candidates if c['time'] == most_frequent_very_high)
        selection_basis = 'Very high confidence + frequency'
    else:
        # Use most frequent overall
        most_common_time = time_counts.most_common(1)[0][0]
        official_record = next(c for c in official_record_candidates if c['time'] == most_common_time)
        selection_basis = 'Most frequent official mention'
    
    print(f'\n*** CORRECTED OFFICIAL WORLD RECORD IDENTIFIED ***')
    print(f'Time: {official_record["time"]}')
    print(f'Source: {official_record["source"]}')
    print(f'Confidence: {official_record["confidence"]}')
    print(f'Selection basis: {selection_basis}')
    print(f'Keywords: {official_record["keywords"]}')
    
else:
    print('\n*** NO OFFICIAL RECORD CANDIDATES FOUND ***')
    print('Using widely recognized official record: 2:01:09 (Berlin Marathon 2018)')
    official_record = {
        'time': '2:01:09',
        'source': 'Berlin Marathon 2018 (widely recognized)',
        'confidence': 'high',
        'context': 'Berlin Marathon 2018 official world record'
    }
    selection_basis = 'Widely recognized official record'

print('\n=== STEP 4: CALCULATING CORRECTED PACE METRICS ===\n')

# Parse the corrected official record time
record_time_str = official_record['time']
print(f'Calculating pace for OFFICIAL world record time: {record_time_str}')

# Parse time components
time_parts = record_time_str.split(':')
hours = int(time_parts[0])
minutes = int(time_parts[1])
seconds = int(time_parts[2])

# Convert to total seconds
total_seconds = hours * 3600 + minutes * 60 + seconds
print(f'Total time in seconds: {total_seconds:,} seconds')

# Marathon distance
marathon_km = 42.195  # Official marathon distance in kilometers
marathon_miles = 26.21875  # Official marathon distance in miles

print(f'Marathon distance: {marathon_km} km ({marathon_miles} miles)')

# Calculate pace metrics
print('\n=== CORRECTED PACE CALCULATIONS ===\n')

# 1. Minutes per kilometer
minutes_per_km = total_seconds / 60 / marathon_km
min_per_km_minutes = int(minutes_per_km)
min_per_km_seconds = (minutes_per_km - min_per_km_minutes) * 60

print(f'1. Pace per kilometer: {min_per_km_minutes}:{min_per_km_seconds:04.1f} min/km')

# 2. Minutes per mile
minutes_per_mile = total_seconds / 60 / marathon_miles
min_per_mile_minutes = int(minutes_per_mile)
min_per_mile_seconds = (minutes_per_mile - min_per_mile_minutes) * 60

print(f'2. Pace per mile: {min_per_mile_minutes}:{min_per_mile_seconds:04.1f} min/mile')

# 3. Speed in km/h
speed_kmh = marathon_km / (total_seconds / 3600)
print(f'3. Speed: {speed_kmh:.2f} km/h')

# 4. Speed in mph
speed_mph = marathon_miles / (total_seconds / 3600)
print(f'4. Speed: {speed_mph:.2f} mph')

# Save corrected results
corrected_results = {
    'athlete': 'Eliud Kipchoge',
    'official_world_record_time': record_time_str,
    'source': official_record.get('source', 'Unknown'),
    'selection_basis': selection_basis,
    'confidence': official_record.get('confidence', 'Unknown'),
    'marathon_distance_km': marathon_km,
    'marathon_distance_miles': marathon_miles,
    'total_seconds': total_seconds,
    'pace_metrics': {
        'minutes_per_km': f'{min_per_km_minutes}:{min_per_km_seconds:04.1f}',
        'minutes_per_mile': f'{min_per_mile_minutes}:{min_per_mile_seconds:04.1f}',
        'speed_kmh': round(speed_kmh, 2),
        'speed_mph': round(speed_mph, 2)
    },
    'detailed_calculations': {
        'time_breakdown': {'hours': hours, 'minutes': minutes, 'seconds': seconds},
        'pace_per_km_decimal': round(minutes_per_km, 3),
        'pace_per_mile_decimal': round(minutes_per_mile, 3)
    },
    'correction_notes': {
        'previous_incorrect_time': '2:00:25',
        'previous_issue': 'Breaking2 unofficial time trial with pacers',
        'correction_applied': 'Filtered out unofficial times, prioritized official marathon records',
        'official_candidates_analyzed': len(official_record_candidates)
    }
}

with open('workspace/kipchoge_corrected_world_record_analysis.json', 'w') as f:
    json.dump(corrected_results, f, indent=2)

print(f'\n=== CORRECTED FINAL RESULTS SUMMARY ===\n')
print(f'Athlete: {corrected_results["athlete"]}')
print(f'OFFICIAL World Record Time: {corrected_results["official_world_record_time"]}')
print(f'Source: {corrected_results["source"]}')
print(f'Selection Basis: {corrected_results["selection_basis"]}')
print(f'\nCorrected Pace Metrics:')
print(f'  - Per kilometer: {corrected_results["pace_metrics"]["minutes_per_km"]} min/km')
print(f'  - Per mile: {corrected_results["pace_metrics"]["minutes_per_mile"]} min/mile')
print(f'  - Speed: {corrected_results["pace_metrics"]["speed_kmh"]} km/h')
print(f'  - Speed: {corrected_results["pace_metrics"]["speed_mph"]} mph')

print(f'\nCorrection Notes:')
print(f'  - Previous incorrect time: {corrected_results["correction_notes"]["previous_incorrect_time"]} (Breaking2 unofficial)')
print(f'  - Corrected to official record: {corrected_results["official_world_record_time"]} (Berlin 2018)')

print(f'\nComplete corrected analysis saved to: workspace/kipchoge_corrected_world_record_analysis.json')
print('\n=== CORRECTED ANALYSIS COMPLETE ===\n')
print('PLAN OBJECTIVE FULFILLED: Found official marathon world record time and calculated pace metrics')
```