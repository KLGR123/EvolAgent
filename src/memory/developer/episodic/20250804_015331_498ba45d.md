### Development Step 10: Construct Two-Cell Move Graph and BFS Path to Extract 11th-Move Cell’s Hex Color

**Description**: Construct adjacency graph of legal two-cell moves using workspace/grid_data.json and workspace/start_end_coordinates.json and perform a breadth-first search from the START cell to locate the shortest path to the END cell enforcing no immediate backtracking; identify the coordinate of the cell landed on after the 11th move along the resulting path; extract that cell’s 6-digit hex fill color from workspace/grid_data.json.

**Use Cases**:
- Automated warehouse navigation and zone verification: plan two-cell moves through a storage grid, extract the 11th cell’s fill color to confirm high-priority pick-up area.
- Precision agriculture drone flight planning: compute two-step waypoints over a crop field grid, identify the 11th waypoint’s spectral fill color to schedule targeted spraying.
- Facility cleaning robot route scheduling: generate non-backtracking cleaning paths on a floor-plan grid, check the 11th segment’s surface-type color to select the proper cleaning mode.
- PCB assembly inspection robot navigation: map legal two-cell moves across a circuit board grid, retrieve the 11th checkpoint’s solder-mask color code for defect classification.
- Video game NPC patrol route generation: calculate diagonal and cardinal jumps on a tile-based map, detect the 11th tile’s texture fill color to trigger an in-game event.
- Forest fire monitoring UAV corridor design: build safe flight paths over a terrain grid, read the 11th cell’s risk-level fill color to adjust surveillance altitude.
- Building security patrol optimization: plan guard walking routes on a floor-plan grid, extract the 11th waypoint’s zone color to verify sensor health status.
- Urban traffic simulation for smart city planning: plot pedestrian crossing patterns on city-block grids, identify the 11th intersection’s pavement color tag to fine-tune adaptive signal timing.

```
import os
import json
from collections import deque

# 1) Define workspace file paths
workspace = 'workspace'
grid_path = os.path.join(workspace, 'grid_data.json')
coords_path = os.path.join(workspace, 'start_end_coordinates.json')

# 2) Load and inspect `grid_data.json`
print(f"Loading grid_data.json from {grid_path}")
with open(grid_path, 'r', encoding='utf-8') as f:
    grid = json.load(f)
print(f"Total cells loaded: {len(grid)}")
if grid:
    sample_keys = list(grid[0].keys())
    print(f"Sample cell keys: {sample_keys}\n")

# 3) Load and inspect `start_end_coordinates.json`
print(f"Loading start/end coordinates from {coords_path}")
with open(coords_path, 'r', encoding='utf-8') as f:
    se = json.load(f)
start = (se['START']['row'], se['START']['col'])
end   = (se['END']['row'],   se['END']['col'])
print(f"START at {start}, END at {end}\n")

# 4) Build a map of all cells and define passable = all non-blue (fill_color != '0099FF')
BLUE = '0099FF'
cell_map = {}
passable = set()
for cell in grid:
    coord = (cell['row'], cell['col'])
    cell_map[coord] = cell
    if cell.get('fill_color', '') != BLUE:
        passable.add(coord)
print(f"Passable cells (non-blue): {len(passable)} / {len(grid)} total\n")

# 5) Helper to build adjacency for a given move set & mid-check rule
def build_adj(passable_set, moves, mid_check):
    """
    passable_set: set of coords
    moves: list of (dr,dc)
    mid_check: if True, require midpoint also passable
    returns: dict coord -> list of neighbor coords
    """
    adj = {c: [] for c in passable_set}
    for (r, c) in passable_set:
        nbrs = []
        for dr, dc in moves:
            dest = (r + dr, c + dc)
            # dest must be passable
            if dest not in passable_set:
                continue
            # if mid_check, midpoint must also be passable
            if mid_check:
                mid = (r + dr // 2, c + dc // 2)
                if mid not in passable_set:
                    continue
            nbrs.append(dest)
        adj[(r, c)] = nbrs
    return adj

# 6) Define four scenarios to test connectivity
cardinal       = [( 2, 0), (-2, 0), (0,  2), (0, -2)]
diagonal       = [( 2, 2), ( 2, -2), (-2, 2), (-2, -2)]
scenarios = [
    ('A: 2-step cardinal, mid-check',                  cardinal,             True ),
    ('B: 2-step cardinal+diagonal, mid-check',         cardinal + diagonal,  True ),
    ('C: 2-step cardinal, NO mid-check',               cardinal,             False),
    ('D: 2-step cardinal+diagonal, NO mid-check',      cardinal + diagonal,  False),
]

chosen_adj = None
chosen_name = None
for name, moves, midc in scenarios:
    print(f"Testing scenario: {name}")
    adj = build_adj(passable, moves, midc)
    # Print neighbors of start and end for quick sanity
    print(f"  START neighbors: {adj.get(start, [])}")
    print(f"  END   neighbors: {adj.get(end,   [])}")
    # BFS for reachability
    vis = {start}
    dq = deque([start])
    while dq:
        cur = dq.popleft()
        for nb in adj[cur]:
            if nb not in vis:
                vis.add(nb)
                dq.append(nb)
    can_reach = end in vis
    print(f"  Reachable cells count: {len(vis)}, END reachable: {can_reach}\n")
    if can_reach:
        chosen_adj  = adj
        chosen_name = name
        break

# If none connect, abort
if chosen_adj is None:
    print("ERROR: No adjacency scenario yields connectivity from START to END. Cannot proceed.")
    exit(1)
print(f"\nUsing scenario '{chosen_name}' for full pathfinding.\n")

# 7) BFS to find shortest path WITHOUT immediate backtracking
dprint = print  # alias for clarity
queue = deque([(start, None, [start])])
seen  = {(start, None)}
path_to_end = None
while queue:
    cur, prev, path = queue.popleft()
    if cur == end:
        path_to_end = path
        break
    for nb in chosen_adj[cur]:
        # forbid going immediately back to the previous cell
        if nb == prev:
            continue
        state = (nb, cur)
        if state not in seen:
            seen.add(state)
            queue.append((nb, cur, path + [nb]))

if path_to_end is None:
    print("ERROR: No path found under no-backtracking BFS. This should not happen if basic BFS was successful.")
    exit(1)

moves_count = len(path_to_end) - 1
print(f"Found shortest path with {moves_count} moves.")
print(f"Full path: {path_to_end}\n")

# 8) Extract the 11th move coordinate
if moves_count < 11:
    print(f"ERROR: Path has only {moves_count} moves; cannot extract the 11th move.")
    exit(1)
coord11 = path_to_end[11]
cell11  = cell_map[coord11]
hex11   = cell11.get('fill_color', '')
print(f"Coordinate after 11th move: {coord11}")
print(f"Fill color at that cell: {hex11}\n")

# 9) Save final result
result = {
    'scenario': chosen_name,
    '11th_move_coordinate': {'row': coord11[0], 'col': coord11[1]},
    'fill_color': hex11,
    'total_moves': moves_count
}
out_file = os.path.join(workspace, 'eleventh_move_result.json')
with open(out_file, 'w', encoding='utf-8') as f:
    json.dump(result, f, indent=2)
print(f"Result saved to {out_file}")
```