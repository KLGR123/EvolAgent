### Development Step 8: Graph Two-Cell Moves, BFS to Determine 11th-Move Cell and Extract Its Hex Color

**Description**: Construct adjacency graph of legal two-cell moves using workspace/grid_data.json and workspace/start_end_coordinates.json and perform a breadth-first search from the START cell to locate the shortest path to the END cell enforcing no immediate backtracking; identify the coordinate of the cell landed on after the 11th move along the resulting path; extract that cell’s 6-digit hex fill color from workspace/grid_data.json.

**Use Cases**:
- Autonomous warehouse robot navigation and obstacle avoidance, extracting the zone color at the 11th waypoint for inventory restocking checks
- Urban delivery drone route planning with no-fly zones marked in blue, identifying the neighborhood color code at the 11th grid coordinate
- Video game NPC pathfinding on a tiled map, predicting the 11th move’s terrain type (via its color) for dynamic AI behavior adjustments
- Building evacuation simulation in emergency management, avoiding blocked corridors, and placing signage at the 11th step’s floor zone color
- Sensor network data routing through a grid of active/inactive nodes, retrieving the 11th sensor’s status color for health-monitoring dashboards
- VLSI chip layout routing around forbidden regions, determining the material layer’s hex color at the 11th segment of the wiring path
- Civil infrastructure pipeline design across a parcel grid, avoiding restricted plots and sampling the land-use color at the 11th pipe joint
- Wildlife corridor modeling on habitat grids, finding the shortest animal path around barriers and noting the vegetation-type color at step 11

```
import os
import json
from collections import deque

# Paths
workspace = 'workspace'
grid_file = os.path.join(workspace, 'grid_data.json')
coords_file = os.path.join(workspace, 'start_end_coordinates.json')

# 1) Load grid data
print(f"Loading grid data from: {grid_file}")
with open(grid_file, 'r', encoding='utf-8') as f:
    grid = json.load(f)
print(f"Total cells in grid_data.json: {len(grid)}")

# Inspect fill_color distribution
from collections import Counter
colors = Counter(cell.get('fill_color','') for cell in grid)
print("\nFill_color counts:")
for col, cnt in colors.items(): print(f"  '{col}': {cnt}")

# 2) Load START/END coords
deprint = lambda *args, **kwargs: print(*args, **kwargs)
print(f"\nLoading start/end coordinates from: {coords_file}")
with open(coords_file, 'r', encoding='utf-8') as f:
    se = json.load(f)
start = (se['START']['row'], se['START']['col'])
end   = (se['END']['row'],   se['END']['col'])
print(f"START: {start}, END: {end}\n")

# 3) Build cell_map and passable set (all non-blue)
BLUE = '0099FF'
cell_map = {}
passable = set()
for cell in grid:
    coord = (cell['row'], cell['col'])
    cell_map[coord] = cell
    if cell.get('fill_color','') != BLUE:
        passable.add(coord)
print(f"Passable cells (non-blue): {len(passable)} of {len(grid)} total\n")

# 4) Define four adjacency scenarios
def build_adj(moves, check_mid):
    adj = {c: [] for c in passable}
    for (r,c) in passable:
        nbrs = []
        for dr,dc in moves:
            dest = (r+dr, c+dc)
            if dest not in passable: continue
            if check_mid:
                mid = (r + dr//2, c + dc//2)
                if mid not in passable: continue
            nbrs.append(dest)
        adj[(r,c)] = nbrs
    return adj

# Move definitions
cardinal = [(2,0),(-2,0),(0,2),(0,-2)]
diagonal = [(2,2),(2,-2),(-2,2),(-2,-2)]
scenarios = [
    ('A: cardinal, mid-check', cardinal, True),
    ('B: cardinal+diagonal, mid-check', cardinal+diagonal, True),
    ('C: cardinal, no-mid', cardinal, False),
    ('D: cardinal+diagonal, no-mid', cardinal+diagonal, False)
]

chosen = None
for name, moves, midc in scenarios:
    print(f"Testing scenario {name}")
    adj = build_adj(moves, midc)
    # BFS simple reachability
    vis = set([start])
    dq = deque([start])
    while dq:
        cur = dq.popleft()
        for n in adj[cur]:
            if n not in vis:
                vis.add(n)
                dq.append(n)
    reachable = len(vis)
    ok = (end in vis)
    print(f"  Reachable cells: {reachable}, END in reachable: {ok}\n")
    if ok:
        chosen = (name, moves, midc, adj)
        break

if not chosen:
    print("ERROR: No scenario provided connectivity. Cannot proceed.")
    exit(1)

name, moves, midc, adj = chosen
print(f"Using scenario '{name}' for pathfinding.\n")
print(f"Moves: {moves}\nMid-check: {midc}\n")

# 5) BFS shortest path forbidding immediate backtracking
print("Running BFS (no immediate backtracking) to find shortest path...")
queue = deque([(start, None, [start])])
seen = set([(start, None)])
path_to_end = None
while queue:
    cur, prev, path = queue.popleft()
    if cur == end:
        path_to_end = path
        break
    for n in adj[cur]:
        if n == prev:
            continue
        state = (n, cur)
        if state not in seen:
            seen.add(state)
            queue.append((n, cur, path + [n]))

if not path_to_end:
    print("ERROR: No path found under no-backtracking BFS.")
    exit(1)

moves_count = len(path_to_end) - 1
print(f"Shortest path found with {moves_count} moves.")
print(f"Full path coords: {path_to_end}\n")

# 6) Extract 11th move
if moves_count < 11:
    print(f"ERROR: Path only has {moves_count} moves; cannot extract the 11th move.")
    exit(1)
coord11 = path_to_end[11]
cell11 = cell_map[coord11]
hex_color = cell11.get('fill_color','')
print(f"Coordinate after 11th move: {coord11}")
print(f"Fill color at that cell: {hex_color}\n")

# 7) Save result
result = {
    'scenario': name,
    '11th_move_coordinate': {'row': coord11[0], 'col': coord11[1]},
    'fill_color': hex_color,
    'path_moves': moves_count
}
out_path = os.path.join(workspace, 'eleventh_move_result.json')
with open(out_path, 'w', encoding='utf-8') as f:
    json.dump(result, f, indent=2)
print(f"Results saved to: {out_path}")
```