### Development Step 4: Extract 11th Move Cell Hex Color via BFS on Two-Cell Move Adjacency Graph

**Description**: Construct adjacency graph of legal two-cell moves using workspace/grid_data.json and workspace/start_end_coordinates.json and perform a breadth-first search from the START cell to locate the shortest path to the END cell enforcing no immediate backtracking; identify the coordinate of the cell landed on after the 11th move along the resulting path; extract that cellâ€™s 6-digit hex fill color from workspace/grid_data.json.

**Use Cases**:
- Autonomous warehouse navigation and pallet pickup route optimization for robotic forklifts
- Precision agriculture path planning and segment-specific soil analysis for automated tractors
- Urban package delivery drone routing and mid-route risk assessment for last-mile logistics
- Hospital floor evacuation mapping and staging area identification for emergency response teams
- Interactive museum exhibit routing and multimedia trigger sequencing for guided tours
- Board game AI move sequence analysis and power-up activation for strategic game design
- Video game level path verification and environmental tile consistency checking for QA testing

```
import os
import json
from collections import deque

# Paths to the input JSON files
workspace_dir = 'workspace'
grid_path = os.path.join(workspace_dir, 'grid_data.json')
coords_path = os.path.join(workspace_dir, 'start_end_coordinates.json')

print(f"Loading grid data from: {grid_path}")
with open(grid_path, 'r', encoding='utf-8') as f:
    grid_data = json.load(f)
print(f"Loaded {len(grid_data)} cells from grid_data.json")

print(f"Loading start/end coordinates from: {coords_path}")
with open(coords_path, 'r', encoding='utf-8') as f:
    se = json.load(f)
start = (se['START']['row'], se['START']['col'])
end = (se['END']['row'], se['END']['col'])
print(f"Start coordinate: {start}")
print(f"End coordinate:   {end}\n")

# Build a map from (row,col) to cell properties
df_map = {}         # full cell dict by coordinate
passable_cells = set()
unique_colors = set()
unique_values = set()
for cell in grid_data:
    coord = (cell['row'], cell['col'])
    df_map[coord] = cell
    unique_colors.add(cell['fill_color'])
    unique_values.add(cell['value'])
    # Consider every cell that is not blue (0099FF) as passable, including START/END (empty color)
    if cell['fill_color'] != '0099FF':
        passable_cells.add(coord)

print(f"Unique fill_color values in grid: {sorted(unique_colors)}")
print(f"Unique value fields in grid:    {sorted(unique_values)}")
print(f"Passable cell count: {len(passable_cells)} / {len(grid_data)}\n")

# Build adjacency graph for "two-cell" moves (cardinal directions, distance = 2)
adj = {coord: [] for coord in passable_cells}
moves = [(2, 0), (-2, 0), (0, 2), (0, -2)]
print("Constructing adjacency list for two-cell moves...")
for r, c in passable_cells:
    for dr, dc in moves:
        nr, nc = r + dr, c + dc
        ncoord = (nr, nc)
        # Check destination exists and is passable
        if ncoord in passable_cells:
            adj[(r, c)].append(ncoord)
    print(f"Cell {(r,c)} has neighbors: {adj[(r,c)]}")
print("Adjacency construction complete.\n")

# BFS to find shortest path from start to end, disallowing immediate backtracking
print("Beginning breadth-first search (no immediate backtracking)...")
# State is (current_coord, previous_coord)
start_state = (start, None)
queue = deque([(start, None, [start])])
visited = set([start_state])
found_path = None

while queue:
    cur, prev, path = queue.popleft()
    if cur == end:
        found_path = path
        print("Reached END!")
        break
    for neigh in adj[cur]:
        # Prevent immediate backtracking to 'prev'
        if neigh == prev:
            continue
        nxt_state = (neigh, cur)
        if nxt_state not in visited:
            visited.add(nxt_state)
            queue.append((neigh, cur, path + [neigh]))

# Check we found a path
if not found_path:
    print("ERROR: No path found from START to END under the two-cell-move rule.")
    exit(1)

print(f"Shortest path length (in moves): {len(found_path)-1}")
print("Full path coords:")
print(found_path)

# Identify the coordinate after the 11th move
# Path list: index 0 = start, index 1 = after 1st move, ..., index 11 = after 11th move
if len(found_path) <= 11:
    print(f"ERROR: Path only has {len(found_path)-1} moves; cannot extract 11th move.")
    exit(1)

coord11 = found_path[11]
cell11 = df_map.get(coord11)
hex_color = cell11['fill_color']
print(f"\nCoordinate after 11th move: {coord11}")
print(f"Fill color at that cell: {hex_color}\n")

# Save result to workspace
overlay = {
    '11th_move_coordinate': {'row': coord11[0], 'col': coord11[1]},
    'fill_color': hex_color,
    'path_length_moves': len(found_path)-1
}
out_path = os.path.join(workspace_dir, 'eleventh_move_result.json')
with open(out_path, 'w', encoding='utf-8') as f:
    json.dump(overlay, f, indent=2)
print(f"Results written to {out_path}")

```