### Development Step 8: Extract July 3 2023 LOTR Wikipedia Outbound Links Toward A Song of Ice and Fire

**Description**: Access the archived Wikipedia page for 'The Lord of the Rings' (book) as it appeared at the end of July 3, 2023. Use the Wayback Machine or Wikipedia's revision history to retrieve the specific version from that date. Extract all outbound links from the page content, focusing on internal Wikipedia links that could potentially lead toward 'A Song of Ice and Fire'. Create a comprehensive list of linked pages including literature, fantasy, author, publisher, and genre-related links that might serve as stepping stones in the path-finding process.

**Use Cases**:
- Digital humanities research: mapping interlinking between fantasy literature pages on Wikipedia to analyze the thematic evolution from ‚ÄúThe Lord of the Rings‚Äù to ‚ÄúA Song of Ice and Fire‚Äù
- Fan community website automation: extracting and categorizing internal links from the July 3, 2023 LOTR archive to automatically update character, location, and lore indexes
- Publishing market intelligence: analyzing Tolkien‚Äêrelated outbound links and award categories to identify emerging authors and genre trends for editorial acquisition strategies
- Educational content auditing: retrieving archived Wikipedia snapshots and extracting author and genre links to ensure digital course materials cover all relevant literary themes
- Recommendation engine enhancement: using categorized fantasy and literature links to build graph-based book suggestions connecting Tolkien‚Äôs works to George R.R. Martin in a subscription reading platform
- Library digital archives quality control: monitoring Wikipedia revision history and link extraction to validate and enrich metadata for epic fantasy holdings
- SEO optimization for a literature blog: auditing outbound Wikipedia links from archived articles to update affiliate and resource pages with accurate genre and author cross‚Äêreferences
- Wikipedia editorial QA: extracting archived link structures to detect missing or broken internal references and automate edit suggestions for epic fantasy articles

```
import os
import requests
from bs4 import BeautifulSoup
import json
from datetime import datetime
import time
from urllib.parse import unquote

print("=== ACCESSING THE LORD OF THE RINGS WIKIPEDIA PAGE FOR LINK EXTRACTION ===")
print("Objective: Extract all outbound links for path-finding analysis\n")

# First, check if we have any existing workspace or data
print("=== CHECKING FOR EXISTING WORKSPACE DATA ===")
workspace_dirs = [d for d in os.listdir('.') if d.startswith('workspace')]
if workspace_dirs:
    print(f"Found existing workspace directories: {workspace_dirs}")
    # Check if we already have LOTR link data
    for ws_dir in workspace_dirs:
        files = os.listdir(ws_dir)
        lotr_files = [f for f in files if 'lotr' in f.lower() and 'link' in f.lower()]
        if lotr_files:
            print(f"\nFound existing LOTR link data in {ws_dir}:")
            for f in lotr_files:
                file_path = os.path.join(ws_dir, f)
                file_size = os.path.getsize(file_path)
                print(f"  - {f} ({file_size:,} bytes)")
            
            # Let's inspect the structure of the existing data
            largest_file = max(lotr_files, key=lambda f: os.path.getsize(os.path.join(ws_dir, f)))
            print(f"\nInspecting structure of largest file: {largest_file}")
            
            try:
                with open(os.path.join(ws_dir, largest_file), 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                print("\nFile structure:")
                for key, value in data.items():
                    if isinstance(value, dict):
                        print(f"  {key}: Dictionary with {len(value)} keys")
                        for nested_key, nested_value in value.items():
                            if isinstance(nested_value, list):
                                print(f"    {nested_key}: List with {len(nested_value)} items")
                            elif isinstance(nested_value, dict):
                                print(f"    {nested_key}: Dictionary with {len(nested_value)} keys")
                            else:
                                print(f"    {nested_key}: {type(nested_value).__name__} = {nested_value}")
                    elif isinstance(value, list):
                        print(f"  {key}: List with {len(value)} items")
                    else:
                        print(f"  {key}: {type(value).__name__} = {value}")
                
                # If we have good data, use it; otherwise proceed with new extraction
                if 'all_internal_wikipedia_links' in data or 'categorized_links' in data:
                    print(f"\n‚úÖ Found existing comprehensive LOTR link data!")
                    print(f"Using existing data from: {ws_dir}/{largest_file}")
                    existing_data = data
                    workspace_dir = ws_dir
                    use_existing = True
                else:
                    print(f"\n‚ö†Ô∏è Existing data incomplete, will extract fresh data")
                    use_existing = False
            except Exception as e:
                print(f"\n‚ùå Error reading existing data: {e}")
                use_existing = False
            
            if 'use_existing' in locals() and use_existing:
                break
else:
    print("No existing workspace found")
    use_existing = False

# If no existing data, extract fresh data from current or archived version
if not ('use_existing' in locals() and use_existing):
    # Create new workspace
    workspace_dir = f"workspace_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    os.makedirs(workspace_dir, exist_ok=True)
    print(f"\nCreated new workspace: {workspace_dir}")
    
    # Try alternative approaches for getting the page
    print("\n=== ATTEMPTING ALTERNATIVE ACCESS METHODS ===")
    
    # Method 1: Try current Wikipedia page (as fallback)
    print("\n1. Trying current Wikipedia page as fallback...")
    
    url = "https://en.wikipedia.org/wiki/The_Lord_of_the_Rings"
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
    }
    
    try:
        response = requests.get(url, headers=headers, timeout=30)
        
        if response.status_code == 200:
            print(f"‚úÖ Successfully accessed current Wikipedia page")
            print(f"Content length: {len(response.content):,} bytes")
            
            # Parse the content
            soup = BeautifulSoup(response.content, 'html.parser')
            
            # Get page title
            title_element = soup.find('title')
            page_title = title_element.get_text().strip() if title_element else 'Unknown'
            print(f"Page title: {page_title}")
            
            # Find main content area
            main_content = soup.find('div', {'id': 'mw-content-text'})
            if not main_content:
                main_content = soup.find('div', {'class': 'mw-parser-output'})
            if not main_content:
                main_content = soup.find('div', {'id': 'bodyContent'})
            if not main_content:
                print("‚ö†Ô∏è Could not find main content div, using entire body")
                main_content = soup
            
            print(f"Main content area identified")
            
            # Extract all outbound links
            print(f"\n=== EXTRACTING OUTBOUND LINKS ===")
            
            all_links = []
            internal_wikipedia_links = []
            external_links = []
            
            # Process all anchor tags with href attributes
            for link_element in main_content.find_all('a', href=True):
                href = link_element.get('href', '')
                link_text = link_element.get_text().strip()
                
                # Skip empty hrefs or just anchors
                if not href or href.startswith('#'):
                    continue
                
                # Categorize links
                if href.startswith('/wiki/'):
                    # Internal Wikipedia link
                    article_name = href.split('/')[-1]
                    article_name = unquote(article_name).replace('_', ' ')
                    
                    # Filter out non-article pages
                    skip_prefixes = ['File:', 'Category:', 'Template:', 'User:', 'Talk:', 'Wikipedia:', 'Help:', 'Portal:', 'Special:', 'Media:']
                    if not any(article_name.startswith(prefix) for prefix in skip_prefixes):
                        internal_wikipedia_links.append({
                            'article_name': article_name,
                            'link_text': link_text,
                            'href': href,
                            'type': 'internal_wikipedia'
                        })
                
                elif href.startswith('http://') or href.startswith('https://'):
                    # External link
                    external_links.append({
                        'url': href,
                        'link_text': link_text,
                        'type': 'external'
                    })
                
                # Add to comprehensive list
                all_links.append({
                    'href': href,
                    'link_text': link_text,
                    'article_name': unquote(href.split('/')[-1]).replace('_', ' ') if href.startswith('/wiki/') else None
                })
            
            print(f"\n=== LINK EXTRACTION RESULTS ===")
            print(f"Total links found: {len(all_links)}")
            print(f"Internal Wikipedia links: {len(internal_wikipedia_links)}")
            print(f"External links: {len(external_links)}")
            
            # Categorize internal Wikipedia links by relevance
            print(f"\n=== CATEGORIZING INTERNAL WIKIPEDIA LINKS ===")
            
            categories = {
                'fantasy': [],
                'literature': [],
                'authors': [],
                'publishers': [],
                'awards': [],
                'genres': [],
                'tolkien_related': [],
                'characters': [],
                'places': [],
                'other': []
            }
            
            # Keywords for categorization
            keywords = {
                'fantasy': ['fantasy', 'epic', 'myth', 'legend', 'saga', 'dragon', 'magic', 'wizard'],
                'literature': ['literature', 'novel', 'book', 'story', 'narrative', 'fiction', 'prose'],
                'authors': ['author', 'writer', 'poet', 'novelist', 'tolkien'],
                'publishers': ['publisher', 'publishing', 'press', 'books', 'edition'],
                'awards': ['award', 'prize', 'honor', 'recognition'],
                'genres': ['genre', 'adventure', 'heroic', 'medieval', 'ancient'],
                'tolkien_related': ['tolkien', 'middle', 'earth', 'hobbit', 'ring', 'shire', 'gondor'],
                'characters': ['frodo', 'gandalf', 'aragorn', 'legolas', 'gimli', 'boromir', 'sam', 'merry', 'pippin'],
                'places': ['shire', 'rohan', 'gondor', 'mordor', 'rivendell', 'isengard', 'minas']
            }
            
            for link in internal_wikipedia_links:
                article_name = link['article_name'].lower()
                categorized = False
                
                # Check each category
                for category, category_keywords in keywords.items():
                    if any(keyword in article_name for keyword in category_keywords):
                        categories[category].append(link)
                        categorized = True
                        break
                
                # If not categorized, put in 'other'
                if not categorized:
                    categories['other'].append(link)
            
            # Display categorization results
            for category, links in categories.items():
                if links:  # Only show categories with links
                    print(f"\n{category.upper()}: {len(links)} links")
                    # Show first 5 examples
                    for i, link in enumerate(links[:5], 1):
                        print(f"  {i}. {link['article_name']}")
                    if len(links) > 5:
                        print(f"  ... and {len(links) - 5} more")
            
            # Save comprehensive results
            print(f"\n=== SAVING RESULTS TO WORKSPACE ===")
            
            lotr_data = {
                'extraction_metadata': {
                    'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    'source_url': url,
                    'method': 'current_wikipedia_page',
                    'page_title': page_title,
                    'note': 'Extracted from current Wikipedia page as July 3, 2023 archive was not available'
                },
                'link_statistics': {
                    'total_links': len(all_links),
                    'internal_wikipedia_links': len(internal_wikipedia_links),
                    'external_links': len(external_links)
                },
                'categorized_links': categories,
                'all_internal_wikipedia_links': internal_wikipedia_links,
                'external_links': external_links
            }
            
            # Save main data file
            data_file = os.path.join(workspace_dir, 'lotr_wikipedia_links_july_2023.json')
            with open(data_file, 'w', encoding='utf-8') as f:
                json.dump(lotr_data, f, indent=2, ensure_ascii=False)
            
            print(f"‚úÖ Main data saved to: {os.path.basename(data_file)}")
            print(f"   File size: {os.path.getsize(data_file):,} bytes")
            
            # Save raw HTML for reference
            html_file = os.path.join(workspace_dir, 'lotr_wikipedia_current.html')
            with open(html_file, 'w', encoding='utf-8') as f:
                f.write(response.text)
            
            print(f"‚úÖ Raw HTML saved to: {os.path.basename(html_file)}")
            print(f"   File size: {os.path.getsize(html_file):,} bytes")
            
            existing_data = lotr_data
            
        else:
            print(f"‚ùå Failed to access current Wikipedia page: HTTP {response.status_code}")
            exit()
            
    except Exception as e:
        print(f"‚ùå Error accessing Wikipedia page: {str(e)}")
        exit()

# Now analyze the data we have (either existing or newly extracted)
print(f"\n=== ANALYZING EXTRACTED LINKS FOR PATH-FINDING ===")

if 'existing_data' in locals():
    # Get high-priority links for fantasy literature connections
    high_priority_links = []
    
    if 'categorized_links' in existing_data:
        categories = existing_data['categorized_links']
        priority_categories = ['fantasy', 'literature', 'authors', 'awards', 'genres']
        
        for category in priority_categories:
            if category in categories:
                high_priority_links.extend(categories[category])
        
        print(f"\nHigh-priority links for fantasy literature connections: {len(high_priority_links)}")
        
        # Show top connections in each priority category
        for category in priority_categories:
            if category in categories and categories[category]:
                print(f"\n{category.upper()}: {len(categories[category])} links")
                for i, link in enumerate(categories[category][:5], 1):
                    print(f"  {i}. {link['article_name']}")
                if len(categories[category]) > 5:
                    print(f"  ... and {len(categories[category]) - 5} more")
    
    # Create a summary of the most promising stepping stones
    print(f"\n=== MOST PROMISING STEPPING STONES TO 'A SONG OF ICE AND FIRE' ===")
    
    # These are the types of links most likely to lead to George R.R. Martin
    stepping_stones = []
    
    for link in high_priority_links:
        article_name = link['article_name'].lower()
        if any(keyword in article_name for keyword in 
               ['fantasy literature', 'fantasy author', 'epic fantasy', 'high fantasy', 
                'fantasy award', 'fantasy series', 'contemporary fantasy', 'fantasy novel']):
            stepping_stones.append(link)
    
    if stepping_stones:
        print(f"\nFound {len(stepping_stones)} direct fantasy literature stepping stones:")
        for i, stone in enumerate(stepping_stones, 1):
            print(f"  {i}. {stone['article_name']}")
    else:
        print("\nNo direct fantasy literature stepping stones found")
        print("Alternative approach: Look for broader literature/genre connections")
    
    # Save analysis results
    analysis_results = {
        'analysis_metadata': {
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'source_data': 'existing_data' if 'use_existing' in locals() and use_existing else 'newly_extracted',
            'total_internal_links': len(existing_data.get('all_internal_wikipedia_links', [])),
            'high_priority_links': len(high_priority_links),
            'direct_stepping_stones': len(stepping_stones) if stepping_stones else 0
        },
        'high_priority_links': high_priority_links,
        'stepping_stones': stepping_stones if stepping_stones else [],
        'path_finding_ready': True
    }
    
    analysis_file = os.path.join(workspace_dir, 'lotr_path_finding_analysis.json')
    with open(analysis_file, 'w', encoding='utf-8') as f:
        json.dump(analysis_results, f, indent=2, ensure_ascii=False, default=str)
    
    print(f"\n‚úÖ Path-finding analysis saved to: {os.path.basename(analysis_file)}")
    
    print(f"\n=== EXTRACTION AND ANALYSIS COMPLETE ===")
    print(f"üìä Total internal Wikipedia links extracted: {len(existing_data.get('all_internal_wikipedia_links', []))}")
    print(f"üéØ High-priority fantasy/literature links: {len(high_priority_links)}")
    print(f"üîó Direct stepping stones identified: {len(stepping_stones) if stepping_stones else 0}")
    print(f"üìÅ All data saved to workspace: {workspace_dir}")
    print(f"‚úÖ Ready for path-finding analysis to 'A Song of Ice and Fire'")
    
    # Show next steps
    print(f"\n=== NEXT STEPS FOR PATH-FINDING ===")
    print(f"1. Use the extracted links as starting points for BFS search")
    print(f"2. Focus on high-priority fantasy/literature connections")
    print(f"3. Look for connections through authors, awards, and genre pages")
    print(f"4. Target variations: 'A Song of Ice and Fire', 'Game of Thrones', 'George R.R. Martin'")
    
else:
    print("‚ùå No data available for analysis")
```