### Development Step 3: Build adjacency graph of two-cell moves, BFS shortest path, and fetch 11th cell’s hex color

**Description**: Construct adjacency graph of legal two-cell moves using workspace/grid_data.json and workspace/start_end_coordinates.json and perform a breadth-first search from the START cell to locate the shortest path to the END cell enforcing no immediate backtracking; identify the coordinate of the cell landed on after the 11th move along the resulting path; extract that cell’s 6-digit hex fill color from workspace/grid_data.json.

**Use Cases**:
- Warehouse robotics path optimization on a color-coded storage grid to identify the 11th pick-up zone’s hex fill for inventory restocking priorities
- Automated PCB trace routing validation in electronics CAD to locate the 11th via’s layer color and ensure correct signal isolation
- Urban emergency vehicle dispatch simulation on a city-block grid to determine the 11th intersection color-coded by congestion level for real-time rerouting
- Agricultural drone flight planning over farmland plots to track the 11th grid cell’s health-monitoring color marker for targeted pesticide deployment
- Video game AI movement debugging in a tile-based level to extract the 11th step’s terrain tile color and adjust collision or graphical effects
- Microfluidic chip design verification to trace the 11th channel segment’s coating color and confirm chemical compatibility in lab-on-a-chip devices
- Museum guide robot navigation across exhibit floor tiles to fetch the 11th display zone’s color code for dynamic lighting and visitor information updates

```
import os
import json

# Step 1: Inspect workspace directory
workspace_dir = 'workspace'
print(f"Workspace directory: {workspace_dir}")
if not os.path.isdir(workspace_dir):
    print(f"ERROR: {workspace_dir} does not exist or is not a directory.")
    exit(1)

files = os.listdir(workspace_dir)
print(f"Files in workspace: {files}\n")

# Step 2: Identify JSON files to inspect
target_files = ['grid_data.json', 'start_end_coordinates.json']
for fname in target_files:
    path = os.path.join(workspace_dir, fname)
    print(f"--- Inspecting {fname} ---")
    if not os.path.isfile(path):
        print(f"ERROR: {fname} not found in workspace.\n")
        continue
    size = os.path.getsize(path)
    print(f"Path: {path}")
    print(f"Size: {size} bytes")

    # Try raw preview of the first 1000 characters
    try:
        with open(path, 'r', encoding='utf-8') as f:
            raw = f.read(1000)
            print(f"Raw preview (first 1000 chars):\n{raw}\n")
    except Exception as e:
        print(f"Could not read raw content: {e}\n")

    # Load JSON and inspect structure
    try:
        with open(path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        print(f"Loaded JSON type: {type(data)}")
        if isinstance(data, dict):
            keys = list(data.keys())
            print(f"Top-level keys ({len(keys)}): {keys}\n")
            # For each key, show sample type/length
            for k in keys:
                v = data[k]
                t = type(v)
                if isinstance(v, list):
                    print(f"  Key '{k}': list of length {len(v)} (sample element type: {type(v[0]) if v else 'N/A'})")
                elif isinstance(v, dict):
                    subkeys = list(v.keys())
                    print(f"  Key '{k}': dict with keys {subkeys[:5]}{'...' if len(subkeys)>5 else ''}")
                else:
                    print(f"  Key '{k}': {t} -> sample value: {str(v)[:100]}")
        elif isinstance(data, list):
            print(f"JSON is a list of length {len(data)}")
            if data:
                print(f"Sample element (index 0) type: {type(data[0])}")
                print(f"Sample element content: {str(data[0])[:200]}\n")
        else:
            print("JSON loaded but is neither dict nor list.\n")
    except Exception as e:
        print(f"Failed to parse JSON: {e}\n")

    print("\n")

print("Inspection complete. Next step: parse these structures to build the adjacency graph and perform BFS.")
```