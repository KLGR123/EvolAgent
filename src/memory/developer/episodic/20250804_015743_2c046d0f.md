### Development Step 24: BFS Shortest Path to END, Retrieve 11th Coordinate’s Hex Fill Color

**Description**: Perform a breadth-first search on workspace/adjacency_cardinal.json starting from the START coordinate from workspace/start_end_coordinates.json to find the shortest path to the END coordinate; then identify the coordinate at index 11 in the resulting path (representing the landing cell after the eleventh two-cell move) and retrieve its 6-digit hex fill_color from workspace/grid_data.json.

**Use Cases**:
- Automated warehouse robot route optimization and dynamic zone color coding: perform BFS on a storage-grid adjacency map to compute the shortest path from the charging station to a pick-up bay, then use the 11th-cell’s hex fill_color to update the warehouse management UI with zone status.
- 2D game AI pathfinding and in‐game event triggering: run BFS on a tile-based level graph to move an NPC from its spawn point to a target, then extract the 11th tile’s hex color to decide which trap or power‐up to activate at that location.
- GIS-based emergency evacuation routing and hazard overlay: calculate the quickest footpath through city-block adjacency from a building to a safe zone, then sample the 11th block’s fill_color (hex-coded risk level) to render hazard intensity on evacuation maps.
- Network topology visualization and device status highlighting: traverse a network adjacency graph via BFS from a source server to a destination node, identify the 11th hop device, and retrieve its hex fill_color to reflect its health status on the monitoring dashboard.
- Interactive algorithm teaching tool for mazes: use BFS on a classroom maze representation to find the path from entry to exit, then highlight the 11th step cell using its stored hex color, illustrating search progress in real time.
- Precision agriculture seeding path and soil‐quality mapping: plan an autonomous seeder’s route across a farm grid with BFS, locate the tile at the 11th move, and read its hex fill_color (soil nutrient code) to adjust seed distribution on the fly.
- Indoor navigation assistance for accessibility apps: compute the best route through a building’s room adjacency graph from the main entrance to a destination office, then grab the 11th corridor cell’s color code to indicate lighting or surface type for a visually impaired user.

```
import os
import json

# Step 1: Locate the workspace directory (handles "workspace" or "workspace_<uuid>")
cwd = os.getcwd()
candidates = [d for d in os.listdir(cwd) if os.path.isdir(d) and d.startswith('workspace')]
if not candidates:
    raise FileNotFoundError(f"No workspace directory found in {cwd}")
workspace_dir = os.path.join(cwd, 'workspace') if 'workspace' in candidates else os.path.join(cwd, candidates[0])
print(f"Using workspace directory: {workspace_dir}\n")
print(f"Contents: {os.listdir(workspace_dir)}\n")

# Step 2: Load and parse start/end coordinates
se_path = os.path.join(workspace_dir, 'start_end_coordinates.json')
print(f"Loading START/END from: {se_path}")
with open(se_path, 'r') as f:
    se = json.load(f)
print(f"Raw start/end data: {se}\n")

# Extract START coordinate
if 'START' in se:
    v = se['START']
elif 'start' in se:
    v = se['start']
else:
    raise KeyError("Missing 'START' or 'start' in JSON")
if isinstance(v, dict) and 'row' in v and 'col' in v:
    start = (int(v['row']), int(v['col']))
elif isinstance(v, (list, tuple)) and len(v) == 2:
    start = (int(v[0]), int(v[1]))
else:
    raise ValueError(f"Unrecognized START format: {v}")

# Extract END coordinate
if 'END' in se:
    v = se['END']
elif 'end' in se:
    v = se['end']
else:
    raise KeyError("Missing 'END' or 'end' in JSON")
if isinstance(v, dict) and 'row' in v and 'col' in v:
    end = (int(v['row']), int(v['col']))
elif isinstance(v, (list, tuple)) and len(v) == 2:
    end = (int(v[0]), int(v[1]))
else:
    raise ValueError(f"Unrecognized END format: {v}")

print(f"Parsed START: {start}")
print(f"Parsed END:   {end}\n")

# Step 3: Load adjacency graph
adj_path = os.path.join(workspace_dir, 'adjacency_cardinal.json')
print(f"Loading adjacency graph from: {adj_path}")
with open(adj_path, 'r') as f:
    adj_raw = json.load(f)
print(f"Total raw nodes: {len(adj_raw)}\nSample entries: {list(adj_raw.items())[:2]}\n")

# Build tuple-based adjacency list
adj = {}
for key_str, nbrs in adj_raw.items():
    r, c = map(int, key_str.split(','))
    node = (r, c)
    parsed = []
    for n in nbrs:
        if isinstance(n, str):
            rr, cc = map(int, n.split(','))
            parsed.append((rr, cc))
        elif isinstance(n, (list, tuple)) and len(n) == 2:
            parsed.append((int(n[0]), int(n[1])))
        else:
            raise ValueError(f"Bad neighbor format: {n}")
    adj[node] = parsed
print(f"Built adjacency list with {len(adj)} nodes.\n")

# Step 4: BFS shortest path with local import of deque
def bfs_shortest_path(adjacency, start_coord, end_coord):
    # Import inside function so deque is bound in local scope
    import collections
    local_deque = collections.deque
    print("Imported local_deque inside BFS function")
    queue = local_deque([start_coord])
    visited = {start_coord}
    parent = {start_coord: None}
    while queue:
        curr = queue.popleft()
        if curr == end_coord:
            print("Reached END in BFS loop")
            break
        for nb in adjacency.get(curr, []):
            if nb not in visited:
                visited.add(nb)
                parent[nb] = curr
                queue.append(nb)
    if end_coord not in parent:
        print(f"No path found from {start_coord} to {end_coord}")
        return []
    # Reconstruct path
    path = []
    node = end_coord
    while node is not None:
        path.append(node)
        node = parent[node]
    path.reverse()
    return path

print(f"Performing BFS from {start} to {end}...\n")
path = bfs_shortest_path(adj, start, end)
print(f"Path length: {len(path)}")
print(f"First 12 coords: {path[:12]}\n")

# Step 5: Extract the coordinate at index 11
index = 11
if len(path) <= index:
    raise IndexError(f"Path length {len(path)} < required index {index}")
landing = path[index]
print(f"Landing coordinate at index {index}: {landing}\n")

# Step 6: Load grid_data.json and inspect sample
grid_path = os.path.join(workspace_dir, 'grid_data.json')
print(f"Loading grid data from: {grid_path}")
with open(grid_path, 'r') as f:
    grid = json.load(f)
print(f"Total grid entries: {len(grid)}\nSample entry: {grid[0]}\n")

# Step 7: Find the 6-digit hex fill_color for the landing cell
fill_color = None
for cell in grid:
    if 'row' in cell and 'col' in cell:
        coord = (int(cell['row']), int(cell['col']))
    elif 'coordinate' in cell and isinstance(cell['coordinate'], (list, tuple)):
        coord = (int(cell['coordinate'][0]), int(cell['coordinate'][1]))
    else:
        continue
    if coord == landing:
        fill_color = cell.get('fill_color') or cell.get('color')
        break
if not fill_color:
    raise ValueError(f"No fill_color found for coordinate {landing}")
print(f"Found fill_color for {landing}: {fill_color}\n")

# Step 8: Save result to workspace
result = {
    'landing_index': index,
    'landing_coordinate': list(landing),
    'fill_color': fill_color
}
out_path = os.path.join(workspace_dir, 'landing_cell_and_color.json')
with open(out_path, 'w') as f:
    json.dump(result, f, indent=2)
print(f"Result written to: {out_path}\n")

print("===== FINAL ANSWER =====")
print(f"Index: {index}")
print(f"Landing coordinate: {landing}")
print(f"Fill color: {fill_color}")
print("========================")
```