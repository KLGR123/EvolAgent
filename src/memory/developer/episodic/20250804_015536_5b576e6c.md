### Development Step 16: Report START’s Two-Cell Neighbors: Text and Hex Fill from grid_data.json

**Description**: Inspect workspace/grid_data.json entries for the four cardinal two-cell neighbor coordinates of the START cell by locating the coordinates (start_x±2, start_y) and (start_x, start_y±2) based on the recorded START position in workspace/start_end_coordinates.json; report each neighbor’s displayed text and 6-digit hex fill color to verify which moves from START are actually legal.

**Use Cases**:
- Board game engine debugging for chess variants, verifying two-square knight jumps from the START cell using grid metadata to ensure legal move generation.
- Warehouse automation path validation, checking two-cell aisle shifts for automated guided vehicles (AGVs) by inspecting corridor cell labels and status colors in the grid JSON.
- Robotics navigation waypoint planning, confirming two-step moves around obstacles by reading cell occupancy text and obstacle-color codes to validate safe robot turns.
- Traffic signal timing simulation, examining second-neighbor intersections’ signal state text and hex-colors to plan coordinated green waves on a city grid.
- GIS road network analysis, identifying two-road-segment detours by extracting road names and surface-quality color codes from grid data for urban planning reports.
- 2D puzzle game level verification, inspecting two-cell tile neighbors’ types and highlight colors to enforce tile-placement rules during level design.
- Educational tool for teaching matrix operations, retrieving adjacent cell values and background hues to illustrate two-cell shifts and transformations in classroom demos.

```
import os
import json
from pprint import pprint

# STEP 1: Inspect workspace directory
workspace_dir = 'workspace'
print("=== STEP 1: Inspect workspace directory ===")
if not os.path.isdir(workspace_dir):
    print(f"Error: workspace directory '{workspace_dir}' does not exist.")
    exit(1)
files = os.listdir(workspace_dir)
print(f"Files in '{workspace_dir}': {files}\n")

# STEP 2: Load and inspect start/end coordinates
coords_path = os.path.join(workspace_dir, 'start_end_coordinates.json')
print("=== STEP 2: Load start_end_coordinates.json ===")
if not os.path.isfile(coords_path):
    print(f"Error: '{coords_path}' not found.")
    exit(1)
with open(coords_path, 'r') as f:
    coords_data = json.load(f)
print(f"Type of coords_data: {type(coords_data)}")
pprint(coords_data)

# Find START block (case-insensitive)
target_key = None
if isinstance(coords_data, dict):
    for key in coords_data.keys():
        if key.lower() == 'start':
            target_key = key
            break
if target_key is None:
    print("Error: No 'START' key (case-insensitive) in coordinates file.")
    exit(1)
start_block = coords_data[target_key]
print(f"Found START block under key '{target_key}': {start_block}")

# Extract x and y from 'col' and 'row'
if not isinstance(start_block, dict) or 'col' not in start_block or 'row' not in start_block:
    print("Error: 'START' block does not contain 'col' and 'row'.")
    exit(1)
start_x = int(start_block['col'])
start_y = int(start_block['row'])
print(f"Parsed START coordinates: x = {start_x}, y = {start_y}\n")

# STEP 3: Compute the four cardinal two-cell neighbors
print("=== STEP 3: Compute 2-cell neighbors ===")
neighbors = [
    (start_x + 2, start_y),
    (start_x - 2, start_y),
    (start_x, start_y + 2),
    (start_x, start_y - 2)
]
print("Candidate neighbor coordinates (x, y):")
for coord in neighbors:
    print(f"  {coord}")
print()

# STEP 4: Load grid_data.json
grid_path = os.path.join(workspace_dir, 'grid_data.json')
print("=== STEP 4: Load grid_data.json ===")
if not os.path.isfile(grid_path):
    print(f"Error: '{grid_path}' not found.")
    exit(1)
with open(grid_path, 'r') as f:
    grid_data = json.load(f)
print(f"Type of grid_data: {type(grid_data)}")
if not isinstance(grid_data, list):
    print("Error: Expected grid_data.json to be a list of cells.")
    exit(1)
print(f"Total grid entries: {len(grid_data)}")
print("Sample keys in first entry:")
pprint(list(grid_data[0].keys()))
print("Sample entry[0]:")
pprint(grid_data[0])
print()

# STEP 5: Report each neighbor's text and fill_color
print("=== STEP 5: Report neighbor cells ===")
for nx, ny in neighbors:
    # Find matching cell by col, row
    match = None
    for cell in grid_data:
        if cell.get('col') == nx and cell.get('row') == ny:
            match = cell
            break
    if not match:
        print(f"Neighbor at ({nx},{ny}): NOT FOUND in grid_data.json")
        continue

    # Extract display text from common keys
    display_text = None
    for key in ['value', 'text', 'displayText', 'label']:
        if key in match:
            display_text = match[key]
            break
    if display_text is None:
        display_text = '<no text key found>'

    # Extract and normalize fill color
    raw_color = match.get('fill_color', '')
    if not raw_color:
        color = '<no fill color>'
    else:
        c = raw_color.lstrip('#')
        if len(c) == 3:
            # expand shorthand e.g. 'f00' -> 'ff0000'
            c = ''.join([ch*2 for ch in c])
        color = c.upper() if len(c) == 6 else raw_color

    print(f"Neighbor at ({nx},{ny}): text = '{display_text}', color = '{color}'")

```