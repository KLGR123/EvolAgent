### Development Step 1: Locate Greetham’s “Uncoupled: OR, How I Lost My Author(s)” Article and Verify Quoted Passage

**Description**: Search for the academic article 'Uncoupled: OR, How I Lost My Author(s)' by David Greetham published in Textual Cultures: Texts, Contexts, Interpretation, vol. 3 no. 1, 2008, pages 45-46. Use the provided DOI 10.2979/tex.2008.3.1.44 to locate the article on Project MUSE or through DOI resolution. Extract the complete text from pages 45-46 to verify if the quoted passage 'obscured not by a "cloak of print" but by the veil of scribal confusion and mis-transmission' appears exactly as cited in the bibliography.

**Use Cases**:
- University library metadata enrichment: automated DOI resolution and pages 45–46 text extraction to verify specific quoted passages in faculty publications
- Pharmaceutical safety review: retrieving full-text toxicology article pages behind paywalls to validate quoted adverse event descriptions for regulatory submissions
- Patent prosecution support: extracting exact technical passages from engineering journal articles via DOI resolution to substantiate novelty arguments in patent applications
- Investigative journalism fact-checking: scraping scholarly sources to confirm verbatim quotes from academic texts before publishing news stories
- E-learning content creation: accessing and verifying historical textual excerpts from journal archives to ensure accuracy in online course materials
- Systematic review automation: programmatically extracting relevant sections from hundreds of journal articles to support evidence synthesis and meta-analysis in medical research
- Grant proposal development: pulling precise methodological quotes from landmark studies to strengthen literature review sections in funding applications
- Digital humanities research: mining variant readings and scribal transmission notes from early modern texts to analyze patterns of textual confusion and mis-transmission

```
import os
import requests
from bs4 import BeautifulSoup
import json
from urllib.parse import urljoin, urlparse
import time

print('=== SEARCHING FOR GREETHAM ARTICLE ON PROJECT MUSE ===') 
print('Title: Uncoupled: OR, How I Lost My Author(s)')
print('Author: David Greetham')
print('Journal: Textual Cultures: Texts, Contexts, Interpretation')
print('Volume: 3, Issue: 1, Year: 2008, Pages: 45-46')
print('DOI: 10.2979/tex.2008.3.1.44')
print('Objective: Extract complete text from pages 45-46 to verify quoted passage\n')

# Construct the DOI URL
doi_url = 'https://doi.org/10.2979/tex.2008.3.1.44'
print(f'DOI URL: {doi_url}')

# Headers to mimic a real browser request
headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
    'Accept-Language': 'en-US,en;q=0.5',
    'Accept-Encoding': 'gzip, deflate, br',
    'Connection': 'keep-alive',
    'Upgrade-Insecure-Requests': '1',
}

print('\n=== FOLLOWING DOI REDIRECT ===\n')

try:
    # Follow the DOI redirect to get the actual Project MUSE URL
    print('Making initial request to DOI...')
    doi_response = requests.get(doi_url, headers=headers, timeout=30, allow_redirects=True)
    print(f'Final URL after redirects: {doi_response.url}')
    print(f'Status code: {doi_response.status_code}')
    print(f'Content length: {len(doi_response.content):,} bytes')
    print(f'Content type: {doi_response.headers.get("Content-Type", "unknown")}')
    
    if doi_response.status_code == 200:
        # Parse the page to understand its structure
        soup = BeautifulSoup(doi_response.content, 'html.parser')
        
        # Get page title
        page_title = soup.find('title')
        if page_title:
            print(f'\nPage title: {page_title.get_text().strip()}')
        
        # Look for the article title on the page
        article_title_selectors = [
            'h1.title',
            'h1',
            '.article-title',
            '.citation_title',
            '[data-title]'
        ]
        
        article_title_found = None
        for selector in article_title_selectors:
            title_elem = soup.select_one(selector)
            if title_elem:
                title_text = title_elem.get_text().strip()
                if 'uncoupled' in title_text.lower() or 'author' in title_text.lower():
                    article_title_found = title_text
                    print(f'Article title found: {title_text}')
                    break
        
        if not article_title_found:
            print('Article title not immediately found, checking page content...')
            page_text = soup.get_text().lower()
            if 'uncoupled' in page_text or 'greetham' in page_text:
                print('✓ Article content appears to be present on the page')
            else:
                print('⚠ Article content may not be on this page')
        
        # Look for author information
        author_selectors = [
            '.author',
            '.citation_author',
            '.article-author',
            '[data-author]'
        ]
        
        author_found = None
        for selector in author_selectors:
            author_elem = soup.select_one(selector)
            if author_elem:
                author_text = author_elem.get_text().strip()
                if 'greetham' in author_text.lower():
                    author_found = author_text
                    print(f'Author found: {author_text}')
                    break
        
        # Look for journal information
        journal_selectors = [
            '.journal-title',
            '.citation_journal_title',
            '.source-title'
        ]
        
        journal_found = None
        for selector in journal_selectors:
            journal_elem = soup.select_one(selector)
            if journal_elem:
                journal_text = journal_elem.get_text().strip()
                if 'textual cultures' in journal_text.lower():
                    journal_found = journal_text
                    print(f'Journal found: {journal_text}')
                    break
        
        # Look for volume/issue/page information
        citation_info = []
        citation_selectors = [
            '.citation_volume',
            '.citation_issue', 
            '.citation_firstpage',
            '.citation_lastpage',
            '.citation_date'
        ]
        
        for selector in citation_selectors:
            elem = soup.select_one(selector)
            if elem:
                citation_info.append(f'{selector}: {elem.get_text().strip()}')
        
        if citation_info:
            print(f'Citation info found:')
            for info in citation_info:
                print(f'  {info}')
        
        # Look for full text access or PDF download links
        print('\n=== SEARCHING FOR FULL TEXT ACCESS ===\n')
        
        access_selectors = [
            'a[href*=".pdf"]',
            'a[href*="download"]',
            'a[href*="fulltext"]',
            'a[href*="full-text"]',
            'a[href*="view"]',
            '.pdf-link',
            '.download-link',
            '.full-text-link',
            '.access-link'
        ]
        
        access_links = []
        for selector in access_selectors:
            links = soup.select(selector)
            for link in links:
                href = link.get('href')
                if href:
                    # Convert relative URLs to absolute
                    if href.startswith('/'):
                        href = urljoin(doi_response.url, href)
                    access_links.append({
                        'url': href,
                        'text': link.get_text().strip(),
                        'selector': selector
                    })
        
        # Remove duplicates
        unique_access = []
        seen_urls = set()
        for link in access_links:
            if link['url'] not in seen_urls:
                seen_urls.add(link['url'])
                unique_access.append(link)
        
        print(f'Found {len(unique_access)} potential access links:')
        for i, link in enumerate(unique_access, 1):
            print(f'{i}. "{link["text"]}" -> {link["url"]}')
            print(f'   Selector: {link["selector"]}')
        
        # Check for open access indicators
        open_access_indicators = ['open access', 'free access', 'freely available', 'oa']
        page_text_lower = soup.get_text().lower()
        is_open_access = any(indicator in page_text_lower for indicator in open_access_indicators)
        print(f'\nOpen access indicators found: {is_open_access}')
        
        # Look for the specific quoted passage we need to verify
        target_quote = 'obscured not by a "cloak of print" but by the veil of scribal confusion and mis-transmission'
        quote_variations = [
            target_quote,
            target_quote.replace('"', '"').replace('"', '"'),  # Smart quotes
            target_quote.replace('"', "'"),  # Single quotes
            'cloak of print',
            'veil of scribal confusion',
            'scribal confusion and mis-transmission'
        ]
        
        print('\n=== SEARCHING FOR TARGET QUOTE ===\n')
        quote_found = False
        for variation in quote_variations:
            if variation.lower() in page_text_lower:
                print(f'✓ Found quote variation: "{variation}"')
                quote_found = True
                
                # Extract context around the quote
                index = page_text_lower.find(variation.lower())
                full_text = soup.get_text()
                context_start = max(0, index - 300)
                context_end = min(len(full_text), index + 400)
                context = full_text[context_start:context_end]
                
                print(f'Context around quote:')
                print('='*100)
                print(context)
                print('='*100)
                break
        
        if not quote_found:
            print('⚠ Target quote not found in immediately visible page content')
            print('This may indicate the full text is behind a paywall or requires additional access')
        
        # Try to access the most promising link if available
        if unique_access:
            # Prioritize PDF links first
            pdf_links = [link for link in unique_access if '.pdf' in link['url'].lower()]
            
            target_link = pdf_links[0] if pdf_links else unique_access[0]
            
            print(f'\n=== ATTEMPTING TO ACCESS FULL TEXT ===\n')
            print(f'Target link: "{target_link["text"]}"')
            print(f'URL: {target_link["url"]}')
            
            try:
                print('Accessing full text...')
                full_response = requests.get(target_link['url'], headers=headers, timeout=60)
                print(f'Response status: {full_response.status_code}')
                print(f'Content type: {full_response.headers.get("content-type", "unknown")}')
                print(f'Content length: {len(full_response.content):,} bytes')
                
                if full_response.status_code == 200:
                    content_type = full_response.headers.get('content-type', '').lower()
                    
                    if 'pdf' in content_type:
                        # Save PDF for analysis
                        os.makedirs('workspace', exist_ok=True)
                        pdf_path = 'workspace/greetham_uncoupled_article.pdf'
                        
                        with open(pdf_path, 'wb') as pdf_file:
                            pdf_file.write(full_response.content)
                        
                        file_size = os.path.getsize(pdf_path)
                        print(f'\n*** PDF SUCCESSFULLY DOWNLOADED ***')
                        print(f'Saved to: {pdf_path}')
                        print(f'File size: {file_size:,} bytes ({file_size/1024/1024:.2f} MB)')
                        
                    elif 'html' in content_type:
                        # Parse HTML content for the article text
                        print('\n=== PARSING HTML FULL TEXT ===\n')
                        
                        full_soup = BeautifulSoup(full_response.content, 'html.parser')
                        
                        # Remove scripts, styles, and navigation elements
                        for element in full_soup(['script', 'style', 'nav', 'header', 'footer']):
                            element.decompose()
                        
                        # Get the main article text
                        article_content_selectors = [
                            '.article-content',
                            '.full-text',
                            '.article-body',
                            'main',
                            '.content'
                        ]
                        
                        article_text = None
                        for selector in article_content_selectors:
                            content_elem = full_soup.select_one(selector)
                            if content_elem:
                                article_text = content_elem.get_text()
                                print(f'Article content extracted using selector: {selector}')
                                break
                        
                        if not article_text:
                            # Fall back to full page text
                            article_text = full_soup.get_text()
                            print('Using full page text as fallback')
                        
                        # Clean up the text
                        lines = (line.strip() for line in article_text.splitlines())
                        chunks = (phrase.strip() for line in lines for phrase in line.split("  "))
                        clean_text = ' '.join(chunk for chunk in chunks if chunk)
                        
                        print(f'Extracted text length: {len(clean_text):,} characters')
                        
                        # Save the extracted text
                        os.makedirs('workspace', exist_ok=True)
                        text_path = 'workspace/greetham_uncoupled_article_text.txt'
                        
                        with open(text_path, 'w', encoding='utf-8') as text_file:
                            text_file.write(clean_text)
                        
                        print(f'Article text saved to: {text_path}')
                        
                        # Search for the target quote in the full text
                        print('\n=== SEARCHING FULL TEXT FOR TARGET QUOTE ===\n')
                        
                        clean_text_lower = clean_text.lower()
                        quote_found_full = False
                        
                        for variation in quote_variations:
                            if variation.lower() in clean_text_lower:
                                print(f'✓ FOUND TARGET QUOTE: "{variation}"')
                                quote_found_full = True
                                
                                # Extract substantial context
                                index = clean_text_lower.find(variation.lower())
                                context_start = max(0, index - 500)
                                context_end = min(len(clean_text), index + 600)
                                context = clean_text[context_start:context_end]
                                
                                print(f'\n*** QUOTE VERIFICATION CONTEXT ***')
                                print('='*120)
                                print(context)
                                print('='*120)
                                
                                # Save the context for detailed analysis
                                context_path = 'workspace/quote_verification_context.txt'
                                with open(context_path, 'w', encoding='utf-8') as context_file:
                                    context_file.write(f'Target Quote: {target_quote}\n\n')
                                    context_file.write(f'Found Variation: {variation}\n\n')
                                    context_file.write(f'Context:\n{context}')
                                
                                print(f'\nQuote verification context saved to: {context_path}')
                                break
                        
                        if not quote_found_full:
                            print('⚠ Target quote still not found in full text')
                            print('The quote may be paraphrased or located in a different section')
                            
                            # Search for partial matches
                            partial_terms = ['cloak of print', 'scribal confusion', 'mis-transmission', 'veil']
                            print('\nSearching for partial quote elements:')
                            
                            for term in partial_terms:
                                if term.lower() in clean_text_lower:
                                    count = clean_text_lower.count(term.lower())
                                    print(f'✓ Found "{term}": {count} occurrence(s)')
                                    
                                    # Show first occurrence context
                                    index = clean_text_lower.find(term.lower())
                                    context_start = max(0, index - 200)
                                    context_end = min(len(clean_text), index + 300)
                                    context = clean_text[context_start:context_end]
                                    print(f'   Context: ...{context}...')
                                else:
                                    print(f'✗ "{term}": Not found')
                        
                        # Look for pages 45-46 specifically
                        print('\n=== SEARCHING FOR PAGES 45-46 CONTENT ===\n')
                        
                        page_indicators = ['page 45', 'page 46', 'p. 45', 'p. 46', '[45]', '[46]']
                        pages_found = []
                        
                        for indicator in page_indicators:
                            if indicator.lower() in clean_text_lower:
                                pages_found.append(indicator)
                                index = clean_text_lower.find(indicator.lower())
                                context_start = max(0, index - 100)
                                context_end = min(len(clean_text), index + 200)
                                context = clean_text[context_start:context_end]
                                print(f'Found {indicator}: ...{context}...')
                        
                        if pages_found:
                            print(f'\nPage indicators found: {pages_found}')
                        else:
                            print('No explicit page indicators found in the text')
                            print('The article text may be presented without page numbers')
                    
                    else:
                        print(f'Unexpected content type: {content_type}')
                        print(f'Response preview: {full_response.text[:500]}...')
                
                else:
                    print(f'Failed to access full text: {full_response.status_code}')
                    print(f'Response: {full_response.text[:300]}...')
            
            except Exception as e:
                print(f'Error accessing full text: {str(e)}')
        
        # Save comprehensive analysis results
        analysis_results = {
            'search_objective': 'Locate and verify quote from Greetham article pages 45-46',
            'target_quote': target_quote,
            'doi_url': doi_url,
            'final_url': doi_response.url,
            'article_info': {
                'title_found': article_title_found,
                'author_found': author_found,
                'journal_found': journal_found,
                'citation_info': citation_info
            },
            'access_analysis': {
                'access_links_found': len(unique_access),
                'is_open_access': is_open_access,
                'quote_found_on_page': quote_found
            },
            'search_timestamp': time.strftime('%Y-%m-%d %H:%M:%S')
        }
        
        os.makedirs('workspace', exist_ok=True)
        results_file = 'workspace/greetham_article_search_results.json'
        with open(results_file, 'w', encoding='utf-8') as f:
            json.dump(analysis_results, f, indent=2, ensure_ascii=False)
        
        print(f'\n*** SEARCH ANALYSIS COMPLETE ***')
        print(f'✓ DOI successfully resolved to: {doi_response.url}')
        print(f'✓ Article information extracted: {bool(article_title_found)}')
        print(f'✓ Access links found: {len(unique_access)}')
        print(f'✓ Target quote found on page: {quote_found}')
        print(f'✓ Analysis results saved to: {results_file}')
        
    else:
        print(f'Failed to access DOI: {doi_response.status_code}')
        print(f'Response: {doi_response.text[:500]}...')

except Exception as e:
    print(f'Error during DOI resolution: {str(e)}')
    
    # Try alternative approaches
    print('\n=== TRYING ALTERNATIVE ACCESS METHODS ===\n')
    
    # Try direct Project MUSE search
    muse_search_terms = 'greetham uncoupled author textual cultures'
    muse_search_url = f'https://muse.jhu.edu/search?action=search&query={muse_search_terms.replace(" ", "%20")}'
    
    print(f'Attempting direct Project MUSE search:')
    print(f'Search URL: {muse_search_url}')
    
    try:
        search_response = requests.get(muse_search_url, headers=headers, timeout=30)
        print(f'Search response status: {search_response.status_code}')
        
        if search_response.status_code == 200:
            search_soup = BeautifulSoup(search_response.content, 'html.parser')
            
            # Look for article results
            result_links = search_soup.find_all('a', href=True)
            article_links = []
            
            for link in result_links:
                href = link.get('href')
                text = link.get_text().strip()
                if href and ('uncoupled' in text.lower() or 'greetham' in text.lower()):
                    if href.startswith('/'):
                        href = urljoin('https://muse.jhu.edu', href)
                    article_links.append({
                        'url': href,
                        'text': text
                    })
            
            print(f'\nFound {len(article_links)} potential article links:')
            for i, link in enumerate(article_links, 1):
                print(f'{i}. {link["text"]} -> {link["url"]}')
            
            # Save search results
            search_results = {
                'search_url': muse_search_url,
                'status_code': search_response.status_code,
                'article_links_found': article_links,
                'search_timestamp': time.strftime('%Y-%m-%d %H:%M:%S')
            }
            
            with open('workspace/project_muse_search_results.json', 'w', encoding='utf-8') as f:
                json.dump(search_results, f, indent=2, ensure_ascii=False)
            
            print('\nSearch results saved to: workspace/project_muse_search_results.json')
    
    except Exception as search_error:
        print(f'Search attempt failed: {str(search_error)}')

print('\n=== GREETHAM ARTICLE SEARCH COMPLETE ===')
print('Objective: Locate and extract pages 45-46 to verify quoted passage')
print('Status: Initial DOI resolution and access attempt completed')
print('Next steps: Analyze results and extract target content if accessible')
```