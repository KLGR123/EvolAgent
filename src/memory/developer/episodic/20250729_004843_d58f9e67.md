### Development Step 6: Determining Hamiltonian Cycle in Earl‚Äôs 49 Green Plot Adjacency Graph

**Description**: Solve the Hamiltonian path problem to determine if Earl can walk through every plot he owns exactly once and return to his starting plot without backtracking. Using the identified 49 green plots from the previous analysis, construct a graph where each plot is a node and edges connect adjacent plots (horizontally and vertically neighboring cells). Apply graph theory algorithms to check if a Hamiltonian cycle exists in Earl's connected land area, considering movement constraints between adjacent plots only.

**Use Cases**:
- Precision agriculture drone surveying: find a Hamiltonian cycle across 49 crop plots so the drone flies over each field section exactly once and returns to the launch pad without retracing any paths
- Warehouse robot inspection routing: compute a cycle through all storage bay locations in a fulfillment center so the robot checks every rack exactly once before returning to its charging dock
- Campus security patrol planning: design a walking route that visits every checkpoint across the university grounds exactly once and loops back to the security office
- Museum maintenance scheduling: generate a path for staff to service each exhibit room once and finish back in the maintenance hub without revisiting corridors
- Printed circuit board testing sequence: determine a probe path that touches each test pad on the PCB exactly once and returns to the starting pad for automated quality control
- Tourist city walking tour creation: plan a route that guides visitors through all 49 landmark sites in a historic district one time and loops back to the tour start point
- Autonomous vacuum cleaner mapping: chart a cleaning path that covers every floor tile in a smart home layout exactly once and ends back at the charging station

```
import os
import json
from collections import defaultdict
import time

# Load the graph data and implement Hamiltonian cycle detection
graph_file = 'workspace/earl_hamiltonian_graph.json'

print("Loading graph data for Hamiltonian cycle detection...")
with open(graph_file, 'r') as f:
    graph_data = json.load(f)

print("Graph data loaded successfully!")
print(f"Nodes: {graph_data['graph_stats']['num_nodes']}")
print(f"Edges: {graph_data['graph_stats']['num_edges']}")
print(f"Connected: {graph_data['graph_stats']['is_connected']}")

# Convert adjacency list back to proper format
adjacency_list = {}
for node_str, neighbors in graph_data['adjacency_list'].items():
    adjacency_list[int(node_str)] = neighbors

num_nodes = len(graph_data['plot_coordinates'])
print(f"\nConverted adjacency list for {num_nodes} nodes")

# Implement Hamiltonian cycle detection using backtracking
def has_hamiltonian_cycle(adj_list, num_nodes):
    """Check if the graph has a Hamiltonian cycle using backtracking"""
    
    def is_safe(vertex, path, pos):
        """Check if vertex can be added to the current path at position pos"""
        # Check if vertex is adjacent to the previously added vertex
        if path[pos - 1] not in adj_list or vertex not in adj_list[path[pos - 1]]:
            return False
        
        # Check if vertex is already in path
        if vertex in path[:pos]:
            return False
            
        return True
    
    def hamiltonian_util(path, pos):
        """Recursive utility function to solve Hamiltonian cycle"""
        # Base case: if all vertices are included in path
        if pos == num_nodes:
            # Check if there is an edge from last vertex to first vertex
            last_vertex = path[pos - 1]
            first_vertex = path[0]
            return first_vertex in adj_list.get(last_vertex, [])
        
        # Try different vertices as next candidate in Hamiltonian cycle
        for vertex in range(num_nodes):
            if is_safe(vertex, path, pos):
                path[pos] = vertex
                
                # Recursive call to construct rest of the path
                if hamiltonian_util(path, pos + 1):
                    return True
                
                # Backtrack - remove vertex from path
                path[pos] = -1
        
        return False
    
    # Initialize path array
    path = [-1] * num_nodes
    
    # Start with vertex 0 (arbitrary starting point)
    path[0] = 0
    
    # Call recursive utility function
    if hamiltonian_util(path, 1):
        return True, path
    else:
        return False, None

print("\n" + "="*70)
print("HAMILTONIAN CYCLE DETECTION")
print("\nStarting backtracking algorithm...")
print("This may take some time for 49 nodes...")

start_time = time.time()

# Run Hamiltonian cycle detection
has_cycle, cycle_path = has_hamiltonian_cycle(adjacency_list, num_nodes)

end_time = time.time()
computation_time = end_time - start_time

print(f"\nComputation completed in {computation_time:.3f} seconds")

# Report results
print("\n" + "="*70)
print("HAMILTONIAN CYCLE ANALYSIS RESULTS")
print("="*70)

if has_cycle:
    print("‚úÖ HAMILTONIAN CYCLE EXISTS!")
    print("\nüéâ Earl CAN walk through every plot exactly once and return to his starting plot!")
    
    print("\nHamiltonian cycle path (by plot indices):")
    print(f"Path: {' -> '.join(map(str, cycle_path))} -> {cycle_path[0]} (return to start)")
    
    # Convert to actual plot addresses for better understanding
    plot_addresses = []
    for plot_idx in cycle_path:
        row, col = graph_data['plot_coordinates'][plot_idx]
        # Convert to Excel-style address
        col_letter = chr(ord('A') + col - 1)  # Convert 1-based col to letter
        address = f"{col_letter}{row}"
        plot_addresses.append(address)
    
    print("\nHamiltonian cycle path (by plot addresses):")
    print(f"Path: {' -> '.join(plot_addresses)} -> {plot_addresses[0]}")
    
    # Verify the path is valid
    print("\nPath verification:")
    valid_path = True
    for i in range(len(cycle_path)):
        current = cycle_path[i]
        next_node = cycle_path[(i + 1) % len(cycle_path)]  # Wrap around for cycle
        
        if next_node not in adjacency_list[current]:
            print(f"‚ùå Invalid edge: {current} -> {next_node}")
            valid_path = False
    
    if valid_path:
        print("‚úÖ Path verification successful - all edges are valid!")
    
else:
    print("‚ùå NO HAMILTONIAN CYCLE EXISTS")
    print("\nüòû Earl CANNOT walk through every plot exactly once and return to his starting plot")
    print("\nThis means Earl's land layout does not allow for the desired walking path.")
    print("He would need to either:")
    print("  - Accept visiting some plots more than once, or")
    print("  - Accept not returning to his starting plot (Hamiltonian path instead)")

# Save detailed results
results = {
    'hamiltonian_cycle_exists': has_cycle,
    'computation_time_seconds': computation_time,
    'algorithm_used': 'backtracking',
    'graph_stats': graph_data['graph_stats'],
    'cycle_path_indices': cycle_path if has_cycle else None,
    'cycle_path_addresses': plot_addresses if has_cycle else None,
    'conclusion': {
        'can_complete_desired_walk': has_cycle,
        'explanation': 'Earl can walk through every plot exactly once and return to start' if has_cycle 
                      else 'Earl cannot complete the desired walk without backtracking or revisiting plots'
    }
}

with open('workspace/hamiltonian_cycle_results.json', 'w') as f:
    json.dump(results, f, indent=2)

print(f"\nDetailed results saved to workspace/hamiltonian_cycle_results.json")

print("\n" + "="*70)
print("FINAL ANSWER:")
if has_cycle:
    print("üéâ YES - Earl can walk through every plot exactly once and return to his starting plot!")
else:
    print("üòû NO - Earl cannot complete his desired walk without backtracking.")
print("="*70)
```