### Development Step 10: Retrieve Moon's minimum perigee distance from Wikipedia for Earth-Moon closest approach calculation

**Description**: Access the Wikipedia page for the Moon and locate the minimum perigee distance value in the orbital characteristics or distance data section. Extract this specific measurement and note the units (likely in kilometers) for use in calculating the Earth-Moon distance at closest approach.

**Use Cases**:
- Aerospace mission trajectory planning and validation by automatically retrieving the Moon’s minimum perigee distance to optimize fuel budgets for lunar spacecraft
- Satellite communication window scheduling that adjusts Earth–Moon link budgets based on real‐time perigee distance data for deep‐space network planning
- Tidal energy forecasting models that refine ocean tide predictions using accurate closest‐approach distances of the Moon to improve coastal power generation estimates
- Commercial space tourism itinerary design around lunar flybys by integrating perigee timing and distance into experience scheduling and safety analyses
- Interactive astronomy education platforms that dynamically visualize the Moon’s orbit and highlight perigee passages for students learning celestial mechanics
- Science journalism and content automation pipelines that extract up-to-date lunar distance metrics to populate live news articles and infographics on Moon missions
- Virtual reality and simulation studios updating lunar surface renderings and skybox environments with precise perigee measurements to enhance immersion
- Geospatial and eclipse prediction services incorporating Earth–Moon minimum distance data to more accurately forecast totality paths and viewing conditions

```
import requests
from bs4 import BeautifulSoup
import json
import re
import os

print("=== MOON WIKIPEDIA PAGE ACCESS AND PERIGEE DISTANCE EXTRACTION - VARIABLE SCOPE FIXED ===")
print("Objective: Find minimum perigee distance from Moon's Wikipedia page")
print("Focus: Locate orbital characteristics section and extract distance measurement\n")

# Create workspace directory if it doesn't exist
os.makedirs('workspace', exist_ok=True)

# Access the Wikipedia page for the Moon
url = "https://en.wikipedia.org/wiki/Moon"
print(f"Accessing Wikipedia page: {url}")

# Set up headers to mimic browser request
headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
    'Accept-Language': 'en-US,en;q=0.5',
    'Accept-Encoding': 'gzip, deflate',
    'Connection': 'keep-alive'
}

try:
    response = requests.get(url, headers=headers, timeout=30)
    
    if response.status_code == 200:
        print(f"✓ Successfully accessed Moon Wikipedia page")
        print(f"Content length: {len(response.content):,} bytes")
        
        # Save the HTML content
        html_file = 'workspace/moon_wikipedia.html'
        with open(html_file, 'w', encoding='utf-8') as f:
            f.write(response.text)
        print(f"HTML content saved to: {html_file}")
        
        # Parse the HTML content
        soup = BeautifulSoup(response.text, 'html.parser')
        
        # Extract the page title for verification
        page_title = soup.find('title')
        if page_title:
            print(f"Page title: {page_title.get_text().strip()}")
        
        # Look for orbital characteristics or distance-related sections
        print(f"\n=== SEARCHING FOR ORBITAL CHARACTERISTICS SECTIONS ===")
        
        # Find headings that might contain orbital data
        orbital_headings = []
        headings = soup.find_all(['h1', 'h2', 'h3', 'h4'], string=re.compile(r'orbit|distance|characteristic|perigee|apogee', re.IGNORECASE))
        
        for heading in headings:
            heading_text = heading.get_text().strip()
            print(f"Found relevant heading: {heading_text}")
            orbital_headings.append({
                'text': heading_text,
                'tag': heading.name,
                'element': heading
            })
        
        # Also look for infobox which typically contains orbital data
        print(f"\n=== SEARCHING FOR INFOBOX DATA ===")
        
        infobox = soup.find('table', class_=re.compile(r'infobox', re.IGNORECASE))
        infobox_data = []  # Initialize empty list
        
        if infobox:
            print("✓ Found infobox table")
            
            # Extract all rows from infobox
            rows = infobox.find_all('tr')
            print(f"Found {len(rows)} rows in infobox")
            
            # Define orbital keywords outside the loop
            orbital_keywords = ['distance', 'perigee', 'apogee', 'orbit', 'semi-major', 'periapsis', 'apoapsis']
            distance_keywords = ['perigee', 'apogee', 'distance']
            
            for i, row in enumerate(rows):
                # Get the label and value from each row
                cells = row.find_all(['th', 'td'])
                if len(cells) >= 2:
                    label = cells[0].get_text().strip()
                    value = cells[1].get_text().strip()
                    
                    # Check if label contains orbital keywords - FIXED: variables defined in scope
                    label_has_orbital = False
                    for keyword in orbital_keywords:
                        if keyword in label.lower():
                            label_has_orbital = True
                            break
                    
                    if label_has_orbital:
                        print(f"Orbital data found - {label}: {value}")
                        infobox_data.append({
                            'label': label,
                            'value': value,
                            'row_index': i,
                            'raw_html': str(row)
                        })
                    
                    # Check if the value contains distance information - FIXED: variables defined in scope
                    value_has_distance = False
                    if 'km' in value.lower():
                        for keyword in distance_keywords:
                            if keyword in value.lower():
                                value_has_distance = True
                                break
                    
                    if value_has_distance:
                        print(f"Distance data in value - {label}: {value}")
                        infobox_data.append({
                            'label': label,
                            'value': value,
                            'row_index': i,
                            'raw_html': str(row)
                        })
                    
                    # Print all rows with numerical values and km for debugging
                    if 'km' in value and any(char.isdigit() for char in value):
                        print(f"Row {i}: {label} = {value}")
        else:
            print("No infobox found")
        
        # Search for specific perigee distance patterns in the entire page text
        print(f"\n=== SEARCHING FOR PERIGEE DISTANCE PATTERNS ===")
        
        page_text = soup.get_text()
        
        # Common patterns for perigee distance - more comprehensive
        perigee_patterns = [
            r'perigee[^\n]*?(\d+[,\d]*\.?\d*)\s*km',
            r'minimum distance[^\n]*?(\d+[,\d]*\.?\d*)\s*km',
            r'closest approach[^\n]*?(\d+[,\d]*\.?\d*)\s*km',
            r'(\d+[,\d]*\.?\d*)\s*km[^\n]*perigee',
            r'perigee.*?(\d+[,\d]*\.?\d*)\s*kilometres',
            r'356[,\d]*\s*km',  # Common approximate perigee distance
            r'perigee:\s*(\d+[,\d]*\.?\d*)\s*km',
            r'(\d+[,\d]*\.?\d*)\s*km.*?perigee',
            r'perigee.*?(\d+[,\d]*\.?\d*)',
            r'periapsis[^\n]*?(\d+[,\d]*\.?\d*)\s*km',
            r'(\d+[,\d]*\.?\d*)\s*km[^\n]*periapsis',
            r'nearest[^\n]*?(\d+[,\d]*\.?\d*)\s*km'
        ]
        
        perigee_matches = []
        for pattern in perigee_patterns:
            matches = re.finditer(pattern, page_text, re.IGNORECASE)
            for match in matches:
                context_start = max(0, match.start() - 150)
                context_end = min(len(page_text), match.end() + 150)
                context = page_text[context_start:context_end].strip()
                
                # Extract the numerical value
                distance_value = None
                if match.groups():
                    distance_value = match.group(1)
                else:
                    # Try to extract number from the full match
                    number_match = re.search(r'(\d+[,\d]*\.?\d*)', match.group())
                    if number_match:
                        distance_value = number_match.group(1)
                
                perigee_matches.append({
                    'pattern': pattern,
                    'match': match.group(),
                    'context': context,
                    'distance_value': distance_value
                })
                
                print(f"Perigee match found: {match.group()}")
                print(f"Extracted distance: {distance_value}")
                print(f"Context: ...{context[:250]}...")
                print()
        
        # Look for specific sections about orbital mechanics
        print(f"\n=== EXAMINING ORBITAL MECHANICS SECTIONS ===")
        
        orbital_sections = []
        for heading in orbital_headings:
            # Get content following this heading
            current = heading['element']
            section_content = []
            
            # Collect paragraphs following the heading
            for _ in range(15):  # Look at next 15 elements
                current = current.find_next_sibling()
                if current is None:
                    break
                if current.name == 'p':
                    text = current.get_text().strip()
                    if text:  # Only add non-empty paragraphs
                        section_content.append(text)
                elif current.name in ['h1', 'h2', 'h3', 'h4']:  # Hit next major section
                    break
            
            if section_content:
                full_content = ' '.join(section_content)
                orbital_sections.append({
                    'heading': heading['text'],
                    'content': full_content
                })
                
                # Check if this section contains perigee information
                section_keywords = ['perigee', 'distance', 'km', 'closest', 'nearest']
                section_has_distance = False
                for keyword in section_keywords:
                    if keyword in full_content.lower():
                        section_has_distance = True
                        break
                
                if section_has_distance:
                    print(f"Section '{heading['text']}' contains distance information:")
                    print(f"Content preview: {full_content[:400]}...")
                    
                    # Look for specific distance values in this section
                    distance_numbers = re.findall(r'\d+[,\d]*\.?\d*\s*km', full_content)
                    if distance_numbers:
                        print(f"Distance values found: {distance_numbers}")
                    print()
        
        # Additional search for distance values in tables
        print(f"\n=== SEARCHING ALL TABLES FOR DISTANCE DATA ===")
        
        all_tables = soup.find_all('table')
        table_distance_data = []
        
        for i, table in enumerate(all_tables):
            table_text = table.get_text()
            table_keywords = ['perigee', 'apogee', 'distance', 'orbit', 'km']
            table_has_orbital = False
            for keyword in table_keywords:
                if keyword in table_text.lower():
                    table_has_orbital = True
                    break
            
            if table_has_orbital:
                print(f"Table {i+1} contains orbital/distance data")
                
                # Extract all cells that might contain distance values
                cells = table.find_all(['td', 'th'])
                for cell in cells:
                    cell_text = cell.get_text().strip()
                    if 'km' in cell_text and any(char.isdigit() for char in cell_text):
                        # Extract numbers from the cell
                        numbers = re.findall(r'\d+[,\d]*\.?\d*', cell_text)
                        if numbers:
                            table_distance_data.append({
                                'table_index': i+1,
                                'cell_text': cell_text,
                                'numbers': numbers
                            })
                            print(f"  Distance data: {cell_text}")
        
        # Save all extracted data
        extraction_data = {
            'page_url': url,
            'extraction_timestamp': response.headers.get('date', 'unknown'),
            'page_title': page_title.get_text().strip() if page_title else 'Unknown',
            'infobox_data': infobox_data,
            'perigee_matches': perigee_matches,
            'orbital_sections': orbital_sections,
            'orbital_headings': [h['text'] for h in orbital_headings],
            'table_distance_data': table_distance_data
        }
        
        results_file = 'workspace/moon_perigee_extraction.json'
        with open(results_file, 'w', encoding='utf-8') as f:
            json.dump(extraction_data, f, indent=2, ensure_ascii=False)
        
        print(f"\n=== EXTRACTION SUMMARY ===")
        print(f"Infobox orbital data entries: {len(infobox_data)}")
        print(f"Perigee pattern matches: {len(perigee_matches)}")
        print(f"Orbital sections found: {len(orbital_sections)}")
        print(f"Table distance data entries: {len(table_distance_data)}")
        print(f"Results saved to: {results_file}")
        
        # Quick analysis of found values
        print(f"\n=== ANALYZING EXTRACTED PERIGEE VALUES ===")
        all_distance_values = []
        
        # Collect all distance values from different sources
        for match in perigee_matches:
            if match['distance_value']:
                clean_value = match['distance_value'].replace(',', '')
                all_distance_values.append(clean_value)
        
        for data in table_distance_data:
            for number in data['numbers']:
                clean_value = number.replace(',', '')
                all_distance_values.append(clean_value)
        
        if all_distance_values:
            unique_values = list(set(all_distance_values))
            print(f"All distance values found: {unique_values}")
            
            # Convert to numeric and find minimum (perigee)
            numeric_values = []
            for value in unique_values:
                try:
                    numeric_val = float(value)
                    # Filter reasonable values (Moon distance should be 300,000-400,000 km range)
                    if 300000 <= numeric_val <= 500000:
                        numeric_values.append(numeric_val)
                except ValueError:
                    continue
            
            if numeric_values:
                min_distance = min(numeric_values)
                max_distance = max(numeric_values)
                print(f"\n*** PERIGEE DISTANCE FOUND ***")
                print(f"Minimum distance (perigee): {min_distance:,.0f} km")
                print(f"Maximum distance (apogee): {max_distance:,.0f} km")
            else:
                print("No valid numeric distance values found in expected range")
        else:
            print("No distance values extracted")
        
    else:
        print(f"Failed to access Wikipedia page. Status code: {response.status_code}")
        print(f"Response headers: {dict(response.headers)}")
        
except requests.exceptions.RequestException as e:
    print(f"Error accessing Wikipedia page: {e}")

print(f"\n=== MOON WIKIPEDIA ACCESS COMPLETE ===")
print("Perigee distance extraction completed - check results file for detailed data")
```