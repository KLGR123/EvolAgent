### Development Step 19: BFS Shortest Path: 11th Two-Cell Move Landing Cell Hex Color

**Description**: Perform a breadth-first search on workspace/adjacency_cardinal.json starting from the START coordinate from workspace/start_end_coordinates.json to find the shortest path to the END coordinate; then identify the coordinate at index 11 in the resulting path (representing the landing cell after the eleventh two-cell move) and retrieve its 6-digit hex fill_color from workspace/grid_data.json.

**Use Cases**:
- Autonomous warehouse robot path planning on grid floor tiles, retrieving the 11th tile’s wear-level hex color code for predictive maintenance scheduling
- Drone-based agricultural field survey navigating a grid of crop plots, identifying the 11th plot’s vegetation health hex color for variable-rate fertilization
- Urban planning pedestrian navigation simulation on city-block adjacency, extracting the 11th intersection’s zoning hex color to assess accessibility improvements
- Network packet tracing over a mesh of routers, computing the shortest path to a destination and retrieving the 11th hop’s status hex color for diagnostics
- Automated guided vehicle (AGV) routing in a manufacturing plant, determining the 11th floor marker tile’s safety hex color to dynamically adjust vehicle speed
- Video game AI NPC navigation on a tile-based map, finding the shortest route to a quest objective and checking the 11th tile’s terrain hex color for movement-cost calculation
- Disaster evacuation modeling in a hospital layout grid, plotting the exit route and inspecting the 11th door’s hazard-level hex color to ensure safe egress
- Archaeological site scanning with ground-penetrating radar, mapping a grid of excavation sectors, planning a survey path and retrieving the 11th sector’s soil anomaly hex color for sampling prioritization

```
import os
import json
from collections import deque

# Step 1: Inspect workspace directory
workspace_dir = 'workspace'
print(f"\nInspecting workspace directory: {workspace_dir}")
if not os.path.isdir(workspace_dir):
    raise FileNotFoundError(f"Workspace directory not found: {workspace_dir}")
files = os.listdir(workspace_dir)
print(f"Files in workspace: {files}\n")

# Step 2: Load and inspect start/end coordinates
start_end_path = os.path.join(workspace_dir, 'start_end_coordinates.json')
print(f"Loading start/end coordinates from: {start_end_path}")
with open(start_end_path, 'r') as f:
    start_end = json.load(f)
print(f"Raw start/end data: {start_end}\n")

# Determine key names for start and end
if 'start' in start_end and 'end' in start_end:
    start_coord = tuple(start_end['start'])
    end_coord = tuple(start_end['end'])
elif 'START' in start_end and 'END' in start_end:
    start_coord = tuple(start_end['START'])
    end_coord = tuple(start_end['END'])
else:
    # Print available keys and abort
    print("Unable to find 'start'/'end' keys in start_end_coordinates.json. Available keys:", list(start_end.keys()))
    raise KeyError("start/end keys not found in start_end_coordinates.json")
print(f"Parsed START coordinate: {start_coord}")
print(f"Parsed END coordinate:   {end_coord}\n")

# Step 3: Load and inspect adjacency_cardinal.json
adjacency_path = os.path.join(workspace_dir, 'adjacency_cardinal.json')
print(f"Loading adjacency graph from: {adjacency_path}")
with open(adjacency_path, 'r') as f:
    adjacency_raw = json.load(f)

# Inspect type and size
print(f"Type of adjacency data: {type(adjacency_raw)}")
if isinstance(adjacency_raw, dict):
    total_keys = len(adjacency_raw)
    print(f"Number of nodes in adjacency dict: {total_keys}")
    sample_keys = list(adjacency_raw.keys())[:5]
    print(f"Sample keys: {sample_keys}")
    print("Sample adjacency for first key:", adjacency_raw[sample_keys[0]])
else:
    raise TypeError("Expected adjacency_cardinal.json to be a JSON object (dict)")
print()

# Build adjacency_list mapping tuple coords to list of tuple coords
adjacency_list = {}
for key_str, neighbors in adjacency_raw.items():
    # Parse the key string into a tuple: assume 'row,col' format
    try:
        row_s, col_s = key_str.split(',')
        node = (int(row_s), int(col_s))
    except Exception as e:
        raise ValueError(f"Unrecognized coordinate key format: '{key_str}'")
    # Parse neighbors: assume list of strings with same format or list of lists
    parsed_neighbors = []
    for n in neighbors:
        if isinstance(n, str):
            r_s, c_s = n.split(',')
            parsed_neighbors.append((int(r_s), int(c_s)))
        elif isinstance(n, (list, tuple)) and len(n) == 2:
            parsed_neighbors.append((int(n[0]), int(n[1])))
        else:
            raise ValueError(f"Unrecognized neighbor format: {n}")
    adjacency_list[node] = parsed_neighbors
print(f"Built adjacency_list with {len(adjacency_list)} nodes.\n")

# Step 4: BFS to find shortest path from start to end
def bfs_shortest_path(adj, start, end):
    """Return the shortest path from start to end using BFS."""
    queue = deque([start])
    visited = set([start])
    parent = {start: None}

    while queue:
        current = queue.popleft()
        if current == end:
            break
        for nbr in adj.get(current, []):
            if nbr not in visited:
                visited.add(nbr)
                parent[nbr] = current
                queue.append(nbr)
    # Reconstruct path
    if end not in parent:
        print(f"No path found from {start} to {end}")
        return []
    path = []
    node = end
    while node is not None:
        path.append(node)
        node = parent[node]
    path.reverse()
    return path

print(f"Performing BFS from {start_coord} to {end_coord}...")
path = bfs_shortest_path(adjacency_list, start_coord, end_coord)
print(f"BFS path found with length {len(path)} steps")
print(f"Full path (first 15 coords): {path[:15]} ...\n")

# Step 5: Identify coordinate at index 11
index = 11
if len(path) <= index:
    raise IndexError(f"Path length {len(path)} is too short to get index {index}")
landing_cell = path[index]
print(f"Coordinate at index {index}: {landing_cell}\n")

# Step 6: Load grid_data.json and inspect
grid_data_path = os.path.join(workspace_dir, 'grid_data.json')
print(f"Loading grid data from: {grid_data_path}")
with open(grid_data_path, 'r') as f:
    grid_data = json.load(f)
print(f"Type of grid_data: {type(grid_data)}")
if isinstance(grid_data, list):
    print(f"Number of grid entries: {len(grid_data)}")
    print(f"Sample grid entry: {grid_data[0]}\n")
else:
    raise TypeError("Expected grid_data.json to be a JSON array (list)")

# Step 7: Find fill_color for landing_cell in grid_data
fill_color = None
for cell in grid_data:
    # Cell might store coordinates under keys 'row','col' or 'coordinate'
    if 'row' in cell and 'col' in cell:
        coord = (int(cell['row']), int(cell['col']))
    elif 'coordinate' in cell and isinstance(cell['coordinate'], (list, tuple)):
        coord = (int(cell['coordinate'][0]), int(cell['coordinate'][1]))
    else:
        continue
    if coord == landing_cell:
        # Retrieve fill_color or 'color'
        if 'fill_color' in cell:
            fill_color = cell['fill_color']
        elif 'color' in cell:
            fill_color = cell['color']
        else:
            raise KeyError(f"No fill_color or color key in grid_data entry {cell}")
        break
if fill_color is None:
    raise ValueError(f"Could not find grid_data entry for coordinate {landing_cell}")
print(f"Found fill_color for {landing_cell}: {fill_color}\n")

# Step 8: Save result to workspace
result = {
    'landing_cell_index': index,
    'landing_cell_coordinate': list(landing_cell),
    'fill_color': fill_color
}
output_path = os.path.join(workspace_dir, 'landing_cell_and_color.json')
with open(output_path, 'w') as f:
    json.dump(result, f, indent=2)
print(f"Result saved to: {output_path}\n")

# Final output summary
print("===== Final Answer =====")
print(f"Eleventh landing cell at index {index}: {landing_cell}")
print(f"Its 6-digit hex fill_color: {fill_color}")
print("========================")
```