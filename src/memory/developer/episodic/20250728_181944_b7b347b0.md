### Development Step 5: Minimum Cell Tower Placement for Seven Houses Using Greedy Interval Cover Algorithm

**Description**: Solve the minimum cell phone tower coverage optimization problem using the analyzed house positions from data/gaia/2023/validation/389793a7-ca17-4e82-81cb-2b3a2391b4b9.txt. Apply the greedy algorithm approach for the interval covering problem: (1) Convert each house position to a coverage interval showing all possible tower locations that can reach that house within 4-mile radius, (2) Sort intervals by their end points, (3) Use greedy selection to find minimum towers by repeatedly choosing the rightmost position that covers the leftmost uncovered house, (4) Verify the solution covers all 7 houses and calculate the final minimum number of towers needed.

**Use Cases**:
- Rural cell tower deployment planning: use the greedy interval covering algorithm to identify the minimal set of new tower locations along a major highway to guarantee 4-mile coverage for all dispersed farmhouses, cutting infrastructure costs.
- Outdoor event wireless network design: apply the greedy coverage optimization approach to determine the smallest number of portable cell towers needed to blanket a music festival‚Äôs grounds and adjacent parking lots with reliable service during peak attendance.
- Post-disaster communication restoration: leverage the interval covering greedy strategy to optimally position mobile base stations and satellite uplink trucks in earthquake-affected regions, ensuring all temporary shelters are within 4-mile connectivity range for rescue coordination.
- Smart farming LoRaWAN gateway placement: use the greedy interval covering method to compute the fewest gateways necessary to cover moisture and weather sensors spread across extensive crop fields within the LoRaWAN range, minimizing hardware and maintenance.
- University dormitory Wi-Fi access point arrangement: apply the interval covering greedy algorithm to place the minimum number of wireless routers along dormitory corridors, guaranteeing every common area and bedroom lies within signal range and reducing energy consumption.
- Drone delivery hub siting for last-mile logistics: utilize the greedy coverage optimization to place the fewest drone charging and dispatch hubs along suburban delivery routes, ensuring all customer clusters are within the drone‚Äôs operational radius and lowering capital expenditure.
- Coastal acoustic sensor network deployment for wildlife monitoring: employ the greedy interval covering solution to determine the minimal number of listening stations needed along a 20-mile shoreline to monitor seal and bird populations within audible distance, saving on sensor costs.
- Retail chain distribution center siting: apply the interval covering greedy algorithm to choose the smallest set of warehouse locations along major transport corridors, making sure every retail outlet is within the designated delivery radius and improving logistics efficiency.

```
# Step 3: Implement the greedy algorithm for minimum cell phone tower coverage
import json
import os

# First, let's inspect the coverage intervals file to understand its structure
intervals_file = 'workspace/coverage_intervals.json'

print("Inspecting coverage intervals file structure...")
if os.path.exists(intervals_file):
    with open(intervals_file, 'r') as f:
        interval_data = json.load(f)
    
    print(f"Keys in interval_data: {list(interval_data.keys())}")
    print(f"House positions: {interval_data.get('house_positions', 'Not found')}")
    print(f"Coverage intervals: {interval_data.get('coverage_intervals', 'Not found')}")
    print(f"Tower range: {interval_data.get('tower_range', 'Not found')}")
else:
    print(f"Error: File {intervals_file} not found")

# Extract the necessary data
house_positions = interval_data['house_positions']
coverage_intervals = interval_data['coverage_intervals']
tower_range = interval_data['tower_range']

print("\n" + "="*70)
print("GREEDY ALGORITHM FOR MINIMUM CELL TOWER COVERAGE")
print("="*70)

print(f"\nProblem setup:")
print(f"- Number of houses: {len(house_positions)}")
print(f"- House positions: {house_positions}")
print(f"- Tower range: {tower_range} miles")
print(f"- Coverage intervals: {coverage_intervals}")

# Step 1: Sort intervals by their end points (greedy algorithm requirement)
print("\nStep 1: Sorting intervals by end points...")
# Convert to format (start, end, house_id) and sort by end point
sorted_intervals = sorted(coverage_intervals, key=lambda x: x[1])

print("Sorted intervals by end point:")
for i, (start, end, house_id) in enumerate(sorted_intervals):
    print(f"  {i+1}. House {house_id}: [{start}, {end}] (end={end})")

# Step 2: Apply greedy algorithm
print("\nStep 2: Applying greedy algorithm...")
print("Strategy: Select the rightmost tower position that covers the leftmost uncovered house")

tower_positions = []
covered_houses = set()
i = 0

print("\nGreedy selection process:")
while i < len(sorted_intervals) and len(covered_houses) < len(house_positions):
    start, end, house_id = sorted_intervals[i]
    
    # Check if this house is already covered
    if house_id in covered_houses:
        print(f"  - House {house_id} already covered, skipping...")
        i += 1
        continue
    
    # Place tower at the rightmost position of this interval (greedy choice)
    tower_pos = end
    tower_positions.append(tower_pos)
    print(f"\n  Tower {len(tower_positions)}: Placed at position {tower_pos}")
    
    # Find all houses that this tower covers
    newly_covered = []
    for house_pos in house_positions:
        house_num = house_positions.index(house_pos) + 1
        if house_num not in covered_houses:
            # Check if tower is within range of this house
            if abs(tower_pos - house_pos) <= tower_range:
                covered_houses.add(house_num)
                newly_covered.append((house_num, house_pos))
    
    print(f"    Covers houses: {[h for h, p in newly_covered]} at positions {[p for h, p in newly_covered]}")
    print(f"    Total houses covered so far: {len(covered_houses)}/{len(house_positions)}")
    
    i += 1

print(f"\nGreedy algorithm completed!")
print(f"Number of towers needed: {len(tower_positions)}")
print(f"Tower positions: {tower_positions}")
print(f"Houses covered: {sorted(covered_houses)}")

# Step 3: Verify the solution
print("\n" + "="*70)
print("SOLUTION VERIFICATION")
print("="*70)

print("\nVerifying that all houses are covered...")
verification_results = []

for i, house_pos in enumerate(house_positions, 1):
    covering_towers = []
    for j, tower_pos in enumerate(tower_positions, 1):
        distance = abs(tower_pos - house_pos)
        if distance <= tower_range:
            covering_towers.append((j, tower_pos, distance))
    
    is_covered = len(covering_towers) > 0
    verification_results.append((i, house_pos, is_covered, covering_towers))
    
    print(f"House {i} at position {house_pos}:")
    if is_covered:
        print(f"  ‚úì COVERED by tower(s): {[f'Tower {t}@{p} (dist={d})' for t, p, d in covering_towers]}")
    else:
        print(f"  ‚úó NOT COVERED")

all_covered = all(result[2] for result in verification_results)
print(f"\nAll houses covered: {all_covered}")

# Calculate final answer
print("\n" + "="*70)
print("FINAL SOLUTION")
print("="*70)

print(f"\nProblem: Minimum number of cell phone towers needed to cover {len(house_positions)} houses")
print(f"Tower range: {tower_range} miles")
print(f"House positions: {house_positions}")
print(f"\nSolution using greedy algorithm:")
print(f"- Minimum number of towers: {len(tower_positions)}")
print(f"- Tower positions: {tower_positions}")
print(f"- All houses covered: {all_covered}")

if all_covered:
    print(f"\nüéâ SUCCESS: All {len(house_positions)} houses are covered with {len(tower_positions)} towers!")
else:
    print(f"\n‚ùå ERROR: Solution does not cover all houses!")

# Save the solution
solution_data = {
    'problem': {
        'house_positions': house_positions,
        'num_houses': len(house_positions),
        'tower_range': tower_range
    },
    'solution': {
        'min_towers_needed': len(tower_positions),
        'tower_positions': tower_positions,
        'all_houses_covered': all_covered
    },
    'verification': verification_results,
    'algorithm': 'Greedy Algorithm for Interval Covering'
}

with open('workspace/tower_optimization_solution.json', 'w') as f:
    json.dump(solution_data, f, indent=2)

print(f"\nComplete solution saved to workspace/tower_optimization_solution.json")
print(f"\nFINAL ANSWER: {len(tower_positions)} towers")
```