### Development Step 7: Title:  
Extract and Analyze XML Category Texts to Identify Unique Food Item from Spreadsheet Data

**Description**: Parse and analyze the attached XML file data/gaia/2023/validation/9b54f9d9-35ee-4a14-b62f-d130ea00317f/CATEGORIES.xml to extract all text elements under the CATEGORIES section. Examine the structure and content of each category element to understand how foods are organized. Then cross-reference the three unique food items identified from the spreadsheet analysis ('goat meat', 'mutton', and 'turtle soup') against the XML categories to determine which specific text element would contain the one food that appears only once in the spreadsheet without duplicates.

**Use Cases**:
- Food safety compliance auditing by cross-referencing regulated food items from spreadsheets against official XML food category lists in government databases
- Restaurant menu engineering to identify unique or rare menu items by comparing internal inventory spreadsheets with standardized food taxonomy XML files
- Automated quality assurance in food delivery platforms by validating that all menu items are properly categorized and uniquely identified in the system’s XML configuration
- Nutrition research projects that require mapping unique food consumption entries from survey spreadsheets to standardized food categories in public health XML datasets
- Supply chain traceability for specialty meats by ensuring that unique items (e.g., “goat meat”, “turtle soup”) in supplier spreadsheets are accurately reflected in centralized XML product catalogs
- Data migration for legacy food service systems, ensuring that unique or non-duplicated food items are preserved and correctly categorized during transfer from spreadsheets to XML-based databases
- Retail analytics for supermarkets, where unique food products identified in sales spreadsheets are matched against XML-based product hierarchies to optimize shelf placement and category management
- Regulatory reporting in the seafood industry by verifying that rare or protected food items from catch logs are cross-checked against XML lists of approved categories for compliance

```
import os
import xml.etree.ElementTree as ET
import json

# Parse the XML file to extract all text elements under CATEGORIES
xml_path = "data/gaia/2023/validation/9b54f9d9-35ee-4a14-b62f-d130ea00317f/CATEGORIES.xml"

print("=== PARSING XML CATEGORIES FILE ===")
print(f"Analyzing file: {xml_path}")

# Check if file exists
if not os.path.exists(xml_path):
    print(f"Error: XML file '{xml_path}' does not exist.")
else:
    print(f"File exists: {xml_path}")
    file_size = os.path.getsize(xml_path)
    print(f"File size: {file_size} bytes")
    
    # Parse the XML file
    try:
        tree = ET.parse(xml_path)
        root = tree.getroot()
        
        print(f"\nRoot element: {root.tag}")
        print(f"Root attributes: {root.attrib}")
        
        # Display the XML structure
        print("\n=== XML STRUCTURE ANALYSIS ===")
        
        def analyze_element(element, level=0):
            indent = "  " * level
            print(f"{indent}Element: {element.tag}")
            if element.attrib:
                print(f"{indent}Attributes: {element.attrib}")
            if element.text and element.text.strip():
                print(f"{indent}Text: '{element.text.strip()}'")
            
            # Analyze children
            children = list(element)
            if children:
                print(f"{indent}Children count: {len(children)}")
                for child in children:
                    analyze_element(child, level + 1)
            
            return element.tag, element.text, element.attrib, len(children)
        
        # Analyze the complete structure
        analyze_element(root)
        
        # Extract all text elements specifically under CATEGORIES section
        print("\n=== EXTRACTING CATEGORIES TEXT ELEMENTS ===")
        
        categories_elements = []
        
        # Look for CATEGORIES elements
        categories_nodes = root.findall('.//CATEGORIES') + root.findall('.//categories')
        if not categories_nodes:
            # Try case-insensitive search
            for elem in root.iter():
                if elem.tag.lower() == 'categories':
                    categories_nodes.append(elem)
        
        print(f"Found {len(categories_nodes)} CATEGORIES nodes")
        
        if categories_nodes:
            for i, categories_node in enumerate(categories_nodes):
                print(f"\n--- CATEGORIES Node {i+1} ---")
                print(f"Tag: {categories_node.tag}")
                print(f"Attributes: {categories_node.attrib}")
                
                # Extract all text content from this categories node
                def extract_text_elements(element, path=""):
                    current_path = f"{path}/{element.tag}" if path else element.tag
                    
                    # If element has text content
                    if element.text and element.text.strip():
                        text_content = element.text.strip()
                        categories_elements.append({
                            'path': current_path,
                            'tag': element.tag,
                            'text': text_content,
                            'attributes': element.attrib
                        })
                        print(f"  Text element: {current_path} = '{text_content}'")
                    
                    # Process children
                    for child in element:
                        extract_text_elements(child, current_path)
                
                extract_text_elements(categories_node)
        else:
            print("No CATEGORIES section found. Extracting all text elements from XML...")
            
            # Extract all text elements from the entire XML
            def extract_all_text_elements(element, path=""):
                current_path = f"{path}/{element.tag}" if path else element.tag
                
                if element.text and element.text.strip():
                    text_content = element.text.strip()
                    categories_elements.append({
                        'path': current_path,
                        'tag': element.tag,
                        'text': text_content,
                        'attributes': element.attrib
                    })
                    print(f"  Text element: {current_path} = '{text_content}'")
                
                for child in element:
                    extract_all_text_elements(child, current_path)
            
            extract_all_text_elements(root)
        
        print(f"\nTotal text elements extracted: {len(categories_elements)}")
        
        # Now cross-reference with the three unique food items from spreadsheet analysis
        print("\n=== CROSS-REFERENCING WITH UNIQUE FOOD ITEMS ===")
        
        # From the previous analysis, the three unique food items are:
        unique_food_items = ['goat meat', 'mutton', 'turtle soup']
        print(f"Unique food items to search for: {unique_food_items}")
        
        # Search for these items in the XML text elements
        matches_found = []
        
        for food_item in unique_food_items:
            print(f"\n--- Searching for '{food_item}' ---")
            item_matches = []
            
            for element in categories_elements:
                text_lower = element['text'].lower()
                food_lower = food_item.lower()
                
                # Check for exact match
                if food_lower == text_lower:
                    item_matches.append({
                        'match_type': 'exact',
                        'element': element
                    })
                    print(f"  EXACT MATCH: {element['path']} = '{element['text']}'")
                
                # Check for partial match (contains)
                elif food_lower in text_lower or text_lower in food_lower:
                    item_matches.append({
                        'match_type': 'partial',
                        'element': element
                    })
                    print(f"  PARTIAL MATCH: {element['path']} = '{element['text']}'")
            
            if item_matches:
                matches_found.append({
                    'food_item': food_item,
                    'matches': item_matches
                })
                print(f"  Total matches for '{food_item}': {len(item_matches)}")
            else:
                print(f"  No matches found for '{food_item}'")
        
        # Determine which food item appears in XML categories
        print("\n=== FINAL ANALYSIS ===")
        
        if matches_found:
            print(f"Found matches for {len(matches_found)} food items:")
            
            for match_info in matches_found:
                food_item = match_info['food_item']
                matches = match_info['matches']
                
                print(f"\n'{food_item}' found in {len(matches)} XML elements:")
                for match in matches:
                    element = match['element']
                    print(f"  - {element['path']}: '{element['text']}' ({match['match_type']} match)")
                
                # If this food item has exact matches, it's a strong candidate
                exact_matches = [m for m in matches if m['match_type'] == 'exact']
                if exact_matches:
                    print(f"  *** '{food_item}' has {len(exact_matches)} exact match(es) in XML categories ***")
        else:
            print("No matches found for any of the unique food items in XML categories.")
        
        # Save analysis results
        xml_analysis = {
            'xml_file': xml_path,
            'file_size': file_size,
            'root_element': root.tag,
            'total_text_elements': len(categories_elements),
            'text_elements': categories_elements,
            'unique_food_items_searched': unique_food_items,
            'matches_found': matches_found
        }
        
        os.makedirs('workspace', exist_ok=True)
        with open('workspace/xml_categories_analysis.json', 'w') as f:
            json.dump(xml_analysis, f, indent=2)
        
        print(f"\nXML analysis saved to: workspace/xml_categories_analysis.json")
        
        # Summary
        print("\n=== SUMMARY ===")
        print(f"XML file parsed successfully: {xml_path}")
        print(f"Total text elements in categories: {len(categories_elements)}")
        print(f"Unique food items from spreadsheet: {unique_food_items}")
        print(f"Food items found in XML: {len(matches_found)}")
        
        if matches_found:
            print("\nFood items that appear in XML categories:")
            for match_info in matches_found:
                food_item = match_info['food_item']
                exact_count = len([m for m in match_info['matches'] if m['match_type'] == 'exact'])
                partial_count = len([m for m in match_info['matches'] if m['match_type'] == 'partial'])
                print(f"  - '{food_item}': {exact_count} exact, {partial_count} partial matches")
        
    except ET.ParseError as e:
        print(f"Error parsing XML file: {e}")
    except Exception as e:
        print(f"Error processing XML file: {e}")
```