### Development Step 2: Download ‘A Dark Trace’ Open Access Book, Extract Chapter 2 to Find ‘Endopsychic Myths’ Influencer

**Description**: Access and download the full text of 'A Dark Trace: Sigmund Freud on the Sense of Guilt' by H. Westerink from Project MUSE using DOI 10.1353/book.24372. Since the book was confirmed to be open access, retrieve the complete text and save it to workspace/dark_trace_freud_book.pdf or appropriate format. Focus on locating and extracting Chapter 2 content to identify the author who influenced Freud's belief in 'endopsychic myths'. If the full book is not directly downloadable, extract Chapter 2 specifically or access the book's table of contents to determine the exact chapter title and content structure.

**Use Cases**:
- Digital humanities research project mapping Freud’s intellectual lineage by automatically retrieving “A Dark Trace: Sigmund Freud on the Sense of Guilt” via DOI and extracting Chapter 2 to identify Wilhelm Fliess’s influence on endopsychic myths.
- University library metadata automation system that scrapes Project MUSE via DOI to validate open access status, download the full-text PDF, extract the table of contents, and index Chapter 2 under psychoanalysis subject headings.
- Graduate student workflow for thesis preparation that uses a Python script to download the complete book from Project MUSE and isolate Chapter 2 content for direct quoting, annotation, and citation management in a dissertation on Freud’s sense of guilt.
- AI training data pipeline for natural language processing that harvests Chapter 2 passages from open access psychoanalytic texts to build a specialized corpus for modeling references to early psychological myth constructs.
- Institutional repository ingestion process where archivists automate DOI-based harvesting of open access monographs, save full PDFs, parse chapter structures, and tag Chapter 2 content for long-term preservation and public access.
- Publisher open access compliance checker that programmatically follows DOIs on Project MUSE, confirms Creative Commons licensing, validates PDF download links, and flags any access or licensing anomalies for titles like “A Dark Trace: Sigmund Freud on the Sense of Guilt.”
- Research information system generating a knowledge graph of psychoanalysis by retrieving monograph text, parsing the table of contents, extracting author references in Chapter 2, and creating entities and relationships representing Freud’s intellectual influences.
- E-learning content automation where an educational platform downloads open access chapters from Project MUSE, extracts illustrative examples from Chapter 2, and generates interactive quiz questions about scholars who shaped Freud’s theory of guilt.

```
import os
import requests
from bs4 import BeautifulSoup
import json
from urllib.parse import urljoin, urlparse
import time

print('=== ACCESSING PROJECT MUSE BOOK VIA DOI ===')
print('Title: A Dark Trace: Sigmund Freud on the Sense of Guilt')
print('Author: H. Westerink')
print('DOI: 10.1353/book.24372')
print('Source: Project MUSE\n')

# Construct the DOI URL
doi_url = 'https://doi.org/10.1353/book.24372'
print(f'DOI URL: {doi_url}')

# Headers to mimic a real browser request
headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
    'Accept-Language': 'en-US,en;q=0.5',
    'Accept-Encoding': 'gzip, deflate, br',
    'Connection': 'keep-alive',
    'Upgrade-Insecure-Requests': '1',
}

print('\n=== FOLLOWING DOI REDIRECT ===')

try:
    # Follow the DOI redirect to get the actual Project MUSE URL
    print('Making initial request to DOI...')
    doi_response = requests.get(doi_url, headers=headers, timeout=30, allow_redirects=True)
    print(f'Final URL after redirects: {doi_response.url}')
    print(f'Status code: {doi_response.status_code}')
    print(f'Content length: {len(doi_response.content):,} bytes')
    print(f'Content type: {doi_response.headers.get("Content-Type", "unknown")}')
    
    if doi_response.status_code == 200:
        # Parse the page to understand its structure
        soup = BeautifulSoup(doi_response.content, 'html.parser')
        
        # Get page title
        page_title = soup.find('title')
        if page_title:
            print(f'\nPage title: {page_title.get_text().strip()}')
        
        # Look for the book title on the page
        book_title_selectors = [
            'h1.title',
            'h1',
            '.book-title',
            '[data-title]',
            '.citation_title'
        ]
        
        book_title_found = None
        for selector in book_title_selectors:
            title_elem = soup.select_one(selector)
            if title_elem:
                title_text = title_elem.get_text().strip()
                if 'dark trace' in title_text.lower() or 'freud' in title_text.lower():
                    book_title_found = title_text
                    print(f'Book title found: {title_text}')
                    break
        
        if not book_title_found:
            print('Book title not immediately found, checking page content...')
        
        # Look for download links (PDF, full text access)
        download_links = []
        
        # Common selectors for download links on academic sites
        download_selectors = [
            'a[href*=".pdf"]',
            'a[href*="download"]',
            'a[href*="fulltext"]',
            '.pdf-link',
            '.download-link',
            '.full-text-link',
            '[data-download]',
            'a:contains("PDF")',
            'a:contains("Download")',
            'a:contains("Full Text")'
        ]
        
        for selector in download_selectors:
            links = soup.select(selector)
            for link in links:
                href = link.get('href')
                link_text = link.get_text().strip()
                if href:
                    # Convert relative URLs to absolute
                    if href.startswith('/'):
                        href = urljoin(doi_response.url, href)
                    download_links.append({
                        'url': href,
                        'text': link_text,
                        'selector': selector
                    })
        
        # Remove duplicates
        unique_downloads = []
        seen_urls = set()
        for link in download_links:
            if link['url'] not in seen_urls:
                seen_urls.add(link['url'])
                unique_downloads.append(link)
        
        print(f'\n=== DOWNLOAD LINKS ANALYSIS ===')
        print(f'Found {len(unique_downloads)} potential download links:')
        
        for i, link in enumerate(unique_downloads, 1):
            print(f'{i}. {link["text"]} -> {link["url"]}')
            print(f'   Selector: {link["selector"]}')
        
        # Look for table of contents or chapter information
        print(f'\n=== SEARCHING FOR TABLE OF CONTENTS ===')
        
        toc_selectors = [
            '.table-of-contents',
            '.toc',
            '.chapter-list',
            '.contents',
            '[id*="toc"]',
            '[class*="chapter"]'
        ]
        
        toc_found = False
        for selector in toc_selectors:
            toc_elem = soup.select_one(selector)
            if toc_elem:
                print(f'Table of contents found with selector: {selector}')
                toc_text = toc_elem.get_text().strip()
                print(f'TOC preview: {toc_text[:500]}...' if len(toc_text) > 500 else f'TOC: {toc_text}')
                toc_found = True
                break
        
        if not toc_found:
            # Search for chapter references in the text
            page_text = soup.get_text().lower()
            chapter_indicators = ['chapter 2', 'chapter two', 'ch. 2', 'ch 2']
            
            for indicator in chapter_indicators:
                if indicator in page_text:
                    print(f'Found reference to Chapter 2: "{indicator}"')
                    # Extract context around the chapter reference
                    index = page_text.find(indicator)
                    context_start = max(0, index - 100)
                    context_end = min(len(page_text), index + 200)
                    context = page_text[context_start:context_end]
                    print(f'Context: ...{context}...')
                    break
        
        # Check if this is an open access work
        open_access_indicators = ['open access', 'free access', 'freely available', 'cc license']
        is_open_access = any(indicator in soup.get_text().lower() for indicator in open_access_indicators)
        print(f'\nOpen access indicators found: {is_open_access}')
        
        # Try the most promising download link if available
        if unique_downloads:
            # Prioritize PDF links
            pdf_links = [link for link in unique_downloads if '.pdf' in link['url'].lower()]
            
            if pdf_links:
                target_link = pdf_links[0]
                print(f'\n=== ATTEMPTING PDF DOWNLOAD ===')
                print(f'Target: {target_link["text"]}')
                print(f'URL: {target_link["url"]}')
                
                try:
                    print('Downloading PDF...')
                    pdf_response = requests.get(target_link['url'], headers=headers, timeout=60)
                    
                    if pdf_response.status_code == 200:
                        content_type = pdf_response.headers.get('content-type', '').lower()
                        print(f'Content-Type: {content_type}')
                        print(f'Content-Length: {len(pdf_response.content):,} bytes')
                        
                        if 'pdf' in content_type or len(pdf_response.content) > 50000:
                            # Save the PDF
                            pdf_path = 'workspace/dark_trace_freud_book.pdf'
                            os.makedirs('workspace', exist_ok=True)
                            
                            with open(pdf_path, 'wb') as pdf_file:
                                pdf_file.write(pdf_response.content)
                            
                            file_size = os.path.getsize(pdf_path)
                            print(f'\n*** PDF SUCCESSFULLY DOWNLOADED ***')
                            print(f'Saved to: {pdf_path}')
                            print(f'File size: {file_size:,} bytes ({file_size/1024/1024:.2f} MB)')
                            
                        else:
                            print('Downloaded content does not appear to be a PDF')
                            print(f'Content preview: {pdf_response.text[:300]}...')
                    
                    else:
                        print(f'PDF download failed with status code: {pdf_response.status_code}')
                        print(f'Response: {pdf_response.text[:300]}...')
                
                except Exception as e:
                    print(f'Error downloading PDF: {str(e)}')
            
            else:
                # Try the first general download link
                target_link = unique_downloads[0]
                print(f'\n=== ATTEMPTING GENERAL DOWNLOAD ===')
                print(f'Target: {target_link["text"]}')
                print(f'URL: {target_link["url"]}')
                
                try:
                    download_response = requests.get(target_link['url'], headers=headers, timeout=60)
                    print(f'Download response status: {download_response.status_code}')
                    print(f'Content type: {download_response.headers.get("content-type", "unknown")}')
                    
                    if download_response.status_code == 200:
                        # Save the response for analysis
                        content_path = 'workspace/book_content_response.html'
                        with open(content_path, 'w', encoding='utf-8') as f:
                            f.write(download_response.text)
                        print(f'Content saved to: {content_path}')
                    
                except Exception as e:
                    print(f'Error with general download: {str(e)}')
        
        # Save page analysis results
        page_analysis = {
            'doi_url': doi_url,
            'final_url': doi_response.url,
            'page_title': page_title.get_text().strip() if page_title else None,
            'book_title_found': book_title_found,
            'download_links': unique_downloads,
            'is_open_access': is_open_access,
            'toc_found': toc_found,
            'content_length': len(doi_response.content),
            'analysis_timestamp': time.strftime('%Y-%m-%d %H:%M:%S')
        }
        
        analysis_file = 'workspace/project_muse_page_analysis.json'
        with open(analysis_file, 'w', encoding='utf-8') as f:
            json.dump(page_analysis, f, indent=2, ensure_ascii=False)
        
        print(f'\n=== ANALYSIS COMPLETE ===')
        print(f'✓ Page analysis saved to: {analysis_file}')
        print(f'✓ Found {len(unique_downloads)} download links')
        print(f'✓ Open access status: {is_open_access}')
        print(f'✓ Book title identified: {book_title_found is not None}')
        
    else:
        print(f'Failed to access DOI page: {doi_response.status_code}')
        print(f'Response: {doi_response.text[:500]}...')

except Exception as e:
    print(f'Error accessing DOI: {str(e)}')
    
    # Try alternative approaches
    print('\n=== TRYING DIRECT PROJECT MUSE SEARCH ===')
    
    # Try searching Project MUSE directly
    muse_search_url = 'https://muse.jhu.edu/search?action=search&query=creator%3A%22Westerink%2C%20H%22%20AND%20title%3A%22Dark%20Trace%22'
    print(f'Direct search URL: {muse_search_url}')
    
    try:
        search_response = requests.get(muse_search_url, headers=headers, timeout=30)
        print(f'Search response status: {search_response.status_code}')
        
        if search_response.status_code == 200:
            search_soup = BeautifulSoup(search_response.content, 'html.parser')
            
            # Look for the book in search results
            result_links = search_soup.find_all('a', href=True)
            book_links = []
            
            for link in result_links:
                href = link.get('href')
                text = link.get_text().strip()
                if href and ('dark' in text.lower() or 'freud' in text.lower() or 'westerink' in text.lower()):
                    if href.startswith('/'):
                        href = urljoin('https://muse.jhu.edu', href)
                    book_links.append({
                        'url': href,
                        'text': text
                    })
            
            print(f'Found {len(book_links)} potential book links:')
            for i, link in enumerate(book_links, 1):
                print(f'{i}. {link["text"]} -> {link["url"]}')
            
            # Save search results
            search_results = {
                'search_url': muse_search_url,
                'status_code': search_response.status_code,
                'book_links_found': book_links,
                'search_timestamp': time.strftime('%Y-%m-%d %H:%M:%S')
            }
            
            with open('workspace/project_muse_search_results.json', 'w', encoding='utf-8') as f:
                json.dump(search_results, f, indent=2, ensure_ascii=False)
            
            print('Search results saved to: workspace/project_muse_search_results.json')
    
    except Exception as search_error:
        print(f'Search attempt also failed: {str(search_error)}')

print('\n=== INITIAL ACCESS ATTEMPT COMPLETE ===')
print('Next steps: Analyze results and attempt targeted content extraction')
```