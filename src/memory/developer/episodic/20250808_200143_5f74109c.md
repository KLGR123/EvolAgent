### Development Step 2: Identifying Viral Animated Rooster and Hamster Musical Duets with Tempo and Lyric Variations

**Description**: Search for animated videos featuring a rooster and a hamster performing the same song at different tempos with different lyrics. Focus on identifying popular animated content, memes, or viral videos where these two animals perform musical numbers. Look for patterns in animated series, YouTube videos, or internet memes that feature both a rooster and hamster singing variations of the same composition.

**Use Cases**:
- Animation studio research for identifying viral animal character trends and musical content inspiration
- Meme curation and discovery for social media managers seeking unique animal duet videos to boost engagement
- Academic study on the evolution of animated musical tropes involving anthropomorphic animals across internet culture
- Automated content sourcing for childrenâ€™s educational platforms looking to license or feature animal-themed musical videos
- Digital marketing campaign analysis to track the popularity and spread of specific animated memes or musical parodies
- Entertainment journalists investigating the origins and variations of popular animated animal song performances
- Music educators compiling multimedia resources that showcase tempo and lyric variation in animated performances for classroom use
- Intellectual property teams monitoring web platforms for potential copyright infringements involving animated rooster and hamster musical content

```
import os
import requests
from bs4 import BeautifulSoup
import json
from datetime import datetime
import time
import urllib.parse
import re

print("=== REAL ANIMATED ROOSTER AND HAMSTER MUSICAL CONTENT SEARCH ===")
print("Objective: Find actual animated videos with rooster and hamster performing same song at different tempos/lyrics\n")

# Create workspace directory
workspace_dir = "workspace"
os.makedirs(workspace_dir, exist_ok=True)

# First, let's inspect any existing search results from previous simulation
print("=== STEP 1: INSPECTING PREVIOUS SEARCH SIMULATION RESULTS ===")

existing_files = []
for filename in os.listdir(workspace_dir):
    if os.path.isfile(os.path.join(workspace_dir, filename)):
        file_path = os.path.join(workspace_dir, filename)
        file_size = os.path.getsize(file_path)
        existing_files.append((filename, file_path, file_size))
        print(f"  - {filename} ({file_size / 1024:.1f} KB)")

# Check if we have previous simulation results
simulation_file = None
for filename, file_path, _ in existing_files:
    if 'rooster_hamster' in filename and filename.endswith('.json'):
        simulation_file = file_path
        break

if simulation_file:
    print(f"\n=== INSPECTING SIMULATION RESULTS STRUCTURE ===")
    print(f"Found simulation file: {os.path.basename(simulation_file)}")
    
    # First inspect the JSON structure
    with open(simulation_file, 'r') as f:
        try:
            sim_data = json.load(f)
            print(f"JSON loaded successfully with {len(sim_data)} top-level keys")
            print("Top-level keys:")
            for key, value in sim_data.items():
                if isinstance(value, dict):
                    print(f"  {key}: Dictionary with {len(value)} keys")
                elif isinstance(value, list):
                    print(f"  {key}: List with {len(value)} items")
                else:
                    print(f"  {key}: {type(value).__name__} - {str(value)[:50]}...")
                    
            # Extract search queries from simulation for real search
            search_queries = sim_data.get('search_queries', [])
            print(f"\nFound {len(search_queries)} search queries from simulation")
            
        except json.JSONDecodeError as e:
            print(f"Error loading JSON: {e}")
            sim_data = {}
else:
    print("\nNo previous simulation file found")
    sim_data = {}

print("\n=== STEP 2: IMPLEMENTING REAL WEB SEARCH ===")
print("Using actual web scraping to search for animated rooster and hamster content")

# Initialize real search results storage
real_search_results = {
    'search_timestamp': datetime.now().isoformat(),
    'objective': 'Find real animated rooster and hamster musical performances',
    'search_method': 'Web scraping and search engine queries',
    'search_queries': [],
    'search_results': [],
    'video_findings': [],
    'analysis_summary': {}
}

# Define focused search queries for real implementation
focused_queries = [
    "rooster hamster animated singing video",
    "rooster hamster cartoon music different tempo",
    "animated farm animals rooster hamster song",
    "viral rooster hamster singing meme",
    "rooster hamster duet animated video",
    "cartoon rooster hamster musical performance"
]

print(f"\nPrepared {len(focused_queries)} focused search queries:")
for i, query in enumerate(focused_queries, 1):
    print(f"  {i}. '{query}'")

real_search_results['search_queries'] = focused_queries

# Function to search DuckDuckGo (no API key required)
def search_duckduckgo(query, max_results=10):
    """Search DuckDuckGo for the given query"""
    print(f"\n  Searching DuckDuckGo for: '{query}'")
    
    try:
        # DuckDuckGo search URL
        search_url = f"https://duckduckgo.com/html/?q={urllib.parse.quote(query)}"
        
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
        
        response = requests.get(search_url, headers=headers, timeout=10)
        response.raise_for_status()
        
        soup = BeautifulSoup(response.content, 'html.parser')
        
        # Find search result links
        results = []
        result_links = soup.find_all('a', class_='result__a')
        
        for link in result_links[:max_results]:
            title = link.get_text(strip=True)
            url = link.get('href', '')
            
            # Get snippet from nearby elements
            snippet = ''
            result_div = link.find_parent('div', class_='result')
            if result_div:
                snippet_elem = result_div.find('a', class_='result__snippet')
                if snippet_elem:
                    snippet = snippet_elem.get_text(strip=True)
            
            if title and url:
                # Calculate relevance score based on keywords
                relevance = calculate_relevance(title, snippet, query)
                
                results.append({
                    'title': title,
                    'url': url,
                    'snippet': snippet,
                    'relevance_score': relevance,
                    'query': query
                })
        
        print(f"    Found {len(results)} results")
        return results
        
    except requests.RequestException as e:
        print(f"    Error searching DuckDuckGo: {e}")
        return []
    except Exception as e:
        print(f"    Unexpected error: {e}")
        return []

def calculate_relevance(title, snippet, query):
    """Calculate relevance score based on keyword matching"""
    text = (title + ' ' + snippet).lower()
    query_words = query.lower().split()
    
    score = 0
    
    # Key terms that indicate our target content
    high_value_terms = ['rooster', 'hamster', 'animated', 'cartoon', 'singing', 'music', 'song', 'tempo', 'different', 'lyrics']
    medium_value_terms = ['video', 'viral', 'meme', 'farm', 'animal', 'performance', 'duet']
    
    # Score based on presence of key terms
    for term in high_value_terms:
        if term in text:
            score += 0.15
    
    for term in medium_value_terms:
        if term in text:
            score += 0.05
    
    # Bonus for having both 'rooster' and 'hamster'
    if 'rooster' in text and 'hamster' in text:
        score += 0.3
    
    # Bonus for musical terms
    musical_terms = ['singing', 'song', 'music', 'tempo', 'lyrics', 'duet']
    music_count = sum(1 for term in musical_terms if term in text)
    score += music_count * 0.1
    
    # Bonus for animation terms
    animation_terms = ['animated', 'cartoon', 'animation']
    animation_count = sum(1 for term in animation_terms if term in text)
    score += animation_count * 0.1
    
    return min(score, 1.0)  # Cap at 1.0

print("\n=== STEP 3: PERFORMING REAL SEARCHES ===")

all_results = []
for query in focused_queries:
    results = search_duckduckgo(query, max_results=8)
    all_results.extend(results)
    time.sleep(2)  # Be respectful to the search engine

print(f"\nTotal search results collected: {len(all_results)}")

# Remove duplicates based on URL
seen_urls = set()
unique_results = []
for result in all_results:
    if result['url'] not in seen_urls:
        seen_urls.add(result['url'])
        unique_results.append(result)

print(f"Unique results after deduplication: {len(unique_results)}")

# Sort by relevance score
unique_results.sort(key=lambda x: x['relevance_score'], reverse=True)

real_search_results['search_results'] = unique_results

print("\n=== STEP 4: ANALYZING HIGH-RELEVANCE RESULTS ===")

# Filter for high-relevance results
high_relevance_threshold = 0.4
high_relevance_results = [r for r in unique_results if r['relevance_score'] >= high_relevance_threshold]

print(f"\nHigh-relevance results (score >= {high_relevance_threshold}): {len(high_relevance_results)}")

for i, result in enumerate(high_relevance_results[:10], 1):  # Show top 10
    print(f"\n{i}. {result['title']}")
    print(f"   URL: {result['url'][:80]}..." if len(result['url']) > 80 else f"   URL: {result['url']}")
    print(f"   Relevance: {result['relevance_score']:.2f}")
    print(f"   Query: '{result['query']}'")
    if result['snippet']:
        snippet_preview = result['snippet'][:150] + "..." if len(result['snippet']) > 150 else result['snippet']
        print(f"   Snippet: {snippet_preview}")
    else:
        print(f"   Snippet: No description available")

print("\n=== STEP 5: IDENTIFYING VIDEO CONTENT ===")

# Look for video-related results
video_indicators = ['youtube.com', 'vimeo.com', 'video', 'watch', 'animated', 'cartoon']
video_results = []

for result in high_relevance_results:
    is_video = False
    video_score = 0
    
    # Check URL for video platforms
    url_lower = result['url'].lower()
    if any(indicator in url_lower for indicator in ['youtube.com', 'youtu.be', 'vimeo.com']):
        is_video = True
        video_score += 0.5
    
    # Check title and snippet for video indicators
    text_content = (result['title'] + ' ' + result['snippet']).lower()
    for indicator in video_indicators:
        if indicator in text_content:
            video_score += 0.1
    
    if video_score > 0.3 or is_video:
        video_info = {
            'title': result['title'],
            'url': result['url'],
            'snippet': result['snippet'],
            'relevance_score': result['relevance_score'],
            'video_score': video_score,
            'is_likely_video': is_video,
            'query': result['query']
        }
        video_results.append(video_info)

print(f"\nIdentified {len(video_results)} potential video results:")

for i, video in enumerate(video_results[:5], 1):  # Show top 5 video results
    print(f"\n{i}. {video['title']}")
    print(f"   URL: {video['url'][:80]}..." if len(video['url']) > 80 else f"   URL: {video['url']}")
    print(f"   Relevance: {video['relevance_score']:.2f}")
    print(f"   Video Score: {video['video_score']:.2f}")
    print(f"   Likely Video: {'Yes' if video['is_likely_video'] else 'Maybe'}")
    if video['snippet']:
        print(f"   Description: {video['snippet'][:120]}..." if len(video['snippet']) > 120 else f"   Description: {video['snippet']}")

real_search_results['video_findings'] = video_results

print("\n=== STEP 6: CONTENT ANALYSIS AND PATTERN DETECTION ===")

# Analyze patterns in the found content
patterns = {
    'common_keywords': {},
    'video_platforms': {},
    'content_types': [],
    'musical_elements': []
}

# Count keyword occurrences
all_text = ' '.join([r['title'] + ' ' + r['snippet'] for r in high_relevance_results]).lower()
keywords = ['rooster', 'hamster', 'animated', 'cartoon', 'singing', 'music', 'song', 'video', 'viral', 'meme', 'tempo', 'lyrics']

for keyword in keywords:
    count = all_text.count(keyword)
    if count > 0:
        patterns['common_keywords'][keyword] = count

# Analyze video platforms
for result in video_results:
    url_lower = result['url'].lower()
    if 'youtube' in url_lower:
        patterns['video_platforms']['YouTube'] = patterns['video_platforms'].get('YouTube', 0) + 1
    elif 'vimeo' in url_lower:
        patterns['video_platforms']['Vimeo'] = patterns['video_platforms'].get('Vimeo', 0) + 1
    else:
        patterns['video_platforms']['Other'] = patterns['video_platforms'].get('Other', 0) + 1

print("\nContent Analysis Results:")
print(f"Keyword frequencies:")
for keyword, count in sorted(patterns['common_keywords'].items(), key=lambda x: x[1], reverse=True):
    print(f"  {keyword}: {count} occurrences")

print(f"\nVideo platforms:")
for platform, count in patterns['video_platforms'].items():
    print(f"  {platform}: {count} results")

# Create analysis summary
analysis_summary = {
    'total_searches_performed': len(focused_queries),
    'total_results_found': len(all_results),
    'unique_results': len(unique_results),
    'high_relevance_results': len(high_relevance_results),
    'video_results_identified': len(video_results),
    'top_result': high_relevance_results[0] if high_relevance_results else None,
    'search_effectiveness': 'High' if len(high_relevance_results) > 5 else 'Moderate' if len(high_relevance_results) > 2 else 'Low',
    'patterns_found': patterns
}

real_search_results['analysis_summary'] = analysis_summary

print(f"\n=== STEP 7: SEARCH EFFECTIVENESS ANALYSIS ===")
print(f"Real Search Performance Metrics:")
print(f"  Search queries executed: {analysis_summary['total_searches_performed']}")
print(f"  Total results found: {analysis_summary['total_results_found']}")
print(f"  Unique results: {analysis_summary['unique_results']}")
print(f"  High-relevance results: {analysis_summary['high_relevance_results']}")
print(f"  Video content identified: {analysis_summary['video_results_identified']}")
print(f"  Search effectiveness: {analysis_summary['search_effectiveness']}")

if analysis_summary['top_result']:
    top_result = analysis_summary['top_result']
    print(f"\n*** TOP RESULT ***")
    print(f"Title: {top_result['title']}")
    print(f"URL: {top_result['url']}")
    print(f"Relevance Score: {top_result['relevance_score']:.2f}")
    if top_result['snippet']:
        print(f"Description: {top_result['snippet'][:200]}..." if len(top_result['snippet']) > 200 else f"Description: {top_result['snippet']}")

print(f"\n=== STEP 8: SAVING REAL SEARCH RESULTS ===")

# Save comprehensive real search results
results_file = os.path.join(workspace_dir, 'real_rooster_hamster_search_results.json')
with open(results_file, 'w') as f:
    json.dump(real_search_results, f, indent=2)

print(f"Real search results saved to: {os.path.basename(results_file)}")

# Create detailed findings report
findings_report = f"""REAL ANIMATED ROOSTER AND HAMSTER MUSICAL CONTENT SEARCH REPORT
================================================================

SEARCH OBJECTIVE:
Find actual animated videos featuring a rooster and hamster performing the same song at different tempos with different lyrics.

SEARCH METHOD:
Real web scraping using DuckDuckGo search engine with {len(focused_queries)} targeted queries.

KEY FINDINGS:
- {len(high_relevance_results)} high-relevance results identified (score >= {high_relevance_threshold})
- {len(video_results)} potential video content results found
- Search effectiveness: {analysis_summary['search_effectiveness']}
- Most common keywords: {', '.join([k for k, v in sorted(patterns['common_keywords'].items(), key=lambda x: x[1], reverse=True)[:5]])}

TOP SEARCH RESULTS:
"""

for i, result in enumerate(high_relevance_results[:5], 1):
    findings_report += f"""
{i}. {result['title']}
   URL: {result['url']}
   Relevance Score: {result['relevance_score']:.2f}
   Search Query: '{result['query']}'
   Description: {result['snippet'][:150] + '...' if len(result['snippet']) > 150 else result['snippet']}
"""

if video_results:
    findings_report += f"""

VIDEO CONTENT IDENTIFIED:
{len(video_results)} potential video results found:
"""
    
    for i, video in enumerate(video_results[:3], 1):
        findings_report += f"""
{i}. {video['title']}
   URL: {video['url']}
   Video Likelihood: {'High' if video['is_likely_video'] else 'Medium'}
   Relevance: {video['relevance_score']:.2f}
"""

findings_report += f"""

SEARCH ANALYSIS:
- Keyword Analysis: Found {len(patterns['common_keywords'])} relevant keywords across results
- Video Platforms: {', '.join([f"{k}: {v}" for k, v in patterns['video_platforms'].items()])}
- Content Quality: {'High-quality matches found' if len(high_relevance_results) > 3 else 'Limited matches found'}

RECOMMENDATIONS:
1. Investigate top-scoring video results for actual animated content
2. Follow up on YouTube links for potential rooster-hamster musical videos
3. Check animation and meme-related results for viral content
4. Consider expanding search to include specific animation studios or series

Search completed: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Total execution time: Approximately {len(focused_queries) * 2} seconds (with respectful delays)
"""

findings_file = os.path.join(workspace_dir, 'real_search_findings_report.txt')
with open(findings_file, 'w') as f:
    f.write(findings_report)

print(f"Detailed findings report saved to: {os.path.basename(findings_file)}")

print(f"\n=== REAL SEARCH COMPLETE ===")
print(f"\n*** FINAL RESULTS SUMMARY ***")

if high_relevance_results:
    print(f"Successfully found {len(high_relevance_results)} high-relevance results for animated rooster and hamster content.")
    print(f"Identified {len(video_results)} potential video results that may contain the target content.")
    
    if analysis_summary['top_result']:
        top = analysis_summary['top_result']
        print(f"\nTop result: '{top['title']}' (Score: {top['relevance_score']:.2f})")
        print(f"URL: {top['url']}")
    
    print(f"\nThis real search provides actual web results that can be investigated further")
    print(f"for genuine animated rooster and hamster musical content.")
else:
    print("No high-relevance results found. The specific content may be rare or")
    print("may require more specialized search terms or platforms.")

print(f"\nFiles created in workspace/:")
for filename in os.listdir(workspace_dir):
    filepath = os.path.join(workspace_dir, filename)
    if os.path.isfile(filepath):
        size_kb = os.path.getsize(filepath) / 1024
        print(f"  - {filename} ({size_kb:.1f} KB)")

print(f"\n*** REAL ANIMATED ROOSTER AND HAMSTER SEARCH COMPLETED ***")
```