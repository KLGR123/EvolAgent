### Development Step 3: Newton’s Method for f(x)=x³+4x²−3x+8 from x₀=−5 to Four-Decimal Convergence

**Description**: Implement Newton's Method for the function f(x) = x³ + 4x² - 3x + 8 starting with x₀ = -5. Calculate the derivative f'(x) = 3x² + 8x - 3 and apply the iterative formula xₙ₊₁ = xₙ - f(xₙ)/f'(xₙ). Continue iterations until finding the smallest n where xₙ = xₙ₊₁ when both values are rounded to four decimal places. Track each iteration's values and identify when convergence occurs at the specified precision level.

**Use Cases**:
- Calibrating a non-linear sensor response in aerospace instrumentation by finding the root of its cubic output polynomial, while logging each Newton iteration for quality assurance and traceability
- Determining the break-even point in a manufacturing cost-revenue model represented by a cubic equation, with detailed iteration tracking to support accurate financial forecasting
- Solving equilibrium concentrations in a chemical reaction kinetics model defined by a cubic polynomial, automating convergence checks and saving iterations for regulatory lab reports
- Computing load-deflection roots in mechanical beam analysis using Newton’s Method, integrating the process into structural design software and archiving results for engineering audits
- Locating the market equilibrium price in an economic supply-demand cubic model, with automated convergence verification and result reporting for macroeconomic policy simulations
- Implementing a real-time root-finding module in robotics control to solve cubic motion-planning equations, including iteration logs for debugging and safety certification
- Demonstrating numerical methods in a university course by applying Newton’s Method to a cubic function, providing students with full iteration outputs and convergence analysis
- Performing stability analysis in power system engineering by finding roots of the system’s characteristic cubic polynomial, with automated logging and file-based reporting for validation and compliance

```
# Newton's Method Implementation - Fixed File Writing Issue
# Complete implementation with proper file handling

import math

# Define the function f(x) = x³ + 4x² - 3x + 8
def f(x):
    """Calculate f(x) = x³ + 4x² - 3x + 8"""
    return x**3 + 4*x**2 - 3*x + 8

# Define the derivative f'(x) = 3x² + 8x - 3
def f_prime(x):
    """Calculate f'(x) = 3x² + 8x - 3"""
    return 3*x**2 + 8*x - 3

print("=== NEWTON'S METHOD IMPLEMENTATION ===")
print("Function: f(x) = x³ + 4x² - 3x + 8")
print("Derivative: f'(x) = 3x² + 8x - 3")
print("Starting point: x₀ = -5")
print("Convergence criteria: x_n = x_(n+1) when rounded to 4 decimal places")
print()

# Initialize variables
x0 = -5
x_current = x0
n = 0
iterations = []

print("Iteration Progress:")
print("n\tx_n\t\t\tf(x_n)\t\t\tf'(x_n)\t\t\tx_(n+1)\t\t\tRounded x_n\tRounded x_(n+1)\tConverged?")
print("-" * 130)

# Newton's Method iterations
while True:
    # Calculate function value and derivative at current point
    fx = f(x_current)
    fpx = f_prime(x_current)
    
    print(f"Step {n}: Evaluating at x = {x_current:.8f}")
    print(f"  f({x_current:.8f}) = {fx:.8f}")
    print(f"  f'({x_current:.8f}) = {fpx:.8f}")
    
    # Check if derivative is zero (would cause division by zero)
    if abs(fpx) < 1e-15:
        print(f"\nError: Derivative is nearly zero at x = {x_current}")
        print("Newton's method cannot continue from this point")
        break
    
    # Calculate next iteration using Newton's formula: x_(n+1) = x_n - f(x_n)/f'(x_n)
    x_next = x_current - fx / fpx
    print(f"  Newton's formula: x_{n+1} = {x_current:.8f} - ({fx:.8f})/({fpx:.8f}) = {x_next:.8f}")
    
    # Round both values to 4 decimal places for convergence check
    x_current_rounded = round(x_current, 4)
    x_next_rounded = round(x_next, 4)
    
    print(f"  Rounded values: x_{n} = {x_current_rounded:.4f}, x_{n+1} = {x_next_rounded:.4f}")
    
    # Store iteration data
    iteration_data = {
        'n': n,
        'x_n': x_current,
        'f_x_n': fx,
        'f_prime_x_n': fpx,
        'x_n_plus_1': x_next,
        'x_n_rounded': x_current_rounded,
        'x_n_plus_1_rounded': x_next_rounded,
        'converged': x_current_rounded == x_next_rounded
    }
    iterations.append(iteration_data)
    
    # Display iteration in table format
    converged_status = "YES" if x_current_rounded == x_next_rounded else "NO"
    print(f"{n}\t{x_current:.10f}\t{fx:.10f}\t{fpx:.10f}\t{x_next:.10f}\t{x_current_rounded:.4f}\t\t{x_next_rounded:.4f}\t\t{converged_status}")
    
    # Check convergence: x_n = x_(n+1) when rounded to 4 decimal places
    if x_current_rounded == x_next_rounded:
        print(f"\n*** CONVERGENCE ACHIEVED AT STEP n = {n} ***")
        print(f"x_{n} rounded to 4 decimal places: {x_current_rounded:.4f}")
        print(f"x_{n+1} rounded to 4 decimal places: {x_next_rounded:.4f}")
        print(f"Since {x_current_rounded:.4f} = {x_next_rounded:.4f}, convergence is achieved.")
        print(f"\nThe smallest n where x_n = x_(n+1) when rounded to 4 decimal places is: n = {n}")
        
        convergence_step = n
        final_x = x_current_rounded
        break
    
    # Move to next iteration
    x_current = x_next
    n += 1
    print(f"  Moving to next iteration: x_{n} = {x_current:.8f}")
    print()
    
    # Safety check to prevent infinite loops
    if n > 50:
        print(f"\nWarning: Maximum iterations (50) reached without convergence")
        convergence_step = None
        final_x = None
        break

print(f"\n=== DETAILED ANALYSIS ===")
print(f"Total iterations performed: {len(iterations)}")
print(f"Starting point: x₀ = {x0}")

if convergence_step is not None:
    print(f"Convergence achieved at step: n = {convergence_step}")
    print(f"Final convergent value: x = {final_x:.4f}")
    
    # Verify this is indeed close to a root by checking f(x)
    final_fx = f(final_x)
    print(f"\nVerification: f({final_x:.4f}) = {final_fx:.8f}")
    
    if abs(final_fx) < 0.1:
        print(f"✓ This is a good approximation of a root (f(x) ≈ 0)")
    else:
        print(f"⚠ This may not be exactly a root, but it's where the method converged")
    
    # Show the progression of values
    print(f"\n=== CONVERGENCE PROGRESSION ===")
    print("Step\tx_n (full precision)\t\tx_n (rounded)\tDifference from previous")
    print("-" * 80)
    
    for i, iteration in enumerate(iterations):
        if i == 0:
            diff = "N/A (initial)"
        else:
            diff = f"{abs(iteration['x_n_rounded'] - iterations[i-1]['x_n_rounded']):.4f}"
        
        print(f"{iteration['n']}\t{iteration['x_n']:.12f}\t{iteration['x_n_rounded']:.4f}\t\t{diff}")
        
        if iteration['converged']:
            print(f"\t*** CONVERGENCE: x_{iteration['n']} = x_{iteration['n']+1} = {iteration['x_n_rounded']:.4f} ***")
            break
else:
    print("Convergence was not achieved within the iteration limit")

# Save detailed results to workspace - FIXED FILE WRITING
print(f"\n=== SAVING RESULTS ===")

try:
    with open('workspace/newtons_method_final_results.txt', 'w') as output_file:
        output_file.write("Newton's Method - Complete Results\n")
        output_file.write("=" * 50 + "\n\n")
        output_file.write(f"Function: f(x) = x³ + 4x² - 3x + 8\n")
        output_file.write(f"Derivative: f'(x) = 3x² + 8x - 3\n")
        output_file.write(f"Starting point: x₀ = {x0}\n")
        output_file.write(f"Convergence criteria: x_n = x_(n+1) when rounded to 4 decimal places\n\n")
        
        if convergence_step is not None:
            output_file.write(f"FINAL RESULT: Convergence achieved at step n = {convergence_step}\n")
            output_file.write(f"Answer: The smallest n where x_n = x_(n+1) when rounded to 4 decimal places is n = {convergence_step}\n")
            output_file.write(f"Convergent value: x = {final_x:.4f}\n")
            output_file.write(f"Verification: f({final_x:.4f}) = {f(final_x):.8f}\n\n")
        else:
            output_file.write("RESULT: Convergence not achieved within iteration limit\n\n")
        
        output_file.write("Detailed Iteration Log:\n")
        output_file.write("n\tx_n\t\t\t\tf(x_n)\t\t\t\tf'(x_n)\t\t\t\tx_(n+1)\t\t\t\tRounded x_n\tRounded x_(n+1)\tConverged\n")
        output_file.write("-" * 150 + "\n")
        
        for iteration in iterations:
            output_file.write(f"{iteration['n']}\t{iteration['x_n']:.12f}\t{iteration['f_x_n']:.12f}\t{iteration['f_prime_x_n']:.12f}\t{iteration['x_n_plus_1']:.12f}\t{iteration['x_n_rounded']:.4f}\t\t{iteration['x_n_plus_1_rounded']:.4f}\t\t{'YES' if iteration['converged'] else 'NO'}\n")
            
            if iteration['converged']:
                output_file.write(f"\n*** CONVERGENCE ACHIEVED AT STEP n = {iteration['n']} ***\n")
                break
        
        output_file.write("\nStep-by-step Newton's Formula Applications:\n")
        output_file.write("-" * 50 + "\n")
        for iteration in iterations:
            n_val = iteration['n']
            x_n = iteration['x_n']
            f_x_n = iteration['f_x_n']
            f_prime_x_n = iteration['f_prime_x_n']
            x_n_plus_1 = iteration['x_n_plus_1']
            
            output_file.write(f"Step {n_val}:\n")
            output_file.write(f"  x_{n_val} = {x_n:.8f}\n")
            output_file.write(f"  f(x_{n_val}) = {f_x_n:.8f}\n")
            output_file.write(f"  f'(x_{n_val}) = {f_prime_x_n:.8f}\n")
            output_file.write(f"  x_{n_val+1} = x_{n_val} - f(x_{n_val})/f'(x_{n_val}) = {x_n:.8f} - ({f_x_n:.8f})/({f_prime_x_n:.8f}) = {x_n_plus_1:.8f}\n")
            output_file.write(f"  Rounded: x_{n_val} = {iteration['x_n_rounded']:.4f}, x_{n_val+1} = {iteration['x_n_plus_1_rounded']:.4f}\n")
            
            if iteration['converged']:
                output_file.write(f"  *** CONVERGENCE: {iteration['x_n_rounded']:.4f} = {iteration['x_n_plus_1_rounded']:.4f} ***\n")
                break
            output_file.write("\n")
    
    print(f"✓ Results successfully saved to: workspace/newtons_method_final_results.txt")
    
except Exception as e:
    print(f"Error saving file: {e}")
    print("Results computed successfully but file saving failed")

# Final summary with clear answer
print(f"\n=== FINAL ANSWER ===")
if convergence_step is not None:
    print(f"SUCCESS: Newton's Method converged successfully!")
    print(f"\nAnswer to the question:")
    print(f"The smallest n where x_n = x_(n+1) when both values are rounded to 4 decimal places is: n = {convergence_step}")
    print(f"\nDetails:")
    print(f"- Starting point: x₀ = -5")
    print(f"- Function: f(x) = x³ + 4x² - 3x + 8")
    print(f"- Derivative: f'(x) = 3x² + 8x - 3")
    print(f"- Convergence occurred at step n = {convergence_step}")
    print(f"- At this step: x_{convergence_step} = x_{convergence_step+1} = {final_x:.4f}")
    print(f"- Verification: f({final_x:.4f}) = {f(final_x):.8f} ≈ 0")
    print(f"\n*** The answer is n = {convergence_step} ***")
else:
    print("Convergence was not achieved - method may need different starting point or more iterations")

print(f"\nNewton's Method execution completed successfully!")
```