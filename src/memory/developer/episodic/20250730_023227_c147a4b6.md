### Development Step 7: Extract internal LOTR Wikipedia links (July 3, 2023) toward 'A Song of Ice and Fire'

**Description**: Access the archived Wikipedia page for 'The Lord of the Rings' (book) as it appeared at the end of July 3, 2023. Use the Wayback Machine or Wikipedia's revision history to retrieve the specific version from that date. Extract all outbound links from the page content, focusing on internal Wikipedia links that could potentially lead toward 'A Song of Ice and Fire'. Create a comprehensive list of linked pages including literature, fantasy, author, publisher, and genre-related links that might serve as stepping stones in the path-finding process.

**Use Cases**:
- Comparative literature research in academia: retrieve the July 3, 2023 snapshot of “The Lord of the Rings” Wikipedia to map links toward “A Song of Ice and Fire,” enabling scholars to analyze thematic influences and authorial networks between epic fantasy sagas.
- Digital humanities project for narrative evolution: extract and categorize internal links from archived medieval literature pages to build a temporal knowledge graph visualizing genre trends, myth motifs, and author collaborations across Wikipedia revisions.
- SEO and competitive intelligence for publishing houses: access historical versions of book and author Wikipedia entries to extract outbound link profiles, track competitor backlink strategies, and inform marketing teams on evolving partnership and citation opportunities.
- Fact-checking and content audit for journalism: automate retrieval of archived wiki revisions to verify changes in author credits, publisher associations, and award mentions on high-profile literary pages, ensuring accurate reporting of publication histories.
- Semantic web and recommendation engine enrichment: harvest categorized internal Wikipedia links from archived fantasy articles to populate a time-aware ontology of authors, genres, and characters, powering AI-driven book recommendation systems.
- Legal and intellectual property due diligence: compile a comprehensive list of publisher, author, and award links from archived literary wiki snapshots to reconstruct citation trails and support negotiations in copyright and licensing agreements.
- Digital library metadata enhancement: integrate extracted character, place, and genre link data from a July 2023 snapshot of “The Lord of the Rings” into catalog records, improving thematic search, discovery, and user engagement for fantasy collections.

```
import os
import requests
from bs4 import BeautifulSoup
import json
from datetime import datetime
import time
from urllib.parse import urljoin, unquote

print("=== ACCESSING ARCHIVED WIKIPEDIA PAGE: THE LORD OF THE RINGS (JULY 3, 2023) ===")
print("Objective: Retrieve archived version and extract all outbound links\n")

# Create workspace directory
workspace_dir = f"workspace_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
os.makedirs(workspace_dir, exist_ok=True)
print(f"Created workspace directory: {workspace_dir}\n")

# Define the target page and date
url = "https://en.wikipedia.org/wiki/The_Lord_of_the_Rings"
archive_date = "20230703"  # July 3, 2023

print(f"Target URL: {url}")
print(f"Target date: July 3, 2023 ({archive_date})\n")

# Check if archived version is available in Wayback Machine
print("=== CHECKING WAYBACK MACHINE AVAILABILITY ===")
api_url = f"https://archive.org/wayback/available?url={url}&timestamp={archive_date}"

headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
}

try:
    print(f"Checking availability: {api_url}")
    avail_response = requests.get(api_url, headers=headers, timeout=30)
    
    if avail_response.status_code == 200:
        avail_data = avail_response.json()
        print(f"API Response status: {avail_response.status_code}")
        print(f"Response data keys: {list(avail_data.keys()) if avail_data else 'No data'}")
        
        if "archived_snapshots" in avail_data and "closest" in avail_data["archived_snapshots"]:
            closest = avail_data["archived_snapshots"]["closest"]
            print(f"Closest snapshot found: {closest.get('available', 'Unknown status')}")
            
            if closest.get("available"):
                archive_url = closest["url"]
                archive_timestamp = closest["timestamp"]
                
                # Format the timestamp for display
                formatted_date = f"{archive_timestamp[:4]}-{archive_timestamp[4:6]}-{archive_timestamp[6:8]} {archive_timestamp[8:10]}:{archive_timestamp[10:12]}:{archive_timestamp[12:14]}"
                
                print(f"\n✅ Archive found!")
                print(f"Archive URL: {archive_url}")
                print(f"Archive timestamp: {archive_timestamp}")
                print(f"Formatted date: {formatted_date}")
            else:
                print(f"\n❌ No archived version available for {url} on {archive_date}")
                exit()
        else:
            print(f"\n❌ No archived snapshots found for {url}")
            exit()
    else:
        print(f"❌ Error checking archive availability: HTTP {avail_response.status_code}")
        exit()
        
except Exception as e:
    print(f"❌ Error accessing Wayback Machine API: {str(e)}")
    exit()

# Retrieve the archived page
print(f"\n=== RETRIEVING ARCHIVED PAGE ===")
print(f"Fetching: {archive_url}")

try:
    response = requests.get(archive_url, headers=headers, timeout=60)
    
    if response.status_code == 200:
        print(f"✅ Successfully retrieved archived page")
        print(f"Content length: {len(response.content):,} bytes")
        print(f"Content type: {response.headers.get('content-type', 'Unknown')}")
    else:
        print(f"❌ Failed to retrieve archived page: HTTP {response.status_code}")
        exit()
        
except Exception as e:
    print(f"❌ Error retrieving archived page: {str(e)}")
    exit()

# Parse the HTML content
print(f"\n=== PARSING HTML CONTENT ===")
soup = BeautifulSoup(response.content, 'html.parser')

# Get page title
title_element = soup.find('title')
page_title = title_element.get_text().strip() if title_element else 'Unknown'
print(f"Page title: {page_title}")

# Find the main content area (avoiding Wayback Machine navigation)
main_content = soup.find('div', {'id': 'mw-content-text'})
if not main_content:
    # Alternative selectors for content
    main_content = soup.find('div', {'class': 'mw-parser-output'})
if not main_content:
    main_content = soup.find('div', {'id': 'bodyContent'})
if not main_content:
    print("⚠️ Could not find main content div, using entire body")
    main_content = soup

print(f"Main content area identified: {main_content.name if hasattr(main_content, 'name') else 'Unknown'}")

# Extract all outbound links
print(f"\n=== EXTRACTING OUTBOUND LINKS ===")

all_links = []
internal_wikipedia_links = []
external_links = []
other_links = []

# Find all anchor tags with href attributes
for link_element in main_content.find_all('a', href=True):
    href = link_element.get('href', '')
    link_text = link_element.get_text().strip()
    
    # Skip empty hrefs or just anchors
    if not href or href.startswith('#'):
        continue
    
    # Skip Wayback Machine specific links
    if 'web.archive.org' in href or 'archive.org' in href:
        continue
    
    # Categorize links
    if href.startswith('/wiki/'):
        # Internal Wikipedia link
        article_name = href.split('/')[-1]
        article_name = unquote(article_name).replace('_', ' ')
        
        # Filter out non-article pages
        skip_prefixes = ['File:', 'Category:', 'Template:', 'User:', 'Talk:', 'Wikipedia:', 'Help:', 'Portal:', 'Special:', 'Media:']
        if not any(article_name.startswith(prefix) for prefix in skip_prefixes):
            internal_wikipedia_links.append({
                'article_name': article_name,
                'link_text': link_text,
                'href': href,
                'type': 'internal_wikipedia'
            })
    
    elif href.startswith('http://') or href.startswith('https://'):
        # External link
        external_links.append({
            'url': href,
            'link_text': link_text,
            'type': 'external'
        })
    
    else:
        # Other types of links
        other_links.append({
            'href': href,
            'link_text': link_text,
            'type': 'other'
        })
    
    # Add to comprehensive list
    all_links.append({
        'href': href,
        'link_text': link_text,
        'article_name': unquote(href.split('/')[-1]).replace('_', ' ') if href.startswith('/wiki/') else None
    })

print(f"\n=== LINK EXTRACTION RESULTS ===")
print(f"Total links found: {len(all_links)}")
print(f"Internal Wikipedia links: {len(internal_wikipedia_links)}")
print(f"External links: {len(external_links)}")
print(f"Other links: {len(other_links)}")

# Categorize internal Wikipedia links by potential relevance
print(f"\n=== CATEGORIZING INTERNAL WIKIPEDIA LINKS ===")

# Define categories based on potential relevance to fantasy literature connections
categories = {
    'fantasy': [],
    'literature': [],
    'authors': [],
    'publishers': [],
    'awards': [],
    'genres': [],
    'tolkien_related': [],
    'characters': [],
    'places': [],
    'other': []
}

# Keywords for categorization
keywords = {
    'fantasy': ['fantasy', 'epic', 'myth', 'legend', 'saga', 'dragon', 'magic', 'wizard'],
    'literature': ['literature', 'novel', 'book', 'story', 'narrative', 'fiction', 'prose'],
    'authors': ['author', 'writer', 'poet', 'novelist', 'tolkien'],
    'publishers': ['publisher', 'publishing', 'press', 'books', 'edition'],
    'awards': ['award', 'prize', 'honor', 'recognition'],
    'genres': ['genre', 'adventure', 'heroic', 'medieval', 'ancient'],
    'tolkien_related': ['tolkien', 'middle', 'earth', 'hobbit', 'ring', 'shire', 'gondor'],
    'characters': ['frodo', 'gandalf', 'aragorn', 'legolas', 'gimli', 'boromir', 'sam', 'merry', 'pippin'],
    'places': ['shire', 'rohan', 'gondor', 'mordor', 'rivendell', 'isengard', 'minas']
}

for link in internal_wikipedia_links:
    article_name = link['article_name'].lower()
    categorized = False
    
    # Check each category
    for category, category_keywords in keywords.items():
        if any(keyword in article_name for keyword in category_keywords):
            categories[category].append(link)
            categorized = True
            break
    
    # If not categorized, put in 'other'
    if not categorized:
        categories['other'].append(link)

# Display categorization results
for category, links in categories.items():
    if links:  # Only show categories with links
        print(f"\n{category.upper()}: {len(links)} links")
        # Show first 5 examples
        for i, link in enumerate(links[:5], 1):
            print(f"  {i}. {link['article_name']}")
        if len(links) > 5:
            print(f"  ... and {len(links) - 5} more")

# Save comprehensive results
print(f"\n=== SAVING RESULTS TO WORKSPACE ===")

# Save the complete data
lotr_data = {
    'extraction_metadata': {
        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'source_url': url,
        'archive_date_requested': archive_date,
        'archive_url': archive_url,
        'archive_timestamp': archive_timestamp,
        'formatted_archive_date': formatted_date,
        'page_title': page_title
    },
    'link_statistics': {
        'total_links': len(all_links),
        'internal_wikipedia_links': len(internal_wikipedia_links),
        'external_links': len(external_links),
        'other_links': len(other_links)
    },
    'categorized_links': categories,
    'all_internal_wikipedia_links': internal_wikipedia_links,
    'external_links': external_links,
    'raw_html_saved': False
}

# Save main data file
data_file = os.path.join(workspace_dir, 'lotr_wikipedia_links_july_2023.json')
with open(data_file, 'w', encoding='utf-8') as f:
    json.dump(lotr_data, f, indent=2, ensure_ascii=False)

print(f"✅ Main data saved to: {os.path.basename(data_file)}")
print(f"   File size: {os.path.getsize(data_file):,} bytes")

# Save raw HTML for reference
html_file = os.path.join(workspace_dir, 'lotr_wikipedia_july_2023.html')
with open(html_file, 'w', encoding='utf-8') as f:
    f.write(response.text)

lotr_data['raw_html_saved'] = True
print(f"✅ Raw HTML saved to: {os.path.basename(html_file)}")
print(f"   File size: {os.path.getsize(html_file):,} bytes")

# Update the JSON with HTML info
with open(data_file, 'w', encoding='utf-8') as f:
    json.dump(lotr_data, f, indent=2, ensure_ascii=False)

# Create summary report
summary_file = os.path.join(workspace_dir, 'extraction_summary.txt')
with open(summary_file, 'w', encoding='utf-8') as f:
    f.write(f"THE LORD OF THE RINGS - WIKIPEDIA LINK EXTRACTION SUMMARY\n")
    f.write(f"={'='*60}\n\n")
    f.write(f"Archive Date: {formatted_date}\n")
    f.write(f"Source URL: {url}\n")
    f.write(f"Archive URL: {archive_url}\n")
    f.write(f"Extraction Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
    
    f.write(f"LINK STATISTICS:\n")
    f.write(f"- Total links found: {len(all_links)}\n")
    f.write(f"- Internal Wikipedia links: {len(internal_wikipedia_links)}\n")
    f.write(f"- External links: {len(external_links)}\n")
    f.write(f"- Other links: {len(other_links)}\n\n")
    
    f.write(f"CATEGORIZED INTERNAL LINKS:\n")
    for category, links in categories.items():
        if links:
            f.write(f"- {category.capitalize()}: {len(links)} links\n")
    
    f.write(f"\nHIGH-PRIORITY FANTASY/LITERATURE CONNECTIONS:\n")
    priority_categories = ['fantasy', 'literature', 'authors', 'genres']
    for category in priority_categories:
        if categories[category]:
            f.write(f"\n{category.upper()}:\n")
            for link in categories[category][:10]:  # First 10 in each category
                f.write(f"  - {link['article_name']}\n")

print(f"✅ Summary report saved to: {os.path.basename(summary_file)}")

print(f"\n=== EXTRACTION COMPLETE ===")
print(f"📊 Successfully extracted {len(internal_wikipedia_links)} internal Wikipedia links")
print(f"🎯 Identified {sum(len(links) for cat, links in categories.items() if cat in ['fantasy', 'literature', 'authors', 'genres'])} high-priority links")
print(f"📁 All data saved to workspace: {workspace_dir}")
print(f"🔍 Ready for path-finding analysis to 'A Song of Ice and Fire'")

# Quick preview of most promising links
print(f"\n=== MOST PROMISING LINKS FOR PATH-FINDING ===")
promising_links = []
for category in ['fantasy', 'literature', 'authors', 'awards']:
    promising_links.extend(categories[category][:3])  # Top 3 from each

if promising_links:
    print(f"Top {len(promising_links)} most promising connections:")
    for i, link in enumerate(promising_links, 1):
        print(f"  {i:2d}. {link['article_name']}")
else:
    print("⚠️ No high-priority fantasy/literature connections found")

print(f"\n✅ Archive extraction and link categorization completed successfully!")
```