### Development Step 7: Two-Step Move Graph BFS from Start to End to Extract 11th Move Cell’s Hex Color

**Description**: Construct adjacency graph of legal two-cell moves using workspace/grid_data.json and workspace/start_end_coordinates.json and perform a breadth-first search from the START cell to locate the shortest path to the END cell enforcing no immediate backtracking; identify the coordinate of the cell landed on after the 11th move along the resulting path; extract that cell’s 6-digit hex fill color from workspace/grid_data.json.

**Use Cases**:
- Warehouse AGV path optimization: plan two-cell hops along green-marked lanes to shuttle pallets, then read the 11th stop’s zone color to schedule a battery swap.
- Hospital autonomous wheelchair routing: traverse color-coded floor tiles with two-step moves, avoiding backtracking, and extract the 11th tile’s hex code to verify it’s a clean-zone surface.
- Firefighter VR training course layout: compute two-cell jumps through safe corridors in a building grid, then use the 11th move’s cell color to trigger a smoke-release simulation.
- Precision-agriculture drone flight planning: map 2×2-meter sampling jumps over healthy-crop plots, retrieve the 11th sampling block’s fill color for nutrient analysis alerts.
- Oil-refinery inspection robot routing: execute two-panel climbs on color-coded walkways, enforce no immediate backstep to maintain safety, and record the 11th panel’s coating color for corrosion monitoring.
- Mobile puzzle-game AI solver: calculate knight-style jumps on a hex-colored board, avoid undoing moves, and capture the 11th tile’s hex color to unlock a bonus level.
- Museum guide robot scheduling: navigate two-step visitor routes across exhibit tiles, then read the 11th tile’s hex color to display the corresponding artwork description.

```
import os
import json
from collections import Counter, deque

# Paths to workspace files
workspace = 'workspace'
grid_path = os.path.join(workspace, 'grid_data.json')
coords_path = os.path.join(workspace, 'start_end_coordinates.json')

# 1) Load and inspect grid_data.json
print(f"Loading grid data from: {grid_path}")
with open(grid_path, 'r', encoding='utf-8') as f:
    grid = json.load(f)
print(f"Total cells loaded: {len(grid)}")

# 1a) Count fill_color frequencies
colors = [cell.get('fill_color', '') for cell in grid]
color_counts = Counter(colors)
print("\nFill_color frequencies:")
for color, cnt in color_counts.items():
    print(f"  '{color}' : {cnt} cells")

# 1b) Show all cells where 'value' is non-empty (START and END)
print("\nCells with non-empty 'value' field:")
for cell in grid:
    if cell.get('value', ''):
        print(f"  {cell['value']:>5} at ({cell['row']},{cell['col']}) fill_color='{cell['fill_color']}'")

# 2) Decide passable colors: only green ('92D050') plus empty-string for START/END
PASSABLE_COLORS = {'92D050', ''}
print(f"\nDefining passable fill_colors = {PASSABLE_COLORS}")

# Build cell_map and passable set
cell_map = {}
passable = set()
for cell in grid:
    coord = (cell['row'], cell['col'])
    cell_map[coord] = cell
    if cell.get('fill_color', '') in PASSABLE_COLORS:
        passable.add(coord)
print(f"Passable cells count: {len(passable)} / {len(grid)}\n")

# 3) Load START and END coordinates
print(f"Loading START/END from: {coords_path}")
with open(coords_path, 'r', encoding='utf-8') as f:
    se = json.load(f)
start = (se['START']['row'], se['START']['col'])
end   = (se['END']['row'],   se['END']['col'])
print(f"START at {start}, END at {end}\n")

# 4) Build adjacency for two-cell cardinal jumps with intermediate-cell check
moves = [(2,0), (-2,0), (0,2), (0,-2)]
adj = {coord: [] for coord in passable}
print("Building adjacency list (two-cell jumps requiring both mid and dest passable)...")
for (r, c) in sorted(passable):
    nbrs = []
    for dr, dc in moves:
        mid = (r + dr//2, c + dc//2)
        dest = (r + dr,      c + dc)
        if dest in passable and mid in passable:
            nbrs.append(dest)
    adj[(r,c)] = nbrs
    # print only first few for brevity
    if (r,c) in [start, end] or len(nbrs)==0:
        print(f"  Cell {(r,c)} -> neighbors: {nbrs}")
print("Adjacency construction done.\n")

# 5) Basic BFS to check connectivity
print("Checking basic reachability (ignoring no-backtracking)...")
visited = set([start])
queue = deque([start])
while queue:
    cur = queue.popleft()
    for n in adj[cur]:
        if n not in visited:
            visited.add(n)
            queue.append(n)
print(f"Reachable from START: {len(visited)} cells")
if end not in visited:
    print("ERROR: END NOT reachable under two-cell jumps with current passable rule.")
    print("-- You may need to adjust passable colors or consider one-cell moves or diagonals.")
    exit(1)
print("END is reachable under two-cell jump rules.\n")

# 6) BFS shortest-path with no immediate backtracking
print("Performing BFS (no immediate backtracking) to find shortest path...")
State = (start, None)
queue = deque([(start, None, [start])])
seen = set([(start, None)])
path_to_end = None
while queue:
    cur, prev, path = queue.popleft()
    if cur == end:
        path_to_end = path
        break
    for n in adj[cur]:
        if n == prev:
            continue
        st = (n, cur)
        if st not in seen:
            seen.add(st)
            queue.append((n, cur, path + [n]))

if not path_to_end:
    print("ERROR: No path found under no-backtracking BFS.")
    exit(1)
print(f"Found path with {len(path_to_end)-1} moves.\n")

# 7) Extract 11th move coordinate and its fill_color
if len(path_to_end) <= 11:
    print(f"ERROR: Path only has {len(path_to_end)-1} moves; cannot get 11th move.")
    exit(1)
coord11 = path_to_end[11]
color11 = cell_map[coord11]['fill_color']
print(f"Coordinate after 11th move: {coord11}")
print(f"Fill color at that cell: {color11}\n")

# 8) Write result JSON
oresult = {
    '11th_move_coordinate': {'row': coord11[0], 'col': coord11[1]},
    'fill_color': color11,
    'path_moves': len(path_to_end)-1
}
out_file = os.path.join(workspace, 'eleventh_move_result.json')
with open(out_file, 'w', encoding='utf-8') as f:
    json.dump(oresult, f, indent=2)
print(f"Result saved to {out_file}")
```