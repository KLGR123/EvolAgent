### Development Step 3: Test Caesar Cipher Shifts to Decrypt Picnic Meeting Location

**Description**: Decrypt the Caesar cipher message 'Zsmxsm sc sx Zyvilsec Zvkjk.' by testing different shift values to find the correct decryption that reveals a readable English location for the picnic meeting place.

**Use Cases**:
- Geocaching adventure clue decryption to automatically translate Caesar‐ciphered location hints into GPS coordinates for outdoor treasure hunts
- Corporate training assessment automation for entry-level infosec courses, testing students’ code solutions by brute-forcing Caesar cipher messages and validating decrypted answers
- Historical document digitization in museum archives, bulk-processing scanned letters with potential Caesar cipher encodings to reveal hidden personal correspondence and event details
- Penetration testing toolkit component for web applications, scanning source code and configuration files for weak Caesar cipher obfuscations and generating decrypted outputs for vulnerability reports
- Educational platform content generation for cryptography classes, programmatically generating and validating Caesar cipher puzzles and ensuring the decrypted text matches learning objectives
- Journalism investigative workflow for processing leaked files, automatically decrypting Caesar-shifted text blocks to uncover concealed information in whistleblower documents
- Escape room puzzle development pipeline, verifying that Caesar-shifted riddle messages correctly decrypt to intended clues before publishing game materials
- Data loss prevention (DLP) scanning in enterprise email servers, detecting simple substitution-ciphered exfiltration attempts by brute-forcing shifts and flagging suspicious readable outputs

```
# Caesar cipher decryption - simplified approach to avoid scope issues
# The message to decrypt: 'Zsmxsm sc sx Zyvilsec Zvkjk.'

cipher_message = 'Zsmxsm sc sx Zyvilsec Zvkjk.'

print('=== CAESAR CIPHER DECRYPTION ANALYSIS ===')
print(f'Encrypted message: "{cipher_message}"')
print(f'Message length: {len(cipher_message)} characters')
print()

# Function to decrypt Caesar cipher with given shift
def caesar_decrypt(text, shift):
    result = ''
    for char in text:
        if char.isalpha():
            # Determine if uppercase or lowercase
            is_upper = char.isupper()
            # Convert to lowercase for processing
            char = char.lower()
            # Apply shift (subtract for decryption)
            shifted_char = chr((ord(char) - ord('a') - shift) % 26 + ord('a'))
            # Restore original case
            if is_upper:
                shifted_char = shifted_char.upper()
            result += shifted_char
        else:
            # Keep non-alphabetic characters unchanged (spaces, punctuation)
            result += char
    return result

print('Testing all possible shift values (1-25):')
print('=' * 60)

decryption_results = []
best_candidates = []

for shift in range(1, 26):
    decrypted = caesar_decrypt(cipher_message, shift)
    print(f'Shift {shift:2d}: "{decrypted}"')
    
    # Store result
    decryption_results.append({
        'shift': shift,
        'decrypted_text': decrypted
    })
    
    # Simple analysis - look for readable English patterns
    text_lower = decrypted.lower().replace('.', '')
    words = text_lower.split()
    
    # Check for common English words directly (avoiding generator expressions)
    readable_score = 0
    found_words = []
    
    # Check each word individually
    for word in words:
        if word in ['the', 'is', 'in', 'at', 'on', 'to', 'of', 'and', 'a', 'an', 'for', 'with', 'picnic']:
            readable_score += 2
            found_words.append(word)
        elif word in ['park', 'street', 'avenue', 'road', 'place', 'square', 'center', 'garden', 'plaza', 'court']:
            readable_score += 3
            found_words.append(word)
    
    # Check for proper sentence structure
    if len(words) >= 4 and len(words) <= 8:
        readable_score += 1
    
    # Check for capitalized words (proper nouns)
    capitalized_count = 0
    for word in decrypted.split():
        if word and word[0].isupper() and len(word) > 1:
            capitalized_count += 1
    
    if capitalized_count >= 2:
        readable_score += 2
    
    # If this looks promising, note it
    if readable_score >= 3 or found_words:
        print(f'    *** Potentially readable (Score: {readable_score}) ***')
        if found_words:
            print(f'        Found words: {found_words}')
        
        best_candidates.append({
            'shift': shift,
            'text': decrypted,
            'score': readable_score,
            'found_words': found_words
        })

print('\n' + '=' * 60)
print('DETAILED ANALYSIS OF PROMISING CANDIDATES:')
print('=' * 60)

# Sort candidates by score
best_candidates.sort(key=lambda x: x['score'], reverse=True)

if best_candidates:
    print('\nTop candidates (sorted by readability score):')
    for i, candidate in enumerate(best_candidates, 1):
        print(f'\n{i}. Shift {candidate["shift"]} (Score: {candidate["score"]}): "{candidate["text"]}"')
        if candidate['found_words']:
            print(f'    Found English words: {candidate["found_words"]}')
        
        # Additional manual analysis for top candidates
        words = candidate['text'].lower().replace('.', '').split()
        if 'is' in words and 'at' in words:
            print('    *** Contains "is" and "at" - typical location description! ***')
        
        # Check if it looks like a location description
        text_analysis = []
        if len(words) >= 4:
            text_analysis.append(f'Sentence structure: {", ".join(words)}')
        
        capitalized_words = [word for word in candidate['text'].split() if word and word[0].isupper() and len(word) > 1]
        if capitalized_words:
            text_analysis.append(f'Proper nouns (likely place names): {capitalized_words}')
        
        for analysis in text_analysis:
            print(f'    {analysis}')
        
        if i == 1 and candidate['score'] >= 5:
            print('    *** MOST LIKELY ANSWER - PICNIC LOCATION FOUND! ***')
else:
    print('\nNo clearly readable candidates found. Let me examine all results manually...')
    
    print('\nManual inspection of all results:')
    for result in decryption_results:
        text = result['decrypted_text']
        shift = result['shift']
        words = text.lower().replace('.', '').split()
        
        # Look for any English-like patterns
        if len(words) >= 4:
            print(f'\nShift {shift}: "{text}"')
            print(f'    Words: {words}')
            
            # Check for location-like patterns
            if any(len(word) >= 4 for word in words):
                print('    Contains longer words - could be place names')

print('\n' + '=' * 60)
print('FINAL ANSWER DETERMINATION:')
print('=' * 60)

if best_candidates:
    top_answer = best_candidates[0]
    print(f'\nBest decryption result:')
    print(f'Shift: {top_answer["shift"]}')
    print(f'Decrypted message: "{top_answer["text"]}"')
    print(f'Readability score: {top_answer["score"]}')
    
    # Extract the location from the decrypted message
    location_text = top_answer['text'].replace('.', '').strip()
    print(f'\nPicnic meeting place: {location_text}')
    
    # Save the final answer
    with open('workspace/picnic_location.txt', 'w') as f:
        f.write('Caesar Cipher Decryption - Picnic Location\n')
        f.write('=' * 45 + '\n\n')
        f.write(f'Encrypted message: "{cipher_message}"\n')
        f.write(f'Correct shift value: {top_answer["shift"]}\n')
        f.write(f'Decrypted message: "{top_answer["text"]}"\n')
        f.write(f'Readability score: {top_answer["score"]}\n\n')
        f.write(f'PICNIC MEETING PLACE: {location_text}\n')
    
    print(f'\nResult saved to: workspace/picnic_location.txt')
else:
    print('\nUnable to determine clear answer. All decryption attempts:')
    for result in decryption_results[:10]:  # Show first 10 results
        print(f'Shift {result["shift"]}: "{result["decrypted_text"]}"')

# Save all results for reference
with open('workspace/all_caesar_results.txt', 'w') as f:
    f.write('Complete Caesar Cipher Decryption Results\n')
    f.write('=' * 50 + '\n\n')
    f.write(f'Original encrypted message: "{cipher_message}"\n\n')
    f.write('All 25 possible decryptions:\n')
    f.write('-' * 40 + '\n')
    
    for result in decryption_results:
        f.write(f'Shift {result["shift"]:2d}: "{result["decrypted_text"]}"\n')
    
    f.write('\nAnalysis complete.\n')

print(f'\nAll decryption attempts saved to: workspace/all_caesar_results.txt')
print('\n=== CAESAR CIPHER DECRYPTION COMPLETE ===')
```