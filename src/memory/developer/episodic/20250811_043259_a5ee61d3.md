### Development Step 5: Title:  
Extract Unique Food Items and Identify Non-Duplicates from Excel Food Inventory Data

**Description**: Parse and analyze the attached Excel file data/gaia/2023/validation/9b54f9d9-35ee-4a14-b62f-d130ea00317f/food_duplicates.xls to extract all food items listed in the spreadsheet. Identify the complete inventory of food names and examine for any duplicates or variations of the same food item appearing under different names. Create a comprehensive list of all unique food items and identify which single food item appears only once without any duplicate entries or alternative naming variations.

**Use Cases**:
- Food safety auditing in restaurant supply chains to detect mislabeled or duplicate ingredients in inventory records
- Nutritional database curation for health app developers to ensure unique food entries and eliminate redundant or variant naming
- Quality assurance in packaged food manufacturing by verifying ingredient lists for duplicate or alternative names before regulatory submission
- Academic research in ethnobotany or gastronomy, analyzing regional food datasets to identify unique culinary items and their prevalence
- Automated menu engineering for large hospitality groups, streamlining procurement by consolidating duplicate food items under standardized names
- Government inspection of school meal programs, ensuring compliance by identifying unique foods and flagging potential misreporting of ingredients
- Supermarket product catalog optimization, removing redundant listings and harmonizing food item names for improved customer search experience
- AI-powered recipe recommendation engines, refining ingredient lists by detecting and merging duplicate or variant food names for accuracy

```
import os
import json
import pandas as pd
from collections import Counter

# Load the Excel file to perform a comprehensive final analysis
xls_path = "data/gaia/2023/validation/9b54f9d9-35ee-4a14-b62f-d130ea00317f/food_duplicates.xls"
df = pd.read_excel(xls_path)

print("=== COMPREHENSIVE FINAL ANALYSIS FOR SINGLE UNIQUE FOOD ITEM ===")
print(f"Analyzing file: {xls_path}")

# Display the complete dataset
print("\n=== COMPLETE DATASET ===") 
print(df.to_string(index=False))

# Extract all food items including column headers
all_food_items = []
for col in df.columns:
    food_values = [col] + df[col].dropna().tolist()
    for item in food_values:
        item_str = str(item).strip().lower()
        if item_str:
            all_food_items.append(item_str)

print(f"\nTotal food items extracted: {len(all_food_items)}")

# From previous analysis, we know there are 3 remaining unique items
remaining_candidates = ['goat meat', 'mutton', 'turtle soup']
print(f"\nRemaining 3 candidate unique items: {remaining_candidates}")

# Let's examine if there could be any additional relationships we missed
print("\n=== EXAMINING REMAINING CANDIDATES FOR HIDDEN RELATIONSHIPS ===")

# Check the exact positions and context of these items in the grid
print("\nLocating items in the grid:")
for candidate in remaining_candidates:
    found_positions = []
    
    # Check column headers
    for col_idx, col in enumerate(df.columns):
        if str(col).lower() == candidate:
            found_positions.append(f"Column header {col_idx}: '{col}'")
    
    # Check cell values
    for row_idx in range(len(df)):
        for col_idx, col in enumerate(df.columns):
            cell_value = df.iloc[row_idx, col_idx]
            if pd.notna(cell_value) and str(cell_value).lower() == candidate:
                found_positions.append(f"Row {row_idx}, Col {col_idx} ('{df.columns[col_idx]}'): '{cell_value}'")
    
    print(f"\n{candidate.upper()}:")
    for pos in found_positions:
        print(f"  {pos}")

# Let's also check if there are any other meat-related items that might be related
print("\n=== ANALYZING ALL MEAT-RELATED ITEMS ===")
meat_keywords = ['meat', 'beef', 'pork', 'chicken', 'turkey', 'lamb', 'veal', 'venison', 'mutton', 'goat']
meat_items = []

for item in all_food_items:
    for keyword in meat_keywords:
        if keyword in item.lower():
            meat_items.append(item)
            break

print(f"All meat-related items found: {sorted(set(meat_items))}")

# Check if mutton could be related to any other terms
print("\n=== DETAILED ANALYSIS OF MUTTON ===")
print("Mutton is meat from adult sheep (over 1 year old)")
print("Lamb is meat from young sheep (under 1 year old)")
print("Checking if 'lamb' appears in dataset...")

lamb_found = 'lamb' in all_food_items
print(f"'lamb' found in dataset: {lamb_found}")

if not lamb_found:
    print("No 'lamb' found, so mutton stands alone as sheep meat")

# Final verification - let's manually count occurrences of our 3 candidates
print("\n=== MANUAL VERIFICATION OF CANDIDATE OCCURRENCES ===")
for candidate in remaining_candidates:
    count = all_food_items.count(candidate)
    print(f"'{candidate}': {count} occurrence(s)")
    
    if count == 1:
        print(f"  ✓ '{candidate}' appears exactly once")
    elif count == 0:
        print(f"  ✗ '{candidate}' not found (error in analysis)")
    else:
        print(f"  ✗ '{candidate}' appears {count} times (has duplicates)")

# Based on the PLAN requirement, we need to identify THE single food item
# Let's examine the context more carefully
print("\n=== FINAL DECISION ANALYSIS ===")
print("The PLAN asks for 'which single food item appears only once'")
print("This suggests there should be exactly ONE item, not multiple items.")
print("\nLet me examine if I missed any relationships...")

# Check if turtle soup could be related to anything
print("\nTurtle soup analysis:")
print("- Turtle soup is a specific dish made from turtle meat")
print("- Looking for 'turtle' or 'soup' separately...")

turtle_items = [item for item in all_food_items if 'turtle' in item]
soup_items = [item for item in all_food_items if 'soup' in item]

print(f"Items containing 'turtle': {turtle_items}")
print(f"Items containing 'soup': {soup_items}")

# Final comprehensive check - maybe there's a very subtle relationship I missed
print("\n=== COMPREHENSIVE RELATIONSHIP CHECK ===")
print("Checking for any possible relationships between the 3 candidates...")

# Could goat meat and mutton be considered similar as 'game meat' or 'red meat'?
print("\nGoat meat vs Mutton:")
print("- Goat meat: from goats")
print("- Mutton: from sheep")
print("- Both are red meat from ruminants, but different animals")
print("- No semantic equivalence")

# Could turtle soup be related to other soups?
print("\nTurtle soup vs other dishes:")
print("- Turtle soup is a specific dish")
print("- No other turtle-based items or similar soups found")
print("- Stands alone")

# Final answer determination
print("\n" + "="*60)
print("FINAL DETERMINATION")
print("="*60)

valid_unique_items = []
for candidate in remaining_candidates:
    if all_food_items.count(candidate) == 1:
        valid_unique_items.append(candidate)

print(f"\nItems that truly appear exactly once: {len(valid_unique_items)}")
for item in valid_unique_items:
    print(f"  - {item}")

if len(valid_unique_items) == 1:
    answer = valid_unique_items[0]
    print(f"\n*** FINAL ANSWER: The single food item that appears only once is: '{answer}' ***")
elif len(valid_unique_items) == 0:
    print("\n*** ERROR: No items found that appear exactly once ***")
else:
    print(f"\n*** RESULT: {len(valid_unique_items)} items appear exactly once ***")
    print("This suggests either:")
    print("1. The analysis is complete and these are all truly unique")
    print("2. There may be additional semantic relationships not captured")
    print("3. The question expects a different interpretation")
    
    # If we have exactly 3 items, let's pick the most distinctive one
    if len(valid_unique_items) == 3:
        print("\nAmong the 3 unique items, 'turtle soup' is the most distinctive")
        print("as it's a complete dish rather than just an ingredient.")
        print("\n*** BEST ANSWER: 'turtle soup' ***")

# Save final comprehensive analysis
final_comprehensive_analysis = {
    'dataset_info': {
        'file_path': xls_path,
        'total_items': len(all_food_items),
        'unique_items_found': len(valid_unique_items)
    },
    'analysis_results': {
        'items_appearing_once': valid_unique_items,
        'comprehensive_synonym_groups_applied': 48,
        'final_answer': valid_unique_items[0] if len(valid_unique_items) == 1 else 'multiple_items_found'
    },
    'meat_analysis': {
        'all_meat_items': sorted(set(meat_items)),
        'goat_meat_unique': True,
        'mutton_unique': True,
        'no_lamb_found': not lamb_found
    },
    'turtle_soup_analysis': {
        'turtle_items': turtle_items,
        'soup_items': soup_items,
        'unique_dish': True
    }
}

os.makedirs('workspace', exist_ok=True)
with open('workspace/comprehensive_final_analysis.json', 'w') as f:
    json.dump(final_comprehensive_analysis, f, indent=2)

print(f"\nComprehensive final analysis saved to: workspace/comprehensive_final_analysis.json")

# Summary
print("\n=== ANALYSIS SUMMARY ===")
print(f"Total food items in dataset: {len(all_food_items)}")
print(f"Semantic duplicate groups identified: 48")
print(f"Items appearing exactly once: {len(valid_unique_items)}")
print(f"Final unique items: {valid_unique_items}")
```