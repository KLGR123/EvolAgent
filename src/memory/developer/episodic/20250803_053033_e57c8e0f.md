### Development Step 2: Build Boggle solver using words_alpha dictionary to find longest word on 4x4 board

**Description**: Download the words_alpha dictionary from https://github.com/dwyl/english-words to workspace/words_alpha.txt and then implement a Boggle solver to find all valid words that can be formed from the given 4x4 board (ABRL/EITE/IONS/FPEI) using the downloaded dictionary. The solver should check all possible paths on the board where adjacent cells (including diagonally adjacent) can be visited exactly once per word, then identify the longest valid English word(s) and return the alphabetically first one if there are ties.

**Use Cases**:
- Mobile game QA and level design validation to ensure every 4×4 Boggle board has at least one solution and identify the optimal longest word before release
- Educational app vocabulary exercises that generate random letter grids for ESL students and automatically retrieve valid word lists to support lesson plans
- Real-time word verification and scoring engine for Boggle tournaments and online competitions, enabling instant feedback and accurate leaderboards
- Cognitive psychology research tool to analyze board complexity by computing distributions of word lengths and branching paths for human performance studies
- Accessibility assistant for visually impaired players that converts spoken or tactile Boggle boards into text and uses the solver to read out possible words and hints
- Social media engagement feature that publishes daily Boggle puzzles with precomputed solution sets to boost community interaction and shareability
- Chatbot or virtual assistant integration that solves user-submitted 4×4 letter puzzles on demand, enhancing conversational game experiences
- Marketing campaign gamification that embeds custom word-finding challenges in newsletters or microsites with automated answer validation and prize entry mechanisms

```
import os
import requests
from collections import defaultdict
import time

print('=== BOGGLE SOLVER IMPLEMENTATION - FIXED VERSION ===')
print('Fixing function scope issue from previous attempt\n')

# Ensure workspace directory exists
workspace = 'workspace'
os.makedirs(workspace, exist_ok=True)

# Check if dictionary already exists, if not download it
words_file_path = os.path.join(workspace, 'words_alpha.txt')

if not os.path.exists(words_file_path):
    print('Step 1: Downloading words_alpha dictionary from GitHub\n')
    
    words_url = 'https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt'
    print(f'Downloading dictionary from: {words_url}')
    print(f'Saving to: {words_file_path}')
    
    try:
        response = requests.get(words_url, timeout=30)
        print(f'Response status: {response.status_code}')
        
        if response.status_code == 200:
            with open(words_file_path, 'w', encoding='utf-8') as f:
                f.write(response.text)
            
            print(f'✓ Dictionary downloaded successfully')
            print(f'File size: {len(response.text):,} characters')
            
            # Count number of words
            word_count = len(response.text.strip().split('\n'))
            print(f'Total words in dictionary: {word_count:,}')
            
        else:
            print(f'Error downloading dictionary: HTTP {response.status_code}')
            
    except Exception as e:
        print(f'Error downloading dictionary: {e}')
else:
    print('✓ Dictionary file already exists, skipping download')

print('\n=== STEP 2: LOADING DICTIONARY INTO MEMORY ===')

# Load the dictionary into a set for fast lookup
if os.path.exists(words_file_path):
    print(f'Loading dictionary from: {words_file_path}')
    
    with open(words_file_path, 'r', encoding='utf-8') as f:
        dictionary_words = set(word.strip().lower() for word in f if word.strip())
    
    print(f'✓ Dictionary loaded: {len(dictionary_words):,} unique words')
    
    # Check some common words to verify dictionary quality
    test_words = ['the', 'and', 'hello', 'world', 'python', 'boggle']
    print(f'\nTesting common words in dictionary:')
    for word in test_words:
        in_dict = word in dictionary_words
        print(f'  "{word}": {"✓" if in_dict else "✗"}')
else:
    print('Error: Dictionary file not found!')
    dictionary_words = set()

print('\n=== STEP 3: DEFINING THE 4x4 BOGGLE BOARD ===')

# Define the 4x4 Boggle board as given in the plan
# ABRL
# EITE  
# IONS
# FPEI

boggle_board = [
    ['A', 'B', 'R', 'L'],
    ['E', 'I', 'T', 'E'], 
    ['I', 'O', 'N', 'S'],
    ['F', 'P', 'E', 'I']
]

print('Boggle board:')
for i, row in enumerate(boggle_board):
    print(f'Row {i}: {" ".join(row)}')

print(f'\nBoard dimensions: {len(boggle_board)}x{len(boggle_board[0])}')

# Verify board structure
total_letters = sum(len(row) for row in boggle_board)
print(f'Total letters on board: {total_letters}')

# Count letter frequency
letter_count = defaultdict(int)
for row in boggle_board:
    for letter in row:
        letter_count[letter] += 1

print(f'Letter frequency: {dict(letter_count)}')

print('\n=== STEP 4: DEFINING HELPER FUNCTIONS ===')

# Define helper functions at global scope to fix the scope issue
def get_neighbors(row, col, rows, cols):
    """Get all adjacent cells (including diagonal) for a given position"""
    neighbors = []
    # Check all 8 directions: up, down, left, right, and 4 diagonals
    directions = [
        (-1, -1), (-1, 0), (-1, 1),  # up-left, up, up-right
        (0, -1),           (0, 1),   # left, right
        (1, -1),  (1, 0),  (1, 1)    # down-left, down, down-right
    ]
    
    for dr, dc in directions:
        new_row, new_col = row + dr, col + dc
        if 0 <= new_row < rows and 0 <= new_col < cols:
            neighbors.append((new_row, new_col))
    
    return neighbors

def find_words_from_position(board, dictionary, start_row, start_col, visited, current_word, found_words):
    """Recursively find all valid words starting from a given position"""
    rows, cols = len(board), len(board[0])
    
    # Add current letter to the word
    current_word += board[start_row][start_col].lower()
    
    # Mark current position as visited
    visited.add((start_row, start_col))
    
    # Check if current word is valid and has reasonable length (3+ letters)
    if len(current_word) >= 3 and current_word in dictionary:
        found_words.add(current_word)
        print(f'Found valid word: "{current_word}" (length: {len(current_word)})')
    
    # Continue searching if word length is reasonable (prevent excessive recursion)
    if len(current_word) < 15:  # Reasonable max word length
        # Get all adjacent neighbors
        neighbors = get_neighbors(start_row, start_col, rows, cols)
        
        for next_row, next_col in neighbors:
            # Only visit unvisited cells
            if (next_row, next_col) not in visited:
                # Create a new copy of visited set for this branch
                new_visited = visited.copy()
                find_words_from_position(board, dictionary, next_row, next_col, new_visited, current_word, found_words)

def solve_boggle(board, dictionary):
    """Solve the Boggle puzzle and return all valid words"""
    found_words = set()
    rows, cols = len(board), len(board[0])
    
    print(f'Starting Boggle solve for {rows}x{cols} board...')
    print(f'Dictionary size: {len(dictionary):,} words')
    
    # Start search from each position on the board
    for row in range(rows):
        for col in range(cols):
            print(f'\nSearching from position ({row},{col}) - letter "{board[row][col]}":')
            visited = set()
            find_words_from_position(board, dictionary, row, col, visited, '', found_words)
    
    return found_words

print('✓ Helper functions defined successfully')

print('\n=== STEP 5: RUNNING BOGGLE SOLVER ===')

if dictionary_words:
    print('Starting Boggle word search...')
    start_time = time.time()
    
    # Solve the Boggle puzzle
    all_found_words = solve_boggle(boggle_board, dictionary_words)
    
    end_time = time.time()
    solve_time = end_time - start_time
    
    print(f'\n=== BOGGLE SOLVE COMPLETE ===')
    print(f'Solve time: {solve_time:.2f} seconds')
    print(f'Total valid words found: {len(all_found_words)}')
    
    if all_found_words:
        # Sort words by length (descending) then alphabetically
        sorted_words = sorted(all_found_words, key=lambda w: (-len(w), w))
        
        print(f'\n=== ALL FOUND WORDS (sorted by length, then alphabetically) ===')
        current_length = None
        for word in sorted_words:
            if len(word) != current_length:
                current_length = len(word)
                print(f'\n--- {current_length}-letter words ---')
            print(f'  {word}')
        
        # Find the longest word(s)
        max_length = max(len(word) for word in all_found_words)
        longest_words = [word for word in all_found_words if len(word) == max_length]
        longest_words.sort()  # Sort alphabetically
        
        print(f'\n=== LONGEST WORD(S) FOUND ===')
        print(f'Maximum word length: {max_length} letters')
        print(f'Number of longest words: {len(longest_words)}')
        print(f'Longest words: {longest_words}')
        
        # Return the alphabetically first longest word
        answer = longest_words[0]
        print(f'\n*** FINAL ANSWER: "{answer}" ***')
        print(f'Length: {len(answer)} letters')
        
        # Save results to file
        results_file = os.path.join(workspace, 'boggle_solver_results.txt')
        with open(results_file, 'w', encoding='utf-8') as f:
            f.write('BOGGLE SOLVER RESULTS\n')
            f.write('=' * 50 + '\n\n')
            f.write('Board:\n')
            for row in boggle_board:
                f.write(' '.join(row) + '\n')
            f.write(f'\nTotal words found: {len(all_found_words)}\n')
            f.write(f'Longest word length: {max_length}\n')
            f.write(f'Longest word (alphabetically first): {answer}\n\n')
            f.write('All words by length:\n')
            f.write('-' * 30 + '\n')
            current_length = None
            for word in sorted_words:
                if len(word) != current_length:
                    current_length = len(word)
                    f.write(f'\n{current_length}-letter words:\n')
                f.write(f'  {word}\n')
        
        print(f'\n✓ Complete results saved to: {results_file}')
        
    else:
        print('No valid words found!')
else:
    print('Error: Dictionary not loaded, cannot solve Boggle puzzle')
```