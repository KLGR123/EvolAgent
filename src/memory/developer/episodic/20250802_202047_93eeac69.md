### Development Step 2: Eliud Kipchoge Marathon Record Time and Pace Calculation

**Description**: Search for Eliud Kipchoge's marathon world record time to determine his record-making pace. Find the official time from his world record performance and calculate his pace in terms of distance per hour or time per kilometer/mile.

**Use Cases**:
- Automated sports journalism workflow that scrapes Eliud Kipchoge’s official marathon world record and generates up-to-date pace infographics for news articles
- Integration into a marathon training app that dynamically fetches world record pace to set personalized split-time targets for runners
- Data ingestion pipeline for a fitness analytics dashboard that benchmarks user performance against Kipchoge’s record in km/h and min/mile
- On-air broadcasting tool for live marathon coverage that extracts and displays real-time comparisons with the world record pace
- Academic sports science research script that compiles historical marathon records and computes pace metrics for comparative studies
- Event management website feature that automatically pulls in record holder splits and speeds to showcase world record stats on race result pages
- Voice-assistant skill integration (e.g., Alexa or Google Assistant) that answers “What’s Eliud Kipchoge’s marathon record pace?” using live scraped data

```
import json
import os
from bs4 import BeautifulSoup
import re

print('=== ELIUD KIPCHOGE MARATHON WORLD RECORD ANALYSIS - PHASE 2 ===\n')
print('Objective: Extract official world record time and calculate pace metrics\n')

# First, let's inspect the workspace structure and understand what data we have
print('=== STEP 1: INSPECTING WORKSPACE STRUCTURE ===\n')

if os.path.exists('workspace'):
    workspace_files = os.listdir('workspace')
    print(f'Files in workspace: {len(workspace_files)}')
    for file in workspace_files:
        file_path = os.path.join('workspace', file)
        file_size = os.path.getsize(file_path)
        print(f'  - {file} ({file_size:,} bytes)')
else:
    print('No workspace directory found')
    exit()

# Inspect the search summary to understand what sources were successful
summary_file = 'workspace/kipchoge_search_summary.json'
if os.path.exists(summary_file):
    print(f'\n=== STEP 2: ANALYZING SEARCH SUMMARY ===\n')
    
    with open(summary_file, 'r') as f:
        search_summary = json.load(f)
    
    print('Search summary structure:')
    for key, value in search_summary.items():
        if isinstance(value, list):
            print(f'  {key}: List with {len(value)} items')
        elif isinstance(value, dict):
            print(f'  {key}: Dictionary with keys: {list(value.keys())}')
        else:
            print(f'  {key}: {value}')
    
    # Examine successful sources
    successful_sources = []
    if 'search_results' in search_summary:
        print(f'\nAnalyzing {len(search_summary["search_results"])} search results:')
        
        for i, result in enumerate(search_summary['search_results'], 1):
            print(f'\nSource {i}: {result.get("source_name", "Unknown")}')
            print(f'  Access successful: {result.get("access_successful", False)}')
            
            if result.get('access_successful', False):
                print(f'  Filename: {result.get("filename", "Not specified")}')
                print(f'  Kipchoge mentions: {result.get("kipchoge_mentions", 0)}')
                print(f'  Record mentions: {result.get("record_mentions", 0)}')
                print(f'  Time patterns: {result.get("time_patterns_found", 0)}')
                print(f'  Sample times: {result.get("sample_time_patterns", [])}')
                successful_sources.append(result)
            else:
                print(f'  Error: {result.get("error", "Unknown error")}')
    
    print(f'\nTotal successful sources: {len(successful_sources)}')
else:
    print(f'Search summary file not found: {summary_file}')
    exit()

print('\n=== STEP 3: PARSING HTML CONTENT FOR WORLD RECORD TIME ===\n')

# Parse each successful source to find the official world record time
record_candidates = []

for source in successful_sources:
    filename = source.get('filename', '')
    source_name = source.get('source_name', 'Unknown')
    
    if not filename or not os.path.exists(filename):
        print(f'Skipping {source_name} - file not found: {filename}')
        continue
    
    print(f'\n--- ANALYZING {source_name.upper()} ---')
    print(f'File: {filename}')
    
    with open(filename, 'r', encoding='utf-8') as f:
        html_content = f.read()
    
    soup = BeautifulSoup(html_content, 'html.parser')
    text_content = soup.get_text()
    
    # Look for specific patterns indicating Kipchoge's world record
    # Common patterns: "2:01:39", "2:01:09", etc.
    
    # Find all time patterns in marathon range (roughly 2:00:00 to 2:30:00)
    marathon_time_pattern = r'\b2:[0-5][0-9]:[0-5][0-9]\b'
    found_times = re.findall(marathon_time_pattern, text_content)
    
    print(f'Found {len(found_times)} potential marathon times: {list(set(found_times))}')
    
    # Look for context around these times to identify the world record
    lines = text_content.split('\n')
    
    for line in lines:
        line_lower = line.lower().strip()
        
        # Look for lines containing both Kipchoge and a time, plus record-related keywords
        if ('kipchoge' in line_lower and 
            ('world record' in line_lower or 'record' in line_lower) and
            re.search(marathon_time_pattern, line)):
            
            # Extract the time from this line
            time_match = re.search(marathon_time_pattern, line)
            if time_match:
                record_time = time_match.group()
                
                print(f'\n*** POTENTIAL WORLD RECORD FOUND ***')
                print(f'Source: {source_name}')
                print(f'Time: {record_time}')
                print(f'Context: {line.strip()[:200]}...')
                
                record_candidates.append({
                    'source': source_name,
                    'time': record_time,
                    'context': line.strip(),
                    'confidence': 'high'
                })
    
    # Also look for common specific times mentioned in the initial analysis
    specific_times_to_check = ['2:01:39', '2:01:09', '2:00:35']
    
    for check_time in specific_times_to_check:
        if check_time in text_content:
            # Find context for this time
            for line in lines:
                if check_time in line and 'kipchoge' in line.lower():
                    print(f'\n*** SPECIFIC TIME MATCH: {check_time} ***')
                    print(f'Context: {line.strip()[:200]}...')
                    
                    record_candidates.append({
                        'source': source_name,
                        'time': check_time,
                        'context': line.strip(),
                        'confidence': 'medium'
                    })
                    break

print(f'\n=== STEP 4: ANALYZING RECORD CANDIDATES ===\n')
print(f'Found {len(record_candidates)} potential world record times:')

for i, candidate in enumerate(record_candidates, 1):
    print(f'\nCandidate {i}:')
    print(f'  Source: {candidate["source"]}')
    print(f'  Time: {candidate["time"]}')
    print(f'  Confidence: {candidate["confidence"]}')
    print(f'  Context: {candidate["context"][:150]}...')

# Determine the most likely official world record time
# Priority: High confidence candidates, then most recent/common time
if record_candidates:
    # Sort by confidence and frequency
    from collections import Counter
    time_counts = Counter([c['time'] for c in record_candidates])
    
    print(f'\nTime frequency analysis:')
    for time, count in time_counts.most_common():
        print(f'  {time}: appears {count} times')
    
    # Select the most likely world record time
    # Prefer high confidence, then most frequent
    high_confidence = [c for c in record_candidates if c['confidence'] == 'high']
    
    if high_confidence:
        official_record = high_confidence[0]
        print(f'\n*** OFFICIAL WORLD RECORD IDENTIFIED ***')
        print(f'Time: {official_record["time"]}')
        print(f'Source: {official_record["source"]}')
        print(f'Basis: High confidence match')
    else:
        # Use most frequent time
        most_common_time = time_counts.most_common(1)[0][0]
        official_record = next(c for c in record_candidates if c['time'] == most_common_time)
        print(f'\n*** OFFICIAL WORLD RECORD IDENTIFIED ***')
        print(f'Time: {official_record["time"]}')
        print(f'Source: {official_record["source"]}')
        print(f'Basis: Most frequently mentioned time')
    
else:
    print('\n*** NO CLEAR WORLD RECORD TIME IDENTIFIED ***')
    print('Will use commonly known record time: 2:01:39 (Berlin Marathon 2018)')
    official_record = {
        'time': '2:01:39',
        'source': 'Common knowledge',
        'context': 'Berlin Marathon 2018 world record'
    }

print('\n=== STEP 5: CALCULATING PACE METRICS ===\n')

# Parse the official record time
record_time_str = official_record['time']
print(f'Calculating pace for world record time: {record_time_str}')

# Parse time components
time_parts = record_time_str.split(':')
hours = int(time_parts[0])
minutes = int(time_parts[1])
seconds = int(time_parts[2])

# Convert to total seconds
total_seconds = hours * 3600 + minutes * 60 + seconds
print(f'Total time in seconds: {total_seconds:,} seconds')

# Marathon distance
marathon_km = 42.195  # Official marathon distance in kilometers
marathon_miles = 26.21875  # Official marathon distance in miles

print(f'Marathon distance: {marathon_km} km ({marathon_miles} miles)')

# Calculate pace metrics
print('\n=== PACE CALCULATIONS ===\n')

# 1. Minutes per kilometer
minutes_per_km = total_seconds / 60 / marathon_km
min_per_km_minutes = int(minutes_per_km)
min_per_km_seconds = (minutes_per_km - min_per_km_minutes) * 60

print(f'1. Pace per kilometer: {min_per_km_minutes}:{min_per_km_seconds:04.1f} min/km')

# 2. Minutes per mile
minutes_per_mile = total_seconds / 60 / marathon_miles
min_per_mile_minutes = int(minutes_per_mile)
min_per_mile_seconds = (minutes_per_mile - min_per_mile_minutes) * 60

print(f'2. Pace per mile: {min_per_mile_minutes}:{min_per_mile_seconds:04.1f} min/mile')

# 3. Speed in km/h
speed_kmh = marathon_km / (total_seconds / 3600)
print(f'3. Speed: {speed_kmh:.2f} km/h')

# 4. Speed in mph
speed_mph = marathon_miles / (total_seconds / 3600)
print(f'4. Speed: {speed_mph:.2f} mph')

# Save complete results
results = {
    'athlete': 'Eliud Kipchoge',
    'world_record_time': record_time_str,
    'source': official_record.get('source', 'Unknown'),
    'marathon_distance_km': marathon_km,
    'marathon_distance_miles': marathon_miles,
    'total_seconds': total_seconds,
    'pace_metrics': {
        'minutes_per_km': f'{min_per_km_minutes}:{min_per_km_seconds:04.1f}',
        'minutes_per_mile': f'{min_per_mile_minutes}:{min_per_mile_seconds:04.1f}',
        'speed_kmh': round(speed_kmh, 2),
        'speed_mph': round(speed_mph, 2)
    },
    'detailed_calculations': {
        'time_breakdown': {'hours': hours, 'minutes': minutes, 'seconds': seconds},
        'pace_per_km_decimal': round(minutes_per_km, 3),
        'pace_per_mile_decimal': round(minutes_per_mile, 3)
    },
    'record_candidates_analyzed': len(record_candidates)
}

with open('workspace/kipchoge_world_record_analysis.json', 'w') as f:
    json.dump(results, f, indent=2)

print(f'\n=== FINAL RESULTS SUMMARY ===\n')
print(f'Athlete: {results["athlete"]}')
print(f'World Record Time: {results["world_record_time"]}')
print(f'Source: {results["source"]}')
print(f'\nPace Metrics:')
print(f'  - Per kilometer: {results["pace_metrics"]["minutes_per_km"]} min/km')
print(f'  - Per mile: {results["pace_metrics"]["minutes_per_mile"]} min/mile')
print(f'  - Speed: {results["pace_metrics"]["speed_kmh"]} km/h')
print(f'  - Speed: {results["pace_metrics"]["speed_mph"]} mph')

print(f'\nComplete analysis saved to: workspace/kipchoge_world_record_analysis.json')
print('\n=== ANALYSIS COMPLETE ===\n')
```