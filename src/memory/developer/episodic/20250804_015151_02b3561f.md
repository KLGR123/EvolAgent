### Development Step 5: Extract Hex Color of 11th Move Cell via BFS on Two-Cell Move Adjacency Graph

**Description**: Construct adjacency graph of legal two-cell moves using workspace/grid_data.json and workspace/start_end_coordinates.json and perform a breadth-first search from the START cell to locate the shortest path to the END cell enforcing no immediate backtracking; identify the coordinate of the cell landed on after the 11th move along the resulting path; extract that cell’s 6-digit hex fill color from workspace/grid_data.json.

**Use Cases**:
- Warehouse robotics navigation and obstacle avoidance in automated fulfillment centers, planning two-cell hops through pallet aisles and identifying the 11th waypoint for sensor calibration
- Grid-based game AI pathfinding in puzzle-platformers where characters jump two tiles, computing the shortest no-backtracking route and retrieving the 11th tile’s color trigger for level scripting
- Drone flight path planning over agricultural plots divided into grid cells, enforcing two‐unit moves to avoid low-flying obstacles and marking the 11th GPS grid cell for aerial imaging focus
- Security patrol route optimization in a facility floorplan represented as a grid, using two-step corridor moves and pinpointing the 11th camera location by its assigned color code
- Pipeline inspection robot routing in industrial plant layouts, hopping across paired pipe segments and extracting the 11th joint’s inspection flag color for maintenance scheduling
- Wildlife tracking simulation on sensor networks laid out in a grid, modeling two-cell animal movements, ensuring no immediate backtracking, and noting the 11th sensor node’s status color for data logging
- Emergency services routing on urban road grids simplified to two-block moves, identifying the shortest path without U-turns and designating the 11th intersection by its signal color for staging support
- PCB trace routing in microchip design where signals jump two grid units, finding minimal no-backtracking wiring paths and highlighting the 11th via pad’s layer color for manufacturing checks

```
import os
import json
from collections import deque
import sys

# Paths to input JSON files
dir_workspace = 'workspace'
grid_file = os.path.join(dir_workspace, 'grid_data.json')
coords_file = os.path.join(dir_workspace, 'start_end_coordinates.json')

# Load grid data
print(f"Loading grid data from {grid_file}")
with open(grid_file, 'r') as f:
    grid = json.load(f)
print(f"Total cells in grid_data.json: {len(grid)}")

# Load start/end coordinates
print(f"Loading start/end coordinates from {coords_file}")
with open(coords_file, 'r') as f:
    se = json.load(f)
start = (se['START']['row'], se['START']['col'])
end = (se['END']['row'], se['END']['col'])
print(f"Start: {start}, End: {end}\n")

# Build maps and passable cell set
cell_map = {}          # (r,c) -> cell dict
grid_passable = set() # coords of non-blue cells (including start/end)
for cell in grid:
    coord = (cell['row'], cell['col'])
    cell_map[coord] = cell
    # Non-passable if fill_color == '0099FF' (blue)
    if cell['fill_color'] != '0099FF':
        grid_passable.add(coord)

print(f"Passable cells count: {len(grid_passable)} / {len(grid)} (non-blue)")

# Define two-cell moves in four cardinal directions
moves = [(2, 0), (-2, 0), (0, 2), (0, -2)]

# Construct adjacency list requiring the intermediate cell also passable
adj = {coord: [] for coord in grid_passable}
print("Building adjacency list with intermediate-cell passability check...")
for (r, c) in grid_passable:
    nbrs = []
    for dr, dc in moves:
        nr, nc = r + dr, c + dc
        mid = (r + dr // 2, c + dc // 2)
        neigh = (nr, nc)
        if neigh in grid_passable and mid in grid_passable:
            nbrs.append(neigh)
    adj[(r, c)] = nbrs
    print(f"Cell {(r,c)} -> neighbors: {nbrs}")
print("Adjacency building complete.\n")

# Quick reachability check (standard BFS) to verify END reachable from START
print("Checking basic reachability (ignoring no-backtracking)...")
vis = set([start])
dq = deque([start])
while dq:
    cur = dq.popleft()
    for neigh in adj[cur]:
        if neigh not in vis:
            vis.add(neigh)
            dq.append(neigh)
print(f"Reachable cells from START: {len(vis)}")
if end not in vis:
    print("ERROR: END not reachable from START under two-cell move rules with intermediate-cell check.")
    sys.exit(1)
print("END is reachable under basic BFS. Proceeding to shortest path search.\n")

# BFS with state to forbid immediate backtracking
print("Running BFS shortest-path without immediate backtracking...")
# state: (current, previous)
start_state = (start, None)
queue = deque([(start, None, [start])])
visited_states = set([start_state])
path_to_end = None

while queue:
    cur, prev, path = queue.popleft()
    if cur == end:
        path_to_end = path
        print("Reached END!")
        break
    for neigh in adj[cur]:
        # skip immediate backtracking\        
        if neigh == prev:
            continue
        state = (neigh, cur)
        if state not in visited_states:
            visited_states.add(state)
            queue.append((neigh, cur, path + [neigh]))

if path_to_end is None:
    print("ERROR: No path found under no-backtracking BFS.")
    sys.exit(1)

# Print path details
moves_count = len(path_to_end) - 1
print(f"Shortest path moves count: {moves_count}")
print(f"Full path: {path_to_end}\n")

# Extract 11th move coordinate
if len(path_to_end) <= 11:
    print(f"ERROR: Path only has {len(path_to_end)-1} moves; cannot extract 11th move.")
    sys.exit(1)
coord11 = path_to_end[11]
cell11 = cell_map[coord11]
color11 = cell11['fill_color']
print(f"Coordinate after 11th move: {coord11}")
print(f"Fill color at 11th move cell: {color11}\n")

# Save results
result = {'11th_move_coordinate': {'row': coord11[0], 'col': coord11[1]}, 'fill_color': color11, 'moves_count': moves_count}
out_file = os.path.join(dir_workspace, 'eleventh_move_result.json')
with open(out_file, 'w') as f:
    json.dump(result, f, indent=2)
print(f"Results saved to {out_file}")
```