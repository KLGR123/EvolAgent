### Development Step 14: Check START Cell’s Two-Cell Cardinal Neighbors’ Display Text and Hex Fill Colors

**Description**: Inspect workspace/grid_data.json entries for the four cardinal two-cell neighbor coordinates of the START cell by locating the coordinates (start_x±2, start_y) and (start_x, start_y±2) based on the recorded START position in workspace/start_end_coordinates.json; report each neighbor’s displayed text and 6-digit hex fill color to verify which moves from START are actually legal.

**Use Cases**:
- Autonomous warehouse navigation and rack clearance verification, checking two-bin-away grid cells from the forklift’s start position to ensure safe travel paths.
- Robotics competition maze solver, evaluating two-step cardinal moves from the entry cell to identify viable corridors and wall-free zones for path planning.
- Board game AI for a custom “two-square” mover piece, scanning cells at (x±2, y) and (x, y±2) to validate legal moves and color-coded threat areas.
- Pharmaceutical high-throughput screening grid analysis, extracting assay well labels and hex color readouts two wells away from a control sample.
- GIS-based wildfire spread modeling, sampling vegetation density and hex-coded risk levels at two-cell offsets from current fire-start coordinates.
- Pixel-art editing tool that reports text labels and 6-digit hex fill colors of pixels exactly two units away from a selected start pixel for precise color transformations.
- Automated aerial drone flight planner over farmland plots, verifying crop health indicators and color-coded NDVI values at two-field offsets from the launch point.

```
import os
import json
from pprint import pprint

# Paths to workspace files
workspace_dir = 'workspace'
grid_path = os.path.join(workspace_dir, 'grid_data.json')
coords_path = os.path.join(workspace_dir, 'start_end_coordinates.json')

print("=== STEP 1: Inspect workspace directory ===")
if os.path.isdir(workspace_dir):
    print(f"Files in '{workspace_dir}': {os.listdir(workspace_dir)}")
else:
    print(f"Error: Workspace directory '{workspace_dir}' not found.")

# STEP 2: Load and inspect start/end coordinates file
print("\n=== STEP 2: Inspect start_end_coordinates.json ===")
if not os.path.isfile(coords_path):
    print(f"Error: File '{coords_path}' does not exist.")
    exit(1)
with open(coords_path, 'r') as f:
    coords_data = json.load(f)

print("Type of coords_data:", type(coords_data))
pprint(coords_data)

# Dynamically detect START coordinates
start_x = None
start_y = None
# Case 1: coords_data is dict with 'start'
if isinstance(coords_data, dict) and 'start' in coords_data:
    start_block = coords_data['start']
    print("Found 'start' block:", start_block)
    if isinstance(start_block, dict):
        # look for numeric values
        for k, v in start_block.items():
            if isinstance(v, (int, float)):
                if start_x is None:
                    start_x = int(v)
                    print(f"Assigned start_x from key '{k}': {start_x}")
                elif start_y is None:
                    start_y = int(v)
                    print(f"Assigned start_y from key '{k}': {start_y}")
# Case 2: coords_data has keys 'start_x' and 'start_y'
elif isinstance(coords_data, dict) and 'start_x' in coords_data and 'start_y' in coords_data:
    start_x = int(coords_data['start_x'])
    start_y = int(coords_data['start_y'])
    print(f"start_x: {start_x}, start_y: {start_y}")
# Case 3: coords_data is list - find entry containing 'start'
elif isinstance(coords_data, list):
    print("coords_data is a list, examining entries for 'start'...")
    for item in coords_data:
        if isinstance(item, dict) and any('start' in str(v).lower() for v in item.values()):
            print("Potential start entry:", item)
            # extract numeric fields
            for k, v in item.items():
                if isinstance(v, (int, float)):
                    if start_x is None:
                        start_x = int(v)
                    elif start_y is None:
                        start_y = int(v)
            break

if start_x is None or start_y is None:
    print("Error: Could not determine START coordinates. Please check the JSON structure.")
    exit(1)

print(f"\nParsed START coordinates: x={start_x}, y={start_y}")

# STEP 3: Compute the four cardinal two-cell neighbors
neighbors = [
    (start_x + 2, start_y),
    (start_x - 2, start_y),
    (start_x, start_y + 2),
    (start_x, start_y - 2)
]
print("\nCandidate neighbor coordinates (x, y):")
for coord in neighbors:
    print(f"  {coord}")

# STEP 4: Load and inspect grid_data.json
print("\n=== STEP 4: Inspect grid_data.json ===")
if not os.path.isfile(grid_path):
    print(f"Error: File '{grid_path}' does not exist.")
    exit(1)
with open(grid_path, 'r') as f:
    grid_data = json.load(f)

print(f"Type of grid_data: {type(grid_data)}")
if isinstance(grid_data, list):
    print(f"Total grid entries: {len(grid_data)}")
    print("Keys of first entry:")
    pprint(list(grid_data[0].keys()))
    print("Sample entries (first 3):")
    pprint(grid_data[:3])
else:
    print("Unexpected structure for grid_data.json - expecting a list of cell entries.")
    exit(1)

# STEP 5: Find each neighbor in the grid and report its text and fill color
print("\n=== STEP 5: Report neighbor cells ===")
for (nx, ny) in neighbors:
    # search for matching entry
    match = next((cell for cell in grid_data
                  if cell.get('x') == nx and cell.get('y') == ny), None)
    if not match:
        print(f"Neighbor at ({nx},{ny}): NOT FOUND in grid_data.json")
        continue
    # Extract displayed text
    text_keys = ['text', 'value', 'displayText', 'label']
    display_text = None
    for k in text_keys:
        if k in match:
            display_text = match[k]
            break
    if display_text is None:
        display_text = "<no text key found>"
    # Extract fill color (6-digit hex)
    color = None
    # assume key 'fillColor' or nested 'fill'->'color'
    if 'fillColor' in match:
        color = match['fillColor']
    elif 'fill_color' in match:
        color = match['fill_color']
    elif 'fill' in match and isinstance(match['fill'], dict) and 'color' in match['fill']:
        color = match['fill']['color']
    # normalize to 6-digit hex
    if isinstance(color, str):
        c = color.lstrip('#')
        if len(c) == 3:
            # expand shorthand
            c = ''.join([ch*2 for ch in c])
        if len(c) == 6:
            color = c.upper()
        else:
            # too long or short
            color = color
    else:
        color = '<no fill color found>'
    print(f"Neighbor at ({nx},{ny}): text='{display_text}', color='{color}'")
```