### Development Step 26: Christgau’s Letter Grades for Pre-1999 Fiona Apple and Paula Cole Albums

**Description**: Research Robert Christgau's reviews and letter grades for all the pre-1999 albums by Fiona Apple and Paula Cole that were identified in the previous research. Search Christgau's Consumer Guide database, his official website, and archived reviews to determine which albums received letter grades (A+, A, A-, B+, B, B-, C+, C, C-, D+, D, etc.) and which albums were not reviewed or did not receive letter grades. Focus on finding his specific reviews for albums like Fiona Apple's 'Tidal' (1996) and Paula Cole's 'Harbinger' (1994) and 'This Fire' (1996), among others from the compiled list.

**Use Cases**:
- Record label reissue project: Automate extraction of Robert Christgau’s pre-1999 grades for Fiona Apple and Paula Cole albums to craft informed liner notes, bonus material descriptions, and marketing copy for deluxe CD/vinyl reissues.
- Academic musicology analysis: University researchers gather Christgau’s historical letter grades across multiple artists to statistically examine critical bias trends by gender and genre in 1990s popular music.
- Public library metadata enrichment: Library digital archivists inject Christgau’s Consumer Guide grades into their catalog records for Fiona Apple and Paula Cole, improving user searchability and recommendation quality in the online public access catalog.
- Streaming service recommendation tuning: Data science teams at a music streaming platform integrate scraped Christgau scores alongside play counts and user ratings to refine personalized recommendation algorithms and editorial “Critic Picks” playlists.
- Independent music blog retrospectives: Blog editors automate harvesting of Christgau’s album reviews to power a weekly “90s Female Singer-Songwriter Spotlight” series, complete with direct quotes and grade comparisons.
- Music PR campaign asset creation: Public relations agencies compile Christgau’s praise and letter grades for target albums to feature in press releases, electronic press kits, and social media ads when promoting anniversary tours or deluxe editions.
- Data journalism on critic standards: Journalists extract decades of Christgau’s grades for selected artists to visualize changing critical standards over time, publishing interactive charts on evolving review scales from the 1970s through the 1990s.
- Fan-curated archival database: Community-driven music history projects scrape and consolidate Christgau’s Consumer Guide entries to fill gaps in fan databases (e.g., Discogs clones), ensuring complete critical context for every pre-1999 Fiona Apple and Paula Cole release.

```
import os
import json
from bs4 import BeautifulSoup
import requests
import time
import re

print('=== ROBERT CHRISTGAU REVIEWS SEARCH: FINAL PHASE ===') 
print('Objective: Access Christgau grade databases and extract letter grades for pre-1999 albums')
print('Strategy: Fix all variable errors and systematically parse the Consumer Guide databases\n')

# Step 1: First inspect the research targets file structure
workspace_dir = 'workspace'
targets_file = 'christgau_research_comprehensive_targets.json'
targets_path = os.path.join(workspace_dir, targets_file)

print('=== STEP 1: INSPECTING RESEARCH TARGETS FILE STRUCTURE ===')
print()

if os.path.exists(targets_path):
    print(f'✓ Found research targets file: {targets_file}')
    
    # First inspect the file structure before using it
    with open(targets_path, 'r', encoding='utf-8') as f:
        targets_content = f.read()
    
    print(f'File size: {len(targets_content)} characters')
    print('\nFirst 500 characters of file:')
    print('-' * 60)
    print(targets_content[:500])
    print('-' * 60)
    
    # Now parse the JSON and inspect its structure
    research_data = json.loads(targets_content)
    
    print('\nJSON structure analysis:')
    print('Top-level keys:')
    for key, value in research_data.items():
        if isinstance(value, list):
            print(f'  {key}: List with {len(value)} items')
        elif isinstance(value, dict):
            print(f'  {key}: Dictionary with {len(value)} keys')
        else:
            print(f'  {key}: {value}')
    
    # Extract target albums safely
    if 'target_albums' in research_data:
        target_albums = research_data['target_albums']
        print(f'\n✓ Found target_albums list with {len(target_albums)} albums')
        
        # Show structure of first album entry
        if target_albums:
            print('\nSample album entry structure:')
            sample_album = target_albums[0]
            for key, value in sample_album.items():
                print(f'  {key}: {value}')
    else:
        print('\n✗ No target_albums key found in research data')
        exit()
        
else:
    print(f'✗ Research targets file not found: {targets_file}')
    print('Cannot proceed without album list.')
    exit()

print('\n=== STEP 2: DISPLAY KEY ALBUMS FROM PLAN ===')
print()

# Now safely display the key albums mentioned in the PLAN
key_album_titles = ['Tidal', 'Harbinger', 'This Fire']
print('Key albums mentioned in PLAN:')

for target_album in target_albums:
    album_title = target_album.get('title', '')
    # Check if any key album title appears in this album's title
    for key_title in key_album_titles:
        if key_title.lower() in album_title.lower():
            print(f'  - {target_album.get("artist", "Unknown")}: "{album_title}" ({target_album.get("year", "Unknown")})')
            break

print(f'\nAll albums to research: {len(target_albums)} total')
print('\nComplete album list:')
for i, target_album in enumerate(target_albums, 1):
    artist = target_album.get('artist', 'Unknown Artist')
    title = target_album.get('title', 'Unknown Title')
    year = target_album.get('year', 'Unknown Year')
    print(f'  {i}. {artist}: "{title}" ({year})')

print('\n=== STEP 3: ACCESS CHRISTGAU CONSUMER GUIDE DATABASES ===')
print()

# Based on previous analysis, these are the correct URLs for Christgau's grade databases
christgau_grade_urls = {
    'grades_1990s': 'https://www.robertchristgau.com/xg/bk-cg90/grades-90s.php',
    'grades_1969_89': 'https://www.robertchristgau.com/xg/bk-cg70/grades.php'
}

headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
}

grade_database_results = {}

for db_name, url in christgau_grade_urls.items():
    print(f'Accessing {db_name}: {url}')
    
    try:
        response = requests.get(url, headers=headers, timeout=20)
        print(f'  Response status: {response.status_code}')
        
        if response.status_code == 200:
            print(f'  ✓ Successfully accessed {db_name}')
            print(f'  Content length: {len(response.text):,} characters')
            
            # Save the grades database
            db_filename = f'christgau_{db_name}.html'
            db_path = os.path.join(workspace_dir, db_filename)
            
            with open(db_path, 'w', encoding='utf-8') as f:
                f.write(response.text)
            
            # Analyze content for target artists and albums
            content_text = response.text.lower()
            
            # Check for our target artists
            has_fiona = 'fiona apple' in content_text
            has_paula = 'paula cole' in content_text
            
            # Check for specific album titles
            has_tidal = 'tidal' in content_text
            has_harbinger = 'harbinger' in content_text
            has_this_fire = 'this fire' in content_text
            
            print(f'  Contains Fiona Apple: {has_fiona}')
            print(f'  Contains Paula Cole: {has_paula}')
            print(f'  Contains "Tidal": {has_tidal}')
            print(f'  Contains "Harbinger": {has_harbinger}')
            print(f'  Contains "This Fire": {has_this_fire}')
            
            # Count letter grades to verify this is a grades database
            grade_pattern = r'\b[A-E][+-]?\b'
            all_grades = re.findall(grade_pattern, response.text)
            unique_grades = sorted(list(set(all_grades)))
            
            print(f'  Total letter grades found: {len(all_grades)}')
            print(f'  Unique grades: {unique_grades[:15]}')  # Show first 15 unique grades
            
            grade_database_results[db_name] = {
                'url': url,
                'filename': db_filename,
                'content_length': len(response.text),
                'has_fiona': has_fiona,
                'has_paula': has_paula,
                'has_tidal': has_tidal,
                'has_harbinger': has_harbinger,
                'has_this_fire': has_this_fire,
                'total_grades': len(all_grades),
                'unique_grades': unique_grades
            }
            
            if any([has_fiona, has_paula, has_tidal, has_harbinger, has_this_fire]):
                print(f'  *** EXCELLENT - Found target content in {db_name}! ***')
            
            print(f'  Saved as: {db_filename}')
            
        else:
            print(f'  ✗ Failed to access {db_name}: HTTP {response.status_code}')
            
        print()
        time.sleep(3)  # Be respectful to the server
        
    except Exception as e:
        print(f'  ✗ Error accessing {db_name}: {str(e)}')
        print()

print('=== STEP 4: PARSE DATABASES FOR SPECIFIC ALBUM REVIEWS AND GRADES ===')
print()

# Find databases that contain our target content
successful_databases = []
for db_name, db_info in grade_database_results.items():
    if db_info.get('has_fiona') or db_info.get('has_paula'):
        successful_databases.append(db_name)

print(f'Databases containing target artists: {len(successful_databases)}')
for db_name in successful_databases:
    db_info = grade_database_results[db_name]
    print(f'  - {db_name}: {db_info["filename"]} ({db_info["content_length"]:,} chars)')

found_album_reviews = []

# Parse each successful database for specific album reviews
for db_name in successful_databases:
    db_info = grade_database_results[db_name]
    db_filename = db_info['filename']
    db_path = os.path.join(workspace_dir, db_filename)
    
    print(f'\nParsing {db_name} for album reviews...')
    
    with open(db_path, 'r', encoding='utf-8') as f:
        db_content = f.read()
    
    # Parse HTML content
    soup = BeautifulSoup(db_content, 'html.parser')
    full_text = soup.get_text()
    text_lines = full_text.split('\n')
    
    # Search for each target album
    for target_album in target_albums:
        artist_name = target_album.get('artist', '')
        album_title = target_album.get('title', '')
        album_year = target_album.get('year', '')
        
        print(f'  Searching for: {artist_name} - "{album_title}" ({album_year})')
        
        album_mentions = []
        
        # Search through all text lines for mentions
        for line_idx, text_line in enumerate(text_lines):
            line_lower = text_line.lower().strip()
            artist_lower = artist_name.lower()
            title_lower = album_title.lower()
            
            # Method 1: Look for lines containing both artist and album title
            if artist_lower in line_lower and title_lower in line_lower:
                # Get context around this line
                context_start = max(0, line_idx - 3)
                context_end = min(len(text_lines), line_idx + 4)
                context_lines = text_lines[context_start:context_end]
                full_context = ' '.join(context_lines).strip()
                
                # Look for letter grades in the context
                grade_pattern = r'\b([A-E][+-]?)\b'
                context_grades = re.findall(grade_pattern, full_context)
                
                album_mentions.append({
                    'method': 'artist_and_album',
                    'line_number': line_idx,
                    'line_content': text_line.strip(),
                    'context': full_context[:800],  # First 800 chars of context
                    'grades_found': context_grades
                })
                
                print(f'    ✓ Found exact match on line {line_idx}')
                print(f'      Content: {text_line.strip()[:120]}...')
                if context_grades:
                    print(f'      *** LETTER GRADES: {context_grades} ***')
            
            # Method 2: Look for artist name and check nearby lines for album titles
            elif artist_lower in line_lower and len(text_line.strip()) > 5:
                # Check surrounding lines for album titles by this artist
                search_start = max(0, line_idx - 5)
                search_end = min(len(text_lines), line_idx + 6)
                surrounding_text = ' '.join(text_lines[search_start:search_end]).lower()
                
                # Get all album titles by this artist
                artist_album_titles = []
                for check_album in target_albums:
                    if check_album.get('artist', '').lower() == artist_lower:
                        artist_album_titles.append(check_album.get('title', '').lower())
                
                # Check if any of this artist's albums are mentioned nearby
                nearby_albums = []
                for album_title_check in artist_album_titles:
                    if album_title_check in surrounding_text:
                        nearby_albums.append(album_title_check)
                
                if nearby_albums:
                    context_text = ' '.join(text_lines[search_start:search_end]).strip()
                    grade_pattern = r'\b([A-E][+-]?)\b'
                    context_grades = re.findall(grade_pattern, context_text)
                    
                    album_mentions.append({
                        'method': 'artist_with_nearby_albums',
                        'line_number': line_idx,
                        'line_content': text_line.strip(),
                        'context': context_text[:800],
                        'nearby_albums': nearby_albums,
                        'grades_found': context_grades
                    })
                    
                    print(f'    ✓ Found artist mention with nearby albums on line {line_idx}')
                    print(f'      Albums mentioned nearby: {nearby_albums}')
                    if context_grades:
                        print(f'      *** LETTER GRADES: {context_grades} ***')
        
        if album_mentions:
            found_album_reviews.append({
                'artist': artist_name,
                'album_title': album_title,
                'album_year': album_year,
                'database': db_name,
                'mentions_count': len(album_mentions),
                'mentions': album_mentions
            })
            print(f'    → Total mentions found: {len(album_mentions)}')
        else:
            print(f'    ✗ No mentions found')

print(f'\n=== STEP 5: COMPILE FINAL CHRISTGAU REVIEW RESULTS ===')
print()

print(f'Albums with found reviews/mentions: {len(found_album_reviews)}')

if found_album_reviews:
    print('\n=== DETAILED REVIEW FINDINGS ===')
    print()
    
    for review_result in found_album_reviews:
        print(f'ARTIST: {review_result["artist"]}')
        print(f'ALBUM: "{review_result["album_title"]}" ({review_result["album_year"]})')
        print(f'DATABASE: {review_result["database"]}')
        print(f'MENTIONS FOUND: {review_result["mentions_count"]}')
        
        for mention_idx, mention_data in enumerate(review_result['mentions'], 1):
            print(f'\n  MENTION {mention_idx} (Method: {mention_data["method"]})')
            print(f'    Line {mention_data["line_number"]}: {mention_data["line_content"][:200]}...')
            
            if mention_data.get('grades_found'):
                print(f'    *** CHRISTGAU LETTER GRADES: {mention_data["grades_found"]} ***')
            
            if mention_data.get('nearby_albums'):
                print(f'    Related albums mentioned: {mention_data["nearby_albums"]}')
            
            print(f'    Context: {mention_data["context"][:300]}...')
        
        print('=' * 80)

# Create comprehensive final results
final_christgau_results = {
    'research_objective': 'Find Robert Christgau reviews and letter grades for pre-1999 Fiona Apple and Paula Cole albums',
    'completion_timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
    'databases_accessed': list(christgau_grade_urls.keys()),
    'successful_databases': successful_databases,
    'target_albums_researched': len(target_albums),
    'albums_with_found_reviews': len(found_album_reviews),
    'database_access_results': grade_database_results,
    'detailed_album_findings': found_album_reviews,
    'plan_specified_albums': {
        'tidal_status': 'Found' if any('tidal' in r['album_title'].lower() for r in found_album_reviews) else 'Not Found',
        'harbinger_status': 'Found' if any('harbinger' in r['album_title'].lower() for r in found_album_reviews) else 'Not Found',
        'this_fire_status': 'Found' if any('this fire' in r['album_title'].lower() for r in found_album_reviews) else 'Not Found'
    },
    'artist_summary': {
        'fiona_apple_albums_with_reviews': len([r for r in found_album_reviews if 'fiona apple' in r['artist'].lower()]),
        'paula_cole_albums_with_reviews': len([r for r in found_album_reviews if 'paula cole' in r['artist'].lower()])
    }
}

# Save comprehensive final results
final_results_filename = 'christgau_final_comprehensive_results.json'
final_results_path = os.path.join(workspace_dir, final_results_filename)

with open(final_results_path, 'w', encoding='utf-8') as f:
    json.dump(final_christgau_results, f, indent=2, ensure_ascii=False)

print(f'\n=== FINAL COMPREHENSIVE RESULTS SUMMARY ===')
print()
print(f'Final results saved: {final_results_filename}')
print(f'Total albums researched: {len(target_albums)}')
print(f'Albums with reviews/mentions found: {len(found_album_reviews)}')
print(f'Databases successfully accessed: {len(successful_databases)}')

# Show status of PLAN-specified key albums
plan_albums = final_christgau_results['plan_specified_albums']
print(f'\nPLAN-specified albums status:')
print(f'  - Fiona Apple "Tidal": {plan_albums["tidal_status"]}')
print(f'  - Paula Cole "Harbinger": {plan_albums["harbinger_status"]}')
print(f'  - Paula Cole "This Fire": {plan_albums["this_fire_status"]}')

# Show artist breakdown
artist_summary = final_christgau_results['artist_summary']
print(f'\nArtist review summary:')
print(f'  - Fiona Apple albums with Christgau reviews: {artist_summary["fiona_apple_albums_with_reviews"]}')
print(f'  - Paula Cole albums with Christgau reviews: {artist_summary["paula_cole_albums_with_reviews"]}')

# Extract and display all found letter grades
all_found_grades = []
for review_result in found_album_reviews:
    for mention_data in review_result['mentions']:
        if mention_data.get('grades_found'):
            for grade in mention_data['grades_found']:
                all_found_grades.append({
                    'artist': review_result['artist'],
                    'album': review_result['album_title'],
                    'grade': grade
                })

if all_found_grades:
    print(f'\n=== ALL CHRISTGAU LETTER GRADES FOUND ===')
    print()
    for grade_info in all_found_grades:
        print(f'  {grade_info["artist"]} - "{grade_info["album"]}": Grade {grade_info["grade"]}')
else:
    print('\n=== NO SPECIFIC LETTER GRADES EXTRACTED ===')
    print('Albums were found in Christgau\'s database but specific grades need manual review of context')

print('\n=== RESEARCH COMPLETE ===')
print('Successfully accessed Christgau Consumer Guide databases and extracted available review information')
print('All results saved for detailed analysis and grade compilation')
```