### Development Step 23: BFS shortest path from START to END: retrieve 11th move cellâ€™s hex fill_color

**Description**: Perform a breadth-first search on workspace/adjacency_cardinal.json starting from the START coordinate from workspace/start_end_coordinates.json to find the shortest path to the END coordinate; then identify the coordinate at index 11 in the resulting path (representing the landing cell after the eleventh two-cell move) and retrieve its 6-digit hex fill_color from workspace/grid_data.json.

**Use Cases**:
- Indoor warehouse drone navigation path mapping and waypoint color-coding for automated inventory scanning
- Fire evacuation planning in commercial buildings with shortest-route computation and checkpoint highlighting
- Agricultural field robot routing on crop grids with milestone cell identification for targeted treatment
- Interactive museum guide app computing visitor paths and exhibit highlight colors on floor maps
- Game level design tool generating NPC patrol paths on tile maps and extracting waypoint marker colors
- GIS-based flood evacuation modeling finding safe routes and color-coded terrain cells at critical waypoints
- Data center rack cable routing optimization with shortest-path analysis and junction node color annotation
- Automated vacuum cleaning robot route planning in home floor plans with segment color-coded cleaning zones

```
import os
import json
from collections import deque

# Step 1: Dynamically locate the workspace directory (handles "workspace" or "workspace_<uuid>")
cwd = os.getcwd()
candidates = [d for d in os.listdir(cwd) if os.path.isdir(d) and d.startswith('workspace')]
if not candidates:
    raise FileNotFoundError(f"No workspace directory found in {cwd}")
workspace_dir = os.path.join(cwd, 'workspace') if 'workspace' in candidates else os.path.join(cwd, candidates[0])
print(f"Using workspace directory: {workspace_dir}\n")
print(f"Contents: {os.listdir(workspace_dir)}\n")

# Step 2: Load and parse start/end coordinates
se_path = os.path.join(workspace_dir, 'start_end_coordinates.json')
print(f"Loading START/END from: {se_path}")
with open(se_path, 'r') as f:
    se = json.load(f)
print(f"Raw start/end data: {se}\n")

# Extract START
if 'START' in se:
    val = se['START']
elif 'start' in se:
    val = se['start']
else:
    raise KeyError("Missing 'START' or 'start' in JSON")
if isinstance(val, dict) and 'row' in val and 'col' in val:
    start = (int(val['row']), int(val['col']))
elif isinstance(val, (list, tuple)) and len(val) == 2:
    start = (int(val[0]), int(val[1]))
else:
    raise ValueError(f"Unrecognized START format: {val}")

# Extract END
if 'END' in se:
    val = se['END']
elif 'end' in se:
    val = se['end']
else:
    raise KeyError("Missing 'END' or 'end' in JSON")
if isinstance(val, dict) and 'row' in val and 'col' in val:
    end = (int(val['row']), int(val['col']))
elif isinstance(val, (list, tuple)) and len(val) == 2:
    end = (int(val[0]), int(val[1]))
else:
    raise ValueError(f"Unrecognized END format: {val}")

print(f"Parsed START: {start}")
print(f"Parsed END:   {end}\n")

# Step 3: Load adjacency graph
adj_path = os.path.join(workspace_dir, 'adjacency_cardinal.json')
print(f"Loading adjacency graph from: {adj_path}")
with open(adj_path, 'r') as f:
    adj_raw = json.load(f)
print(f"Total raw nodes: {len(adj_raw)}\nSample entry: {list(adj_raw.items())[:2]}\n")

# Build tuple-based adjacency list
adj = {}
for key_str, nbrs in adj_raw.items():
    r, c = map(int, key_str.split(','))
    node = (r, c)
    parsed = []
    for n in nbrs:
        if isinstance(n, str):
            rr, cc = map(int, n.split(','))
            parsed.append((rr, cc))
        elif isinstance(n, (list, tuple)) and len(n) == 2:
            parsed.append((int(n[0]), int(n[1])))
        else:
            raise ValueError(f"Bad neighbor format: {n}")
    adj[node] = parsed
print(f"Built adjacency list with {len(adj)} nodes.\n")

# Step 4: BFS shortest path
def bfs_shortest_path(adjacency, start_coord, end_coord):
    print("Starting BFS (deque imported at top)")
    queue = deque([start_coord])
    visited = {start_coord}
    parent = {start_coord: None}
    while queue:
        curr = queue.popleft()
        if curr == end_coord:
            print("Reached end in BFS")
            break
        for nb in adjacency.get(curr, []):
            if nb not in visited:
                visited.add(nb)
                parent[nb] = curr
                queue.append(nb)
    if end_coord not in parent:
        print(f"No path from {start_coord} to {end_coord}")
        return []
    # Reconstruct path
    path = []
    node = end_coord
    while node is not None:
        path.append(node)
        node = parent[node]
    path.reverse()
    return path

print(f"Performing BFS from {start} to {end}...\n")
path = bfs_shortest_path(adj, start, end)
print(f"Path length: {len(path)}")
print(f"First 12 coords: {path[:12]}\n")

# Step 5: Get the coordinate at index 11
index = 11
if len(path) <= index:
    raise IndexError(f"Path length {len(path)} is too short for index {index}")
landing = path[index]
print(f"Coordinate at index {index}: {landing}\n")

# Step 6: Load grid_data.json
grid_path = os.path.join(workspace_dir, 'grid_data.json')
print(f"Loading grid data from: {grid_path}")
with open(grid_path, 'r') as f:
    grid = json.load(f)
print(f"Total grid entries: {len(grid)}\nSample entry: {grid[0]}\n")

# Step 7: Find the 6-digit hex fill_color for landing cell
fill_color = None
for cell in grid:
    if 'row' in cell and 'col' in cell:
        coord = (int(cell['row']), int(cell['col']))
    elif 'coordinate' in cell and isinstance(cell['coordinate'], (list, tuple)):
        coord = (int(cell['coordinate'][0]), int(cell['coordinate'][1]))
    else:
        continue
    if coord == landing:
        fill_color = cell.get('fill_color') or cell.get('color')
        break
if not fill_color:
    raise ValueError(f"No fill_color found for {landing}")
print(f"Found fill_color for {landing}: {fill_color}\n")

# Step 8: Save result to workspace
result = {
    'landing_index': index,
    'landing_coordinate': list(landing),
    'fill_color': fill_color
}
out_path = os.path.join(workspace_dir, 'landing_cell_and_color.json')
with open(out_path, 'w') as f:
    json.dump(result, f, indent=2)
print(f"Result written to: {out_path}\n")

print("===== FINAL ANSWER =====")
print(f"Index: {index}")
print(f"Landing coordinate: {landing}")
print(f"fill_color: {fill_color}")
print("========================")
```