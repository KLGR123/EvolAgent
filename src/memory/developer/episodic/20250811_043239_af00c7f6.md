### Development Step 2: **Title:**  
Extract Unique Food Items and Identify Non-Duplicates from Excel Food Inventory List

**Description**: Parse and analyze the attached Excel file data/gaia/2023/validation/9b54f9d9-35ee-4a14-b62f-d130ea00317f/food_duplicates.xls to extract all food items listed in the spreadsheet. Identify the complete inventory of food names and examine for any duplicates or variations of the same food item appearing under different names. Create a comprehensive list of all unique food items and identify which single food item appears only once without any duplicate entries or alternative naming variations.

**Use Cases**:
- Restaurant chain menu standardization and duplicate dish detection to streamline ingredient procurement and reduce inventory redundancies
- Food safety compliance audits in hospital kitchens by identifying duplicate or mislabeled food items in inventory records
- Nutrition research projects analyzing dietary survey data to ensure unique food item reporting and prevent double-counting of similar foods
- Supermarket product catalog cleaning to merge semantically identical food products listed under different regional names
- Automated quality assurance for meal delivery startups, detecting and consolidating duplicate meal entries in supplier spreadsheets
- Agricultural supply chain data harmonization, ensuring consistent crop naming across international partners for accurate yield tracking
- Food labeling regulatory review, identifying and flagging alternative names for allergens to ensure comprehensive consumer warnings
- Culinary school curriculum planning, analyzing course ingredient lists to avoid repetition and ensure diverse food exposure for students

```
import os
import pandas as pd
import json
from collections import Counter

# The path to the Excel file to be analyzed
xls_path = "data/gaia/2023/validation/9b54f9d9-35ee-4a14-b62f-d130ea00317f/food_duplicates.xls"

print("=== FOOD DUPLICATES ANALYSIS - SEMANTIC DUPLICATE DETECTION ===")
print(f"Analyzing file: {xls_path}")

# Load the Excel file with pandas
df = pd.read_excel(xls_path)
print(f"Dataset shape: {df.shape}")
print(f"Column names: {list(df.columns)}")

# Extract all food items from all columns (treating each cell as a food item)
all_food_items = []
for col in df.columns:
    # Get all values from this column (including the column header itself)
    food_values = [col] + df[col].dropna().tolist()
    for item in food_values:
        item_str = str(item).strip().lower()  # Convert to lowercase for comparison
        if item_str:  # Only add non-empty items
            all_food_items.append(item_str)

print(f"\nTotal food items extracted: {len(all_food_items)}")

# Define known food synonyms and variations
food_synonyms = {
    # Vegetables
    'zucchini': ['courgette'],
    'eggplant': ['aubergine'],
    'bell pepper': ['capsicum'],
    'beet': ['beetroot'],
    'cilantro': ['coriander'],
    'arugula': ['rocket'],
    'broccoli rabe': ['rapini'],
    
    # Legumes
    'chickpea': ['garbanzo bean'],
    
    # Fruits
    'avocado': ['alligator pear'],
    
    # Meat
    'beef': ['cow meat'],
    'veal': ['calf meat'],
    'pigeon': ['squab'],
    'foie gras': ['fatty goose liver'],
    
    # Seafood
    'crawdad': ['mudbug'],
    
    # Grains/Cereals
    'rice krispies': ['puffed rice'],
    'congee': ['rice porridge'],
    
    # Sweets/Desserts
    'cotton candy': ['candy floss'],
    'confectioner\'s sugar': ['icing sugar'],
    'jelly donut': ['jam doughnut'],
    'cupcake': ['fairy cake'],
    
    # Beverages
    'soda': ['pop'],
    'coffee': ['java'],
    
    # Dried fruits
    'dried cranberries': ['craisins'],
    'golden raisin': ['sultana'],
    
    # Sandwiches
    'sandwich': ['hoagie'],
    
    # Potatoes
    'fries': ['chips'],
    
    # Pasta
    'angel hair pasta': ['capellini'],
    
    # Dairy
    'soy curds': ['tofu'],
    
    # Other
    'fleur de sel': ['salt'],
    'candy': ['bonbon']
}

# Create a reverse mapping for easier lookup
synonym_groups = {}
for main_term, synonyms in food_synonyms.items():
    # Create a group with the main term and all its synonyms
    group = [main_term] + synonyms
    for term in group:
        synonym_groups[term] = tuple(sorted(group))  # Use tuple for hashability

print(f"\nDefined {len(food_synonyms)} synonym groups")
print("Synonym groups:")
for main_term, synonyms in food_synonyms.items():
    print(f"  {main_term} = {synonyms}")

# Group food items by their semantic equivalence
print("\n=== SEMANTIC GROUPING ANALYSIS ===")
semantic_groups = {}
ungrouped_items = []

for item in all_food_items:
    if item in synonym_groups:
        group_key = synonym_groups[item]
        if group_key not in semantic_groups:
            semantic_groups[group_key] = []
        semantic_groups[group_key].append(item)
    else:
        ungrouped_items.append(item)

print(f"Found {len(semantic_groups)} semantic groups")
print(f"Found {len(ungrouped_items)} ungrouped items")

# Analyze semantic groups
print("\n=== SEMANTIC GROUPS WITH DUPLICATES ===")
groups_with_duplicates = []
groups_without_duplicates = []

for group_key, items in semantic_groups.items():
    item_count = len(items)
    unique_items = list(set(items))  # Remove exact duplicates within the group
    unique_count = len(unique_items)
    
    print(f"\nGroup: {list(group_key)}")
    print(f"  Items found: {items} (total: {item_count})")
    print(f"  Unique items: {unique_items} (count: {unique_count})")
    
    if unique_count > 1:
        groups_with_duplicates.append((group_key, unique_items))
        print(f"  -> HAS SEMANTIC DUPLICATES")
    else:
        groups_without_duplicates.append((group_key, unique_items))
        print(f"  -> NO DUPLICATES (only one variant found)")

# Count occurrences of ungrouped items
print("\n=== UNGROUPED ITEMS FREQUENCY ===")
ungrouped_counter = Counter(ungrouped_items)
ungrouped_appearing_once = [item for item, count in ungrouped_counter.items() if count == 1]
ungrouped_duplicates = [item for item, count in ungrouped_counter.items() if count > 1]

print(f"Ungrouped items appearing only once: {len(ungrouped_appearing_once)}")
for item in ungrouped_appearing_once:
    print(f"  - {item}")

print(f"\nUngrouped items with duplicates: {len(ungrouped_duplicates)}")
for item in ungrouped_duplicates:
    count = ungrouped_counter[item]
    print(f"  - {item}: {count} occurrences")

# Find items that truly appear only once (no semantic duplicates)
print("\n" + "="*60)
print("FINAL ANALYSIS: ITEMS APPEARING ONLY ONCE")
print("="*60)

true_unique_items = []

# Add ungrouped items that appear only once
true_unique_items.extend(ungrouped_appearing_once)

# Add items from semantic groups that have no duplicates
for group_key, unique_items in groups_without_duplicates:
    true_unique_items.extend(unique_items)

print(f"\nItems that truly appear only once (no semantic duplicates): {len(true_unique_items)}")
for item in sorted(true_unique_items):
    print(f"  - {item}")

# Summary of duplicates found
print("\n=== SUMMARY OF DUPLICATES FOUND ===")
print(f"Semantic groups with duplicates: {len(groups_with_duplicates)}")
for group_key, unique_items in groups_with_duplicates:
    print(f"  Group {list(group_key)}: {unique_items}")

print(f"\nUngrouped exact duplicates: {len(ungrouped_duplicates)}")
for item in ungrouped_duplicates:
    count = ungrouped_counter[item]
    print(f"  {item}: {count} occurrences")

# Create comprehensive analysis report
analysis_report = {
    'dataset_info': {
        'file_path': xls_path,
        'shape': df.shape,
        'total_food_items': len(all_food_items)
    },
    'semantic_analysis': {
        'synonym_groups_defined': len(food_synonyms),
        'semantic_groups_found': len(semantic_groups),
        'ungrouped_items': len(ungrouped_items)
    },
    'duplicate_analysis': {
        'semantic_groups_with_duplicates': len(groups_with_duplicates),
        'ungrouped_exact_duplicates': len(ungrouped_duplicates),
        'items_appearing_only_once': len(true_unique_items)
    },
    'true_unique_items': sorted(true_unique_items),
    'semantic_duplicates': {
        group_key[0]: unique_items for group_key, unique_items in groups_with_duplicates
    },
    'exact_duplicates': {
        item: ungrouped_counter[item] for item in ungrouped_duplicates
    }
}

# Save comprehensive analysis
os.makedirs('workspace', exist_ok=True)
with open('workspace/semantic_food_analysis.json', 'w') as f:
    json.dump(analysis_report, f, indent=2)

print(f"\nComprehensive semantic analysis saved to: workspace/semantic_food_analysis.json")

# Save summary report
with open('workspace/final_food_analysis.txt', 'w') as f:
    f.write("FOOD DUPLICATES - SEMANTIC ANALYSIS RESULTS\n")
    f.write("="*60 + "\n\n")
    f.write(f"Dataset: {os.path.basename(xls_path)}\n")
    f.write(f"Total food items: {len(all_food_items)}\n")
    f.write(f"Semantic groups with duplicates: {len(groups_with_duplicates)}\n")
    f.write(f"Ungrouped exact duplicates: {len(ungrouped_duplicates)}\n")
    f.write(f"Items appearing only once: {len(true_unique_items)}\n\n")
    
    f.write("ITEMS APPEARING ONLY ONCE:\n")
    for item in sorted(true_unique_items):
        f.write(f"  - {item}\n")
    
    f.write(f"\nSEMANTIC DUPLICATES FOUND:\n")
    for group_key, unique_items in groups_with_duplicates:
        f.write(f"  {list(group_key)}: {unique_items}\n")
    
    f.write(f"\nEXACT DUPLICATES FOUND:\n")
    for item in ungrouped_duplicates:
        count = ungrouped_counter[item]
        f.write(f"  {item}: {count} occurrences\n")

print(f"Final analysis summary saved to: workspace/final_food_analysis.txt")

print("\n*** SEMANTIC ANALYSIS COMPLETE ***")
print(f"Found {len(groups_with_duplicates)} semantic duplicate groups")
print(f"Found {len(ungrouped_duplicates)} exact duplicate items")
print(f"Found {len(true_unique_items)} items that truly appear only once")

if len(true_unique_items) == 1:
    print(f"\n*** ANSWER: The single food item that appears only once is: '{true_unique_items[0]}' ***")
elif len(true_unique_items) == 0:
    print("\n*** All food items have duplicates or variations ***")
else:
    print(f"\n*** Multiple items ({len(true_unique_items)}) appear only once ***")
```