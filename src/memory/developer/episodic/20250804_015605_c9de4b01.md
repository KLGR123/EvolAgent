### Development Step 18: Generate two-cell cardinal adjacency list from grid_data.json excluding blue (‘0099FF’) cells

**Description**: Generate an adjacency list of legal cardinal two-cell moves by reading workspace/grid_data.json and including edges only when the target cell’s fill_color is not '0099FF'; save the adjacency list to workspace/adjacency_cardinal.json.

**Use Cases**:
- Autonomous warehouse robotics path planning: generate adjacency of storage aisle grid from workspace/grid_data.json, excluding cells colored ‘0099FF’ (blocked areas), to optimize AGV routes in real time.
- Tile-based video game NPC movement: build adjacency list of walkable map cells, filtering out water or hazard tiles (fill_color ‘0099FF’), for A* pathfinding and AI behavior.
- Urban utility network planning: derive adjacency of city-block grid intersections, ignoring river or canal cells marked in blue, to design underground cable and pipeline layouts.
- Agricultural field irrigation sequencing: map adjacent crop-plot cells while excluding waterlogged zones colored ‘0099FF’, enabling precise routing of irrigation equipment across fields.
- Flood evacuation route modeling: compute safe pedestrian and vehicle paths on a municipal grid by omitting inundated cells (fill_color ‘0099FF’), to support emergency response planning.
- Automated floor-cleaning robot navigation: generate adjacency of building-floor grid excluding no-go zones marked in blue, for efficient coverage planning and collision avoidance.
- Manufacturing plant AGV routing: build adjacency of factory-floor grid, filtering out safety buffer zones around heavy machinery (fill_color ‘0099FF’), to streamline material transport workflows.
- Microfluidic device simulation: create adjacency list of channel segments in a lab-on-chip grid, excluding blocked or inactive channels colored blue, to model fluid flow and reagent mixing.

```
import os
import json

# Step 1: Inspect workspace and grid_data.json
workspace_dir = 'workspace'
grid_path = os.path.join(workspace_dir, 'grid_data.json')
print(f"Workspace directory: {workspace_dir}")
if not os.path.isdir(workspace_dir):
    print("Error: workspace directory does not exist.")
else:
    print(f"Contents: {os.listdir(workspace_dir)}")

# Check for grid_data.json
if not os.path.exists(grid_path):
    print(f"Error: '{grid_path}' not found.")
    exit(1)

# Preview the first part of the file to understand its structure
print(f"\n--- Preview of '{grid_path}' ---")
with open(grid_path, 'r') as f:
    preview_text = f.read(500)
    print(preview_text)

# Load the JSON fully
with open(grid_path, 'r') as f:
    grid_data = json.load(f)

# Determine structure
print("\n--- Structure of loaded JSON ---")
print(f"Type of top-level object: {type(grid_data)}")
if isinstance(grid_data, dict):
    print(f"Top-level keys: {list(grid_data.keys())}")
    # Try to locate the list of cells
    # Common key names might be 'cells', 'data', 'grid', etc.
    for candidate in ['cells', 'data', 'grid', 'cells_data', 'cellsList']:
        if candidate in grid_data and isinstance(grid_data[candidate], list):
            cells_list = grid_data[candidate]
            print(f"Using '{candidate}' as cell list with {len(cells_list)} entries.")
            break
    else:
        # If no candidate key found, but dict might itself be a mapping of coords->cell
        # or the JSON might already be a list disguised as a dict
        # Fallback: if all values are similar-length lists, not helpful
        print("Could not find a 'cells' list in the dict; trying to interpret the entire dict as a list of cells.")
        # Sometimes the JSON is actually a list saved as a dict with numeric keys
        try:
            # Try to build a list if keys are numeric strings
            numeric_keys = sorted(grid_data.keys(), key=lambda k: int(k))
            test_entry = grid_data[numeric_keys[0]]
            if isinstance(test_entry, dict):
                cells_list = [grid_data[k] for k in numeric_keys]
                print(f"Reconstructed cell list from numeric keys: {len(cells_list)} entries.")
            else:
                raise ValueError
        except Exception:
            print("Fatal: Cannot interpret the JSON as a list of cell objects.")
            exit(1)
elif isinstance(grid_data, list):
    cells_list = grid_data
    print(f"Top-level is a list of {len(cells_list)} cell entries.")
else:
    print("Fatal: Unsupported JSON structure for grid data.")
    exit(1)

# Preview one cell to see its keys/fields
print("\n--- Preview of one cell entry ---")
first = cells_list[0]
print(f"Type: {type(first)}")
if isinstance(first, dict):
    print(f"Keys: {list(first.keys())}")
    print(f"Sample entry: {first}")
else:
    print(f"Unexpected cell entry type: {type(first)}")
    exit(1)

# Step 2: Build mapping from (row, col) -> cell data
print("\n--- Building cell mapping ---")
cell_map = {}  # key: (row, col)
missing_coords = []
for cell in cells_list:
    if 'row' in cell and 'col' in cell:
        coord = (cell['row'], cell['col'])
        cell_map[coord] = cell
    else:
        missing_coords.append(cell)
if missing_coords:
    print(f"Warning: {len(missing_coords)} cells missing 'row' or 'col' and will be skipped.")
print(f"Total mapped cells: {len(cell_map)}")

# Step 3: Generate adjacency list for cardinal moves
print("\n--- Generating adjacency list for cardinal moves ---")
adjacency = {}
directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # up, down, left, right
for coord, cell in cell_map.items():
    row, col = coord
    key = f"{row},{col}"
    adjacency[key] = []
    for dr, dc in directions:
        nbr = (row + dr, col + dc)
        if nbr in cell_map:
            nbr_cell = cell_map[nbr]
            # Only include if neighbor's fill_color is not '0099FF'
            fill = nbr_cell.get('fill_color')
            if fill != '0099FF':
                adjacency[key].append(f"{nbr[0]},{nbr[1]}")
                print(f"Edge from {key} -> {nbr[0]},{nbr[1]} (fill_color={fill})")
            else:
                print(f"Skipping neighbor {nbr[0]},{nbr[1]} because fill_color is '0099FF'")
        else:
            # No cell at that neighbor coordinate
            pass

# Step 4: Save adjacency list
out_path = os.path.join(workspace_dir, 'adjacency_cardinal.json')
with open(out_path, 'w') as f:
    json.dump(adjacency, f, indent=2)
print(f"\nSaved adjacency list to: {out_path}")

# Summary
total_nodes = len(adjacency)
total_edges = sum(len(v) for v in adjacency.values())
print(f"Total nodes in adjacency list: {total_nodes}")
print(f"Total directed edges: {total_edges}")
```