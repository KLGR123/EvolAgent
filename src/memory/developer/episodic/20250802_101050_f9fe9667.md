### Development Step 6: Compile US Presidents' Birth Cities, States, and Coordinates into workspace/presidential_birthplaces.json

**Description**: Collect a complete list of all United States presidents with their official birth city names and state names, then obtain the geographic coordinates (longitude and latitude) for each birth city using authoritative sources such as official presidential biographies or Wikipedia infoboxes. Save the results in a structured format (e.g., CSV or JSON) at workspace/presidential_birthplaces.json.

**Use Cases**:
- Interactive historical map for an education platform showing the geographic distribution of U.S. presidents’ birthplaces and enabling students to explore regional patterns.
- Political science research analysis correlating presidential birth regions with their voting demographics and policy decisions over different centuries.
- Travel itinerary generator for tour companies designing a “Presidential Birthplace Road Trip,” complete with driving directions and nearby attractions.
- Data journalism visualization that plots presidential birthplaces on a time‐lapse map to illustrate shifts in leadership origins across U.S. history.
- Genealogy platform integration that automatically tags presidential ancestors’ hometowns on family trees using precise latitude and longitude.
- Mobile trivia app development where users are quizzed on identifying U.S. presidents based on interactive map pins of their birth cities.
- GIS layer creation for cultural heritage organizations to highlight clusters of presidential birthplaces in regional planning and preservation projects.
- Automated enrichment of a historical database by appending exact coordinates to each president’s biography for downstream analytics and mapping.

```
import os
import re
import time
import json
import requests
from bs4 import BeautifulSoup, NavigableString
from bs4.element import Tag
from geopy.geocoders import Nominatim

# Ensure workspace directory exists
workspace = 'workspace'
os.makedirs(workspace, exist_ok=True)

# 1. Load or fetch the main list of presidents page
list_html_path = os.path.join(workspace, 'presidents_list.html')
if os.path.exists(list_html_path):
    print(f"Loading cached HTML from {list_html_path}")
    with open(list_html_path, 'r', encoding='utf-8') as f:
        list_html = f.read()
else:
    list_url = 'https://en.wikipedia.org/wiki/List_of_presidents_of_the_United_States'
    print(f"Fetching presidents list: {list_url}")
    resp = requests.get(list_url)
    resp.raise_for_status()
    list_html = resp.text
    with open(list_html_path, 'w', encoding='utf-8') as f:
        f.write(list_html)
    print(f"Saved HTML to {list_html_path}")

# 2. Parse the table of presidents
soup = BeautifulSoup(list_html, 'html.parser')
table = soup.find('table', class_='wikitable')
rows = table.find_all('tr')[1:]
print(f"Found {len(rows)} presidents in table")

# 3. Collect each president's name and individual page URL
presidents = []
for row in rows:
    cells = row.find_all('td')
    if len(cells) < 2:
        continue
    link = cells[1].find('a', href=True)
    if not link:
        continue
    name = link.get_text(strip=True)
    page_url = 'https://en.wikipedia.org' + link['href']
    presidents.append({'name': name, 'url': page_url})
print(f"Collected {len(presidents)} president pages to process")

# 4. Initialize geolocator
geolocator = Nominatim(user_agent='presidential_birth_locator')
results = []

# 5. Process each president
for idx, pres in enumerate(presidents, start=1):
    name = pres['name']
    url = pres['url']
    print(f"\n[{idx}/{len(presidents)}] {name}\nFetching: {url}")
    page_resp = requests.get(url)
    page_resp.raise_for_status()
    page_soup = BeautifulSoup(page_resp.text, 'html.parser')
    time.sleep(1)

    # 6. Extract birthplace string
    birth_place = ''
    # Try span.birthplace first
    bp_span = page_soup.select_one('span.birthplace')
    if bp_span and bp_span.get_text(strip=True):
        birth_place = bp_span.get_text(strip=True)
        print(f"  Found span.birthplace: '{birth_place}'")
    else:
        # Fallback: find the 'Born' row in the infobox
        infobox = page_soup.find('table', class_=lambda c: c and 'infobox' in c)
        if infobox:
            for tr in infobox.find_all('tr'):
                th = tr.find('th')
                if th and th.get_text(strip=True).startswith('Born'):
                    td = tr.find('td')
                    if td:
                        # locate the first <br> inside td
                        contents = td.contents
                        br_index = next((i for i, el in enumerate(contents)
                                         if isinstance(el, Tag) and el.name == 'br'), None)
                        if br_index is not None:
                            parts = []
                            for el in contents[br_index+1:]:
                                # collect only <a> text and plain text (no dates)
                                if isinstance(el, Tag) and el.name == 'a':
                                    parts.append(el.get_text(strip=True))
                                elif isinstance(el, NavigableString):
                                    txt = el.strip()
                                    # skip parentheses and citation markers
                                    if txt and not txt.startswith('(') and not txt.startswith('['):
                                        parts.append(txt)
                            raw = ''.join(parts)
                            raw = re.sub(r'\s+', ' ', raw).strip()
                            birth_place = raw
                            print(f"  Fallback Born->raw tokens: '{birth_place}'")
                    break
    if not birth_place:
        print(f"  Warning: Could not extract birthplace for {name}")

    # 7. Clean up birth_place: remove parentheticals and trailing country markers
    # remove any parentheses
    birth_clean = re.sub(r'\([^)]*\)', '', birth_place).strip()
    # split tokens by comma
    tokens = [t.strip() for t in birth_clean.split(',') if t.strip()]
    # pop trailing tokens that are countries/historical areas
    unwanted = re.compile(r'^(British America|British\xa0America|United States|U\.?S\.?A?\.?|USA)$', re.I)
    while tokens and unwanted.match(tokens[-1]):
        tokens.pop()
    birth_clean = ', '.join(tokens)
    print(f"  Cleaned birthplace: '{birth_clean}'")

    # 8. Derive city and state from tokens
    city = tokens[0] if len(tokens) >= 1 else ''
    state = tokens[1] if len(tokens) >= 2 else ''
    print(f"  Parsed city='{city}', state='{state}'")

    # 9. Geocode: first try full cleaned place, then fallback to city+state
    latitude = longitude = None
    if birth_clean:
        query_full = birth_clean + ", USA"
        print(f"  Geocoding full: '{query_full}'")
        try:
            loc = geolocator.geocode(query_full, timeout=10)
            time.sleep(1)
            if loc:
                latitude, longitude = loc.latitude, loc.longitude
                print(f"   -> Got coords: ({latitude}, {longitude})")
            else:
                # fallback to city/state only
                if city and state:
                    query_cs = f"{city}, {state}, USA"
                    print(f"  Fallback geocoding: '{query_cs}'")
                    loc2 = geolocator.geocode(query_cs, timeout=10)
                    time.sleep(1)
                    if loc2:
                        latitude, longitude = loc2.latitude, loc2.longitude
                        print(f"   -> Fallback coords: ({latitude}, {longitude})")
        except Exception as e:
            print(f"   -> Error during geocoding: {e}")

    # 10. Record result
    entry = {
        'name': name,
        'birth_city': city,
        'birth_state': state,
        'latitude': latitude,
        'longitude': longitude
    }
    print(f"  Recorded: {entry}")
    results.append(entry)

# 11. Save all results
out_path = os.path.join(workspace, 'presidential_birthplaces.json')
with open(out_path, 'w', encoding='utf-8') as f:
    json.dump(results, f, indent=2)
print(f"\nFinished: saved {len(results)} records to {out_path}")
```