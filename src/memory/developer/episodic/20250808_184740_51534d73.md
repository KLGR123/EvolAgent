### Development Step 9: Sort and Process Array with C++ Quicksort: Return Sum of 3rd and 5th Sorted Integers

**Description**: Compile the C++ quicksort code from workspace/quicksort.cpp and execute it against the integer array [35, 12, 8, 99, 21, 5] to sort the array, then calculate and return the sum of the third and fifth integers in the sorted result.

**Use Cases**:
- Automated grading system for computer science courses, where student-submitted arrays are sorted and specific elements are summed to verify algorithm correctness
- Quality control in manufacturing, where sensor readings are sorted and the sum of key percentile values is used to detect anomalies in product batches
- Sports analytics dashboard that processes player statistics, sorts performance metrics, and calculates combined scores for ranking or scouting purposes
- Medical research data pipeline that sorts patient biomarker values and computes sums of specific ranked results for cohort analysis
- Logistics optimization tool that sorts delivery times and uses the sum of selected delivery durations to identify bottlenecks in the supply chain
- Financial risk assessment application that sorts transaction amounts and sums particular order statistics to evaluate exposure or outlier impact
- Automated test suite for embedded systems, where output arrays are sorted and the sum of designated elements is used as a checksum for validation
- Educational app for teaching sorting algorithms, providing step-by-step execution and calculating the sum of specific sorted elements as interactive exercises

```
import os
import subprocess
import tempfile

print("=== COMPILING AND EXECUTING C++ QUICKSORT ===")
print("Task: Compile quicksort.cpp and test with array [35, 12, 8, 99, 21, 5]")
print("Goal: Calculate sum of 3rd and 5th elements in sorted result\n")

# First, let's inspect the downloaded C++ file
cpp_file = 'workspace/quicksort.cpp'
if os.path.exists(cpp_file):
    print(f"Found C++ file: {cpp_file}")
    
    with open(cpp_file, 'r', encoding='utf-8') as f:
        cpp_content = f.read()
    
    print(f"File size: {len(cpp_content)} characters")
    print("\n=== INSPECTING C++ CODE STRUCTURE ===")
    
    lines = cpp_content.split('\n')
    print(f"Total lines: {len(lines)}")
    
    # Show first 15 lines to understand the structure
    print("\nFirst 15 lines:")
    for i, line in enumerate(lines[:15], 1):
        print(f"  {i:2d}: {line}")
    
    # Check if it has a main function
    has_main = 'int main(' in cpp_content or 'main(' in cpp_content
    print(f"\nHas main function: {has_main}")
    
    # Look for key components
    has_includes = '#include' in cpp_content
    has_templates = 'template' in cpp_content
    has_quicksort_func = 'quicksort(' in cpp_content
    
    print(f"Has includes: {has_includes}")
    print(f"Has templates: {has_templates}")
    print(f"Has quicksort function: {has_quicksort_func}")
    
    # Since this appears to be a library implementation without main(),
    # I need to create a test program that uses it
    print("\n=== CREATING TEST PROGRAM ===")
    
    test_program = '''
#include <iostream>
#include <vector>
#include <algorithm>

''' + cpp_content + '''

int main() {
    std::vector<int> arr = {35, 12, 8, 99, 21, 5};
    
    std::cout << "Original array: ";
    for (int x : arr) {
        std::cout << x << " ";
    }
    std::cout << std::endl;
    
    // Sort the array using our quicksort
    quicksort(arr.begin(), arr.end());
    
    std::cout << "Sorted array: ";
    for (int x : arr) {
        std::cout << x << " ";
    }
    std::cout << std::endl;
    
    // Calculate sum of 3rd and 5th elements (0-indexed: positions 2 and 4)
    if (arr.size() >= 5) {
        int third = arr[2];   // 3rd element (0-indexed position 2)
        int fifth = arr[4];   // 5th element (0-indexed position 4)
        int sum = third + fifth;
        
        std::cout << "3rd element: " << third << std::endl;
        std::cout << "5th element: " << fifth << std::endl;
        std::cout << "Sum of 3rd and 5th elements: " << sum << std::endl;
        
        return sum;  // Return the sum as exit code (if within valid range)
    } else {
        std::cout << "Array too small!" << std::endl;
        return -1;
    }
}
'''
    
    # Save the complete test program
    test_file = 'workspace/quicksort_test.cpp'
    with open(test_file, 'w', encoding='utf-8') as f:
        f.write(test_program)
    
    print(f"Created test program: {test_file}")
    print(f"Test program size: {len(test_program)} characters")
    
    print("\n=== COMPILING C++ PROGRAM ===")
    
    # Compile the program
    executable = 'workspace/quicksort_test'
    if os.name == 'nt':  # Windows
        executable += '.exe'
    
    try:
        # Try compiling with g++
        compile_cmd = ['g++', '-std=c++11', '-o', executable, test_file]
        print(f"Compile command: {' '.join(compile_cmd)}")
        
        result = subprocess.run(compile_cmd, capture_output=True, text=True, timeout=30)
        
        if result.returncode == 0:
            print("✅ Compilation successful!")
            if result.stdout:
                print(f"Compile stdout: {result.stdout}")
        else:
            print(f"❌ Compilation failed with return code: {result.returncode}")
            print(f"Compile stderr: {result.stderr}")
            print(f"Compile stdout: {result.stdout}")
            
            # Let's try a simpler approach - maybe the template syntax needs adjustment
            print("\n=== TRYING ALTERNATIVE COMPILATION ===")
            compile_cmd2 = ['g++', '-std=c++14', '-o', executable, test_file]
            print(f"Alternative compile command: {' '.join(compile_cmd2)}")
            
            result2 = subprocess.run(compile_cmd2, capture_output=True, text=True, timeout=30)
            if result2.returncode != 0:
                print(f"Alternative compilation also failed: {result2.stderr}")
                # Let's examine what might be wrong
                print("\n=== ANALYZING COMPILATION ERRORS ===")
                print("Error details:")
                print(result2.stderr)
            else:
                print("✅ Alternative compilation successful!")
                result = result2  # Use the successful result
        
        # If compilation was successful, run the program
        if result.returncode == 0 and os.path.exists(executable):
            print(f"\n=== EXECUTING PROGRAM ===")
            print(f"Running: {executable}")
            
            try:
                run_result = subprocess.run([executable], capture_output=True, text=True, timeout=10)
                
                print(f"Execution return code: {run_result.returncode}")
                print(f"Program output:")
                print(run_result.stdout)
                
                if run_result.stderr:
                    print(f"Program stderr: {run_result.stderr}")
                
                # Parse the output to extract the final answer
                output_lines = run_result.stdout.strip().split('\n')
                sum_result = None
                
                for line in output_lines:
                    if 'Sum of 3rd and 5th elements:' in line:
                        try:
                            sum_result = int(line.split(':')[-1].strip())
                            break
                        except ValueError:
                            pass
                
                if sum_result is not None:
                    print(f"\n🎯 FINAL ANSWER: {sum_result}")
                    print(f"The sum of the 3rd and 5th elements in the sorted array is: {sum_result}")
                    
                    # Save the result
                    with open('workspace/quicksort_result.txt', 'w') as f:
                        f.write(f"Original array: [35, 12, 8, 99, 21, 5]\n")
                        f.write(f"Program output:\n{run_result.stdout}\n")
                        f.write(f"Final answer: {sum_result}\n")
                    
                    print("Results saved to workspace/quicksort_result.txt")
                else:
                    print("❌ Could not extract sum result from program output")
                
            except subprocess.TimeoutExpired:
                print("❌ Program execution timed out")
            except Exception as e:
                print(f"❌ Error executing program: {e}")
        else:
            print("❌ Compilation failed, cannot execute program")
            
    except subprocess.TimeoutExpired:
        print("❌ Compilation timed out")
    except FileNotFoundError:
        print("❌ g++ compiler not found. Trying alternative approaches...")
        
        # Try with clang++ if available
        try:
            compile_cmd_clang = ['clang++', '-std=c++11', '-o', executable, test_file]
            print(f"Trying clang++: {' '.join(compile_cmd_clang)}")
            
            result = subprocess.run(compile_cmd_clang, capture_output=True, text=True, timeout=30)
            if result.returncode == 0:
                print("✅ Compilation with clang++ successful!")
                # Continue with execution...
            else:
                print(f"❌ clang++ also failed: {result.stderr}")
        except FileNotFoundError:
            print("❌ clang++ also not found")
            
    except Exception as e:
        print(f"❌ Unexpected error during compilation: {e}")
        
else:
    print(f"❌ C++ file not found: {cpp_file}")
    print("Available files in workspace:")
    if os.path.exists('workspace'):
        for file in os.listdir('workspace'):
            print(f"  {file}")
    else:
        print("  workspace directory does not exist")

print("\n=== COMPILATION AND EXECUTION COMPLETE ===")
```