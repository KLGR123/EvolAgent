### Development Step 8: Download C++ Quicksort Source from URL and Save as workspace/quicksort.cpp for Compilation

**Description**: Download the C++ source code from the URL https://web.archive.org/web/20230609112831/https://rosettacode.org/wiki/sorting_algorithms/Quicksort#C++ and save it to workspace/quicksort.cpp for compilation and execution.

**Use Cases**:
- Automated retrieval and compilation of algorithm source code for competitive programming training platforms
- Integration of verified sorting algorithm implementations into educational software for computer science courses
- Benchmarking and performance analysis of different sorting algorithms for high-frequency trading systems
- Rapid prototyping of data processing modules in bioinformatics pipelines requiring efficient sorting routines
- Continuous integration workflows that fetch and test open-source algorithm samples for code quality assurance
- Building a curated repository of canonical algorithm implementations for machine learning preprocessing tasks
- Automated documentation generation for software engineering teams maintaining algorithm libraries
- Sourcing and validating reference implementations for cybersecurity tools analyzing data packet order

```
import os
import requests
from bs4 import BeautifulSoup

# Ensure workspace directory exists
os.makedirs('workspace', exist_ok=True)

# The URL from the PLAN to download C++ source code
url = "https://web.archive.org/web/20230609112831/https://rosettacode.org/wiki/sorting_algorithms/Quicksort#C++"
print(f"Target URL: {url}")
print("Objective: Download C++ Quicksort source code and save to workspace/quicksort.cpp\n")

# Set up headers to mimic a real browser
headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
    'Accept-Language': 'en-US,en;q=0.5',
    'Accept-Encoding': 'gzip, deflate',
    'Connection': 'keep-alive',
    'Upgrade-Insecure-Requests': '1'
}

print("Fetching webpage content...")
try:
    response = requests.get(url, headers=headers, timeout=30)
    response.raise_for_status()
    print(f"✅ Successfully fetched webpage (Status: {response.status_code})")
    print(f"Content length: {len(response.text)} characters")
    print(f"Content type: {response.headers.get('content-type', 'unknown')}\n")
except Exception as e:
    print(f"❌ Error fetching webpage: {e}")
    exit(1)

# Parse the HTML content
soup = BeautifulSoup(response.text, 'html.parser')
print("Parsing HTML content to locate C++ source code...")

# Look for the C++ section specifically
print("\n=== SEARCHING FOR C++ SECTION ===")

# Find all headings that might indicate C++ section
headings = soup.find_all(['h1', 'h2', 'h3', 'h4', 'h5', 'h6'])
c_plus_plus_sections = []

for heading in headings:
    heading_text = heading.get_text().strip()
    if 'C++' in heading_text or 'c++' in heading_text.lower():
        print(f"Found C++ heading: '{heading_text}'")
        c_plus_plus_sections.append(heading)

print(f"Found {len(c_plus_plus_sections)} C++ section headings")

# Look for code blocks - common patterns on Rosetta Code
code_patterns = [
    {'tag': 'pre', 'class': None},
    {'tag': 'code', 'class': None},
    {'tag': 'div', 'class': 'mw-highlight'},
    {'tag': 'div', 'class': 'source-cpp'},
    {'tag': 'pre', 'class': 'cpp'},
    {'tag': 'pre', 'class': 'c++'},
    {'tag': 'div', 'class': 'highlighted_source'}
]

all_code_blocks = []
print("\n=== SEARCHING FOR CODE BLOCKS ===")

for pattern in code_patterns:
    if pattern['class']:
        blocks = soup.find_all(pattern['tag'], class_=pattern['class'])
    else:
        blocks = soup.find_all(pattern['tag'])
    
    if blocks:
        print(f"Found {len(blocks)} <{pattern['tag']}> blocks with class '{pattern['class']}'")
        all_code_blocks.extend(blocks)

# Also look for any <pre> or <code> tags near C++ headings
if c_plus_plus_sections:
    print("\n=== SEARCHING NEAR C++ HEADINGS ===")
    for heading in c_plus_plus_sections:
        # Look for code blocks after this heading
        next_elements = heading.find_next_siblings(['pre', 'code', 'div'], limit=5)
        for element in next_elements:
            if element not in all_code_blocks:
                all_code_blocks.append(element)
                print(f"Found code block near C++ heading: <{element.name}>")

print(f"\nTotal code blocks found: {len(all_code_blocks)}")

# Analyze each code block to find C++ content
print("\n=== ANALYZING CODE BLOCKS FOR C++ CONTENT ===")
cpp_candidates = []

for i, block in enumerate(all_code_blocks, 1):
    code_text = block.get_text().strip()
    
    # Skip very short blocks
    if len(code_text) < 50:
        continue
        
    print(f"\nBlock {i}:")
    print(f"  Tag: <{block.name}>")
    print(f"  Classes: {block.get('class', [])}")
    print(f"  Length: {len(code_text)} characters")
    
    # Check for C++ indicators
    cpp_indicators = [
        '#include',
        'std::',
        'using namespace std',
        'vector<',
        'int main(',
        'void ',
        'template<',
        'class ',
        '->',
        'quicksort',
        'partition'
    ]
    
    found_indicators = []
    for indicator in cpp_indicators:
        if indicator.lower() in code_text.lower():
            found_indicators.append(indicator)
    
    print(f"  C++ indicators found: {found_indicators}")
    
    # Show preview
    preview = code_text[:200].replace('\n', '\\n')
    print(f"  Preview: {preview}...")
    
    # Score this block based on C++ indicators
    cpp_score = len(found_indicators)
    if cpp_score > 0:
        cpp_candidates.append({
            'block': block,
            'text': code_text,
            'score': cpp_score,
            'indicators': found_indicators
        })
        print(f"  ⭐ C++ Score: {cpp_score} - Added to candidates")

# Sort candidates by score (highest first)
cpp_candidates.sort(key=lambda x: x['score'], reverse=True)

print(f"\n=== C++ CANDIDATES SUMMARY ===")
print(f"Found {len(cpp_candidates)} potential C++ code blocks")

if cpp_candidates:
    print("\nTop candidates:")
    for i, candidate in enumerate(cpp_candidates[:3], 1):
        print(f"  {i}. Score: {candidate['score']}, Length: {len(candidate['text'])}, Indicators: {candidate['indicators']}")
    
    # Use the best candidate
    best_candidate = cpp_candidates[0]
    cpp_code = best_candidate['text']
    
    print(f"\n=== SELECTED C++ CODE ===")
    print(f"Score: {best_candidate['score']}")
    print(f"Length: {len(cpp_code)} characters")
    print(f"Indicators: {best_candidate['indicators']}")
    print("\nCode content:")
    print("-" * 60)
    print(cpp_code)
    print("-" * 60)
    
    # Save to workspace/quicksort.cpp
    output_path = 'workspace/quicksort.cpp'
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(cpp_code)
    
    print(f"\n✅ C++ source code saved to: {output_path}")
    print(f"File size: {os.path.getsize(output_path)} bytes")
    
    # Verify the saved file
    with open(output_path, 'r', encoding='utf-8') as f:
        saved_content = f.read()
    
    print(f"\n=== VERIFICATION ===")
    print(f"Saved file length: {len(saved_content)} characters")
    print(f"Content matches: {saved_content == cpp_code}")
    
    # Show first few lines of saved file
    lines = saved_content.split('\n')
    print(f"\nFirst 10 lines of saved file:")
    for i, line in enumerate(lines[:10], 1):
        print(f"  {i:2d}: {line}")
    
else:
    print("\n❌ No C++ code blocks found on the webpage")
    print("\nSaving raw HTML for manual inspection...")
    with open('workspace/rosetta_code_page.html', 'w', encoding='utf-8') as f:
        f.write(response.text)
    print("HTML saved to: workspace/rosetta_code_page.html")

print("\n=== DOWNLOAD COMPLETE ===")
```