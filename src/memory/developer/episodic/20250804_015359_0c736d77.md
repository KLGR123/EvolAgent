### Development Step 11: BFS on Two-Cell Moves Graph to Identify 11th-Move Cell Hex Color

**Description**: Construct adjacency graph of legal two-cell moves using workspace/grid_data.json and workspace/start_end_coordinates.json and perform a breadth-first search from the START cell to locate the shortest path to the END cell enforcing no immediate backtracking; identify the coordinate of the cell landed on after the 11th move along the resulting path; extract that cell’s 6-digit hex fill color from workspace/grid_data.json.

**Use Cases**:
- Warehouse robotics navigation and floor-tile mapping: plan two-cell moves for an AGV from loading dock to storage rack, then retrieve the 11th-tile’s hex color to verify zone boundaries before unloading.
- Puzzle game level solver and dynamic tile effect: compute the optimal series of two-cell jumps from player start to goal, then read the 11th landing tile’s fill_color to trigger a timed power-up spawn.
- Satellite image scan path optimization and land-use classification: traverse a grid of terrain pixels in two-pixel hops to minimize overlap, locate the 11th pixel on the shortest route to a target region, and extract its color code for vegetation analysis.
- Automotive painting robot calibration in assembly lines: route the sprayer nozzle in two-panel shifts across a vehicle shell, identify the panel reached on the 11th move, and sample its existing paint color hex to adjust spray parameters.
- Agricultural drone spraying pattern and soil moisture sensing: map out a sequence of two-plot jumps to cover a field efficiently, then at the 11th plot’s coordinate retrieve the recorded soil-moisture color code to adjust nutrient dosing.
- Cold-chain warehouse rack scheduling: calculate forklift movements between two-shelf intervals to minimize travel time, then at the 11th rack pause and read its color-coded temperature zone to decide which pallet to pick.
- Urban street-cleaner robot routing and debris-type detection: generate a non-backtracking route with two-manhole-cover hops from start to end, then at the 11th cover read its surface-color hex to switch cleaning mode for oily residue.
- Laboratory pipetting robot well-sequence planning: plan reagent dispensing moves in two-well increments across a microplate, identify the 11th well on the fastest path, and extract its color indicator to decide on a tip exchange protocol.

```
import os
import json

# Paths to workspace files
dir_path = 'workspace'
grid_path = os.path.join(dir_path, 'grid_data.json')
coords_path = os.path.join(dir_path, 'start_end_coordinates.json')

# 1) Inspect start_end_coordinates.json
print('=== Inspecting start_end_coordinates.json ===')
with open(coords_path, 'r', encoding='utf-8') as f:
    se_data = json.load(f)
print('Type of top‐level object:', type(se_data))
print('Top-level keys:', list(se_data.keys()))
print('Values by key:')
for k, v in se_data.items():
    print(f'  {k!r}: {v!r} (type {type(v)})')
print()

# 2) Inspect grid_data.json
print('=== Inspecting grid_data.json ===')
with open(grid_path, 'r', encoding='utf-8') as f:
    grid = json.load(f)
print('Total number of cells:', len(grid))
if len(grid) > 0:
    # Examine keys of first cell
    sample = grid[0]
    print('Keys in one cell record:', list(sample.keys()))
    # Print first 3 samples
    print('\nFirst 3 cell entries:')
    for i, cell in enumerate(grid[:3], start=1):
        print(f'  Cell {i}:', cell)

# 3) Summarize row/col distribution and fill_color frequencies
rows = [cell.get('row') for cell in grid]
cols = [cell.get('col') for cell in grid]
colors = [cell.get('fill_color', '') for cell in grid]

print('\n=== Row & Column Statistics ===')
print(f'Row: min={min(rows)}, max={max(rows)}, unique={len(set(rows))}')
print(f'Col: min={min(cols)}, max={max(cols)}, unique={len(set(cols))}')

from collections import Counter
color_counts = Counter(colors)
print('\n=== fill_color Frequencies ===')
for color, cnt in color_counts.most_common():
    print(f"  '{color}': {cnt}")

# 4) Identify how many cells have a non‐empty "value" field
value_cells = [c for c in grid if c.get('value')]
print(f"\nCells with non-empty 'value' field (usually START/END): {len(value_cells)}")
for cell in value_cells:
    print(' ', cell)

# 5) Save inspection summary to file
summary = {
    'start_end_structure': {
        'type': str(type(se_data)),
        'keys': list(se_data.keys()),
        'values': se_data
    },
    'grid_sample_keys': list(sample.keys()),
    'grid_total_cells': len(grid),
    'row_stats': {'min': min(rows), 'max': max(rows), 'unique': len(set(rows))},
    'col_stats': {'min': min(cols), 'max': max(cols), 'unique': len(set(cols))},
    'fill_color_counts': color_counts,
    'value_field_cells': value_cells
}
out_file = os.path.join(dir_path, 'inspection_summary.json')
with open(out_file, 'w', encoding='utf-8') as f:
    json.dump(summary, f, indent=2)
print(f"\nInspection summary written to {out_file}")

```