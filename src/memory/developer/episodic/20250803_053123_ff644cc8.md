### Development Step 4: Implement 4x4 Boggle solver using words_alpha dictionary to find longest valid word

**Description**: Download the words_alpha dictionary from https://github.com/dwyl/english-words to workspace/words_alpha.txt and then implement a Boggle solver to find all valid words that can be formed from the given 4x4 board (ABRL/EITE/IONS/FPEI) using the downloaded dictionary. The solver should check all possible paths on the board where adjacent cells (including diagonally adjacent) can be visited exactly once per word, then identify the longest valid English word(s) and return the alphabetically first one if there are ties.

**Use Cases**:
- Real-time word validation and scoring engine integration for mobile Boggle-like game platforms
- Automated puzzle difficulty assessment and 4×4 board generation for weekly print and digital puzzle publications
- Student vocabulary enhancement and custom exercise creation for ESL classrooms using dynamic board solvers
- Cognitive psychology experiment design and participant response tracking for research into spatial word retrieval strategies
- Social media gamification and interactive marketing campaign deployment for brand engagement via word-search challenges
- NLP model benchmarking and vocabulary coverage analysis for evaluating large language models’ ability to find valid word paths
- Crossword clue suggestion and obscure word discovery for puzzle editors creating fresh content based on random letter matrices
- Accessibility tool development and dyslexia-friendly word practice for special needs educational software

```
import os
import requests
from collections import defaultdict
import time

print('=== BOGGLE SOLVER IMPLEMENTATION - CLASS-BASED APPROACH ===')
print('Using class-based structure to avoid function scope issues\n')

# Ensure workspace directory exists
workspace = 'workspace'
os.makedirs(workspace, exist_ok=True)

# Check if dictionary already exists, if not download it
words_file_path = os.path.join(workspace, 'words_alpha.txt')

if not os.path.exists(words_file_path):
    print('Step 1: Downloading words_alpha dictionary from GitHub\n')
    
    words_url = 'https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt'
    print(f'Downloading dictionary from: {words_url}')
    print(f'Saving to: {words_file_path}')
    
    try:
        response = requests.get(words_url, timeout=30)
        print(f'Response status: {response.status_code}')
        
        if response.status_code == 200:
            with open(words_file_path, 'w', encoding='utf-8') as f:
                f.write(response.text)
            
            print(f'✓ Dictionary downloaded successfully')
            print(f'File size: {len(response.text):,} characters')
            
            # Count number of words
            word_count = len(response.text.strip().split('\n'))
            print(f'Total words in dictionary: {word_count:,}')
            
        else:
            print(f'Error downloading dictionary: HTTP {response.status_code}')
            
    except Exception as e:
        print(f'Error downloading dictionary: {e}')
else:
    print('✓ Dictionary file already exists, skipping download')

print('\n=== STEP 2: LOADING DICTIONARY INTO MEMORY ===')

# Load the dictionary into a set for fast lookup
if os.path.exists(words_file_path):
    print(f'Loading dictionary from: {words_file_path}')
    
    with open(words_file_path, 'r', encoding='utf-8') as f:
        dictionary_words = set(word.strip().lower() for word in f if word.strip())
    
    print(f'✓ Dictionary loaded: {len(dictionary_words):,} unique words')
    
    # Check some common words to verify dictionary quality
    test_words = ['the', 'and', 'hello', 'world', 'python', 'boggle']
    print(f'\nTesting common words in dictionary:')
    for word in test_words:
        in_dict = word in dictionary_words
        print(f'  "{word}": {"✓" if in_dict else "✗"}')
else:
    print('Error: Dictionary file not found!')
    dictionary_words = set()

print('\n=== STEP 3: DEFINING THE 4x4 BOGGLE BOARD ===')

# Define the 4x4 Boggle board as given in the plan
# ABRL
# EITE  
# IONS
# FPEI

boggle_board = [
    ['A', 'B', 'R', 'L'],
    ['E', 'I', 'T', 'E'], 
    ['I', 'O', 'N', 'S'],
    ['F', 'P', 'E', 'I']
]

print('Boggle board:')
for i, row in enumerate(boggle_board):
    print(f'Row {i}: {" ".join(row)}')

print(f'\nBoard dimensions: {len(boggle_board)}x{len(boggle_board[0])}')

# Verify board structure
total_letters = sum(len(row) for row in boggle_board)
print(f'Total letters on board: {total_letters}')

# Count letter frequency
letter_count = defaultdict(int)
for row in boggle_board:
    for letter in row:
        letter_count[letter] += 1

print(f'Letter frequency: {dict(letter_count)}')

print('\n=== STEP 4: IMPLEMENTING BOGGLE SOLVER CLASS ===')

class BoggleSolver:
    def __init__(self, board, dictionary):
        self.board = board
        self.dictionary = dictionary
        self.rows = len(board)
        self.cols = len(board[0]) if board else 0
        self.found_words = set()
        
    def get_neighbors(self, row, col):
        """Get all adjacent cells (including diagonal) for a given position"""
        neighbors = []
        # Check all 8 directions: up, down, left, right, and 4 diagonals
        directions = [
            (-1, -1), (-1, 0), (-1, 1),  # up-left, up, up-right
            (0, -1),           (0, 1),   # left, right
            (1, -1),  (1, 0),  (1, 1)    # down-left, down, down-right
        ]
        
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc
            if 0 <= new_row < self.rows and 0 <= new_col < self.cols:
                neighbors.append((new_row, new_col))
        
        return neighbors
    
    def find_words_from_position(self, start_row, start_col, visited, current_word):
        """Recursively find all valid words starting from a given position"""
        # Add current letter to the word
        current_word += self.board[start_row][start_col].lower()
        
        # Mark current position as visited
        visited.add((start_row, start_col))
        
        # Check if current word is valid and has reasonable length (3+ letters)
        if len(current_word) >= 3 and current_word in self.dictionary:
            self.found_words.add(current_word)
            print(f'Found valid word: "{current_word}" (length: {len(current_word)})')
        
        # Continue searching if word length is reasonable (prevent excessive recursion)
        if len(current_word) < 15:  # Reasonable max word length
            # Get all adjacent neighbors
            neighbors = self.get_neighbors(start_row, start_col)
            
            for next_row, next_col in neighbors:
                # Only visit unvisited cells
                if (next_row, next_col) not in visited:
                    # Create a new copy of visited set for this branch
                    new_visited = visited.copy()
                    self.find_words_from_position(next_row, next_col, new_visited, current_word)
    
    def solve(self):
        """Solve the Boggle puzzle and return all valid words"""
        print(f'Starting Boggle solve for {self.rows}x{self.cols} board...')
        print(f'Dictionary size: {len(self.dictionary):,} words')
        
        # Start search from each position on the board
        for row in range(self.rows):
            for col in range(self.cols):
                print(f'\nSearching from position ({row},{col}) - letter "{self.board[row][col]}":')
                visited = set()
                self.find_words_from_position(row, col, visited, '')
        
        return self.found_words

print('✓ BoggleSolver class defined successfully')

print('\n=== STEP 5: RUNNING BOGGLE SOLVER ===')

if dictionary_words:
    print('Starting Boggle word search...')
    start_time = time.time()
    
    # Create solver instance and solve the puzzle
    solver = BoggleSolver(boggle_board, dictionary_words)
    all_found_words = solver.solve()
    
    end_time = time.time()
    solve_time = end_time - start_time
    
    print(f'\n=== BOGGLE SOLVE COMPLETE ===')
    print(f'Solve time: {solve_time:.2f} seconds')
    print(f'Total valid words found: {len(all_found_words)}')
    
    if all_found_words:
        # Sort words by length (descending) then alphabetically
        sorted_words = sorted(all_found_words, key=lambda w: (-len(w), w))
        
        print(f'\n=== ALL FOUND WORDS (sorted by length, then alphabetically) ===')
        current_length = None
        for word in sorted_words:
            if len(word) != current_length:
                current_length = len(word)
                print(f'\n--- {current_length}-letter words ---')
            print(f'  {word}')
        
        # Find the longest word(s)
        max_length = max(len(word) for word in all_found_words)
        longest_words = [word for word in all_found_words if len(word) == max_length]
        longest_words.sort()  # Sort alphabetically
        
        print(f'\n=== LONGEST WORD(S) FOUND ===')
        print(f'Maximum word length: {max_length} letters')
        print(f'Number of longest words: {len(longest_words)}')
        print(f'Longest words: {longest_words}')
        
        # Return the alphabetically first longest word
        answer = longest_words[0]
        print(f'\n*** FINAL ANSWER: "{answer}" ***')
        print(f'Length: {len(answer)} letters')
        
        # Save results to file
        results_file = os.path.join(workspace, 'boggle_solver_results.txt')
        with open(results_file, 'w', encoding='utf-8') as f:
            f.write('BOGGLE SOLVER RESULTS\n')
            f.write('=' * 50 + '\n\n')
            f.write('Board:\n')
            for row in boggle_board:
                f.write(' '.join(row) + '\n')
            f.write(f'\nTotal words found: {len(all_found_words)}\n')
            f.write(f'Longest word length: {max_length}\n')
            f.write(f'Longest word (alphabetically first): {answer}\n\n')
            f.write('All words by length:\n')
            f.write('-' * 30 + '\n')
            current_length = None
            for word in sorted_words:
                if len(word) != current_length:
                    current_length = len(word)
                    f.write(f'\n{current_length}-letter words:\n')
                f.write(f'  {word}\n')
        
        print(f'\n✓ Complete results saved to: {results_file}')
        
    else:
        print('No valid words found!')
else:
    print('Error: Dictionary not loaded, cannot solve Boggle puzzle')
```