### Development Step 2: Retrieve Merriam-Webster Word of the Day June 27, 2022 Entry and Author Attribution

**Description**: Search for Merriam-Webster's Word of the Day archive or specific entry from June 27, 2022. Use web search with targeted queries such as 'Merriam-Webster Word of the Day June 27 2022', 'site:merriam-webster.com word of the day June 2022', and 'Merriam-Webster WOTD archive 06/27/2022'. Look for the official Merriam-Webster page showing the word selection, definition, etymology, and any quoted usage examples. Extract the complete entry including the featured word, writer attribution, and quote context to identify which author is referenced in the daily feature.

**Use Cases**:
- Educational technology platform automating daily vocabulary email digests by scraping WOTD entries with definitions, etymology, and author quotes for K-12 students
- Language-learning mobile app integrating authentic usage examples by extracting WOTD quotes and author attributions to enhance contextual flashcards
- Content marketing team sourcing engaging social media posts by programmatically pulling Word of the Day entries with notable author quotes for audience engagement
- SEO-driven dictionary aggregator updating web pages overnight with fresh WOTD content, metadata, and author references to improve search rankings
- Academic linguistics research group harvesting WOTD etymologies and usage quotes for large-scale analysis of lexical trends over time
- Digital assistant skill developer enabling smart speakers to deliver Word of the Day briefings with pronunciation, definition, and cited author examples
- E-learning course designers generating custom quizzes by extracting WOTD definitions and example sentences along with author names for interactive assessments
- Journalism workflow automating weekly “Word of the Day” column drafts by extracting WOTD entries and quoted contexts with author credits

```
import os
import json
from bs4 import BeautifulSoup
import re

print("=== PARSING MERRIAM-WEBSTER WORD OF THE DAY - JUNE 27, 2022 ===")
print("Objective: Extract complete WOTD entry including author reference from downloaded HTML\n")

# First, inspect the workspace directory structure
workspace_dirs = [d for d in os.listdir('.') if d.startswith('workspace')]
if not workspace_dirs:
    print("No workspace directory found")
    exit()

workspace_dir = workspace_dirs[0]
print(f"Using workspace directory: {workspace_dir}\n")

# List available files
print("Available files in workspace:")
for file in os.listdir(workspace_dir):
    file_path = os.path.join(workspace_dir, file)
    file_size = os.path.getsize(file_path)
    print(f"  - {file} ({file_size:,} bytes)")

# Locate the HTML file with WOTD content
html_file = None
for file in os.listdir(workspace_dir):
    if file.endswith('.html') and 'merriam_webster_wotd' in file:
        html_file = os.path.join(workspace_dir, file)
        break

if not html_file:
    print("\n❌ WOTD HTML file not found")
    exit()

print(f"\n=== PARSING HTML FILE: {os.path.basename(html_file)} ===")
print(f"File size: {os.path.getsize(html_file):,} bytes\n")

# Read and parse the HTML content
with open(html_file, 'r', encoding='utf-8') as f:
    html_content = f.read()

soup = BeautifulSoup(html_content, 'html.parser')

print("=== EXTRACTING WORD OF THE DAY INFORMATION ===")

# Extract the featured word
word_element = soup.find('h1', class_='hword') or soup.find('h1') or soup.find(class_='word-of-the-day-word')
if word_element:
    featured_word = word_element.get_text().strip()
else:
    # Try alternative approaches
    title_text = soup.find('title').get_text() if soup.find('title') else ''
    if 'Word of the Day:' in title_text:
        featured_word = title_text.split('Word of the Day:')[1].split('|')[0].strip()
    else:
        featured_word = 'Not found'

print(f"Featured Word: {featured_word}")

# Extract the date
date_element = soup.find(class_='date') or soup.find(class_='word-of-the-day-date')
if date_element:
    wotd_date = date_element.get_text().strip()
else:
    # Search for date pattern in text
    date_pattern = r'June\s+27,?\s+2022'
    date_match = re.search(date_pattern, html_content, re.IGNORECASE)
    wotd_date = date_match.group() if date_match else 'June 27, 2022'

print(f"Date: {wotd_date}")

# Extract the definition/meaning
definition_selectors = [
    '.wod-definition-container',
    '.word-definition',
    '.definition',
    '.meaning',
    '[data-type="definition"]'
]

definition = None
for selector in definition_selectors:
    definition_element = soup.select_one(selector)
    if definition_element:
        definition = definition_element.get_text().strip()
        break

if not definition:
    # Look for definition patterns in the text
    definition_patterns = [
        r'extreme patriotism or nationalism',
        r'What It Means[\s\S]*?(?=Etymology|Examples|\n\n)',
        r'Definition[\s\S]*?(?=Etymology|Examples|\n\n)'
    ]
    
    for pattern in definition_patterns:
        match = re.search(pattern, html_content, re.IGNORECASE)
        if match:
            definition = match.group().strip()
            break

print(f"Definition: {definition or 'Not found'}")

# Extract etymology information
etymology_selectors = [
    '.etymology',
    '.word-etymology',
    '[data-type="etymology"]',
    '.et'
]

etymology = None
for selector in etymology_selectors:
    etymology_element = soup.select_one(selector)
    if etymology_element:
        etymology = etymology_element.get_text().strip()
        break

if not etymology:
    # Look for etymology patterns
    etymology_patterns = [
        r'Etymology[\s\S]*?(?=Examples|Did You Know|\n\n)',
        r'Jingoism originated during[\s\S]*?(?=Examples|Did You Know)',
        r'originated during[\s\S]*?War of 1877-1878[\s\S]*?citizens'
    ]
    
    for pattern in etymology_patterns:
        match = re.search(pattern, html_content, re.IGNORECASE)
        if match:
            etymology = match.group().strip()
            break

print(f"Etymology: {etymology[:200] + '...' if etymology and len(etymology) > 200 else etymology or 'Not found'}")

print("\n=== SEARCHING FOR AUTHOR REFERENCES AND QUOTES ===")

# Look for quoted usage examples with author attribution
quote_patterns = [
    r'"[^"]+"[\s\S]*?—[\s]*([A-Z][a-zA-Z\s]+)',  # "Quote" — Author Name
    r'"[^"]+"[\s\S]*?—[\s]*([A-Z][a-zA-Z\s]+)',   # "Quote" — Author Name (smart quotes)
    r'"[^"]+"[\s\S]*?by[\s]+([A-Z][a-zA-Z\s]+)',  # "Quote" by Author Name
    r'"[^"]+"[\s\S]*?by[\s]+([A-Z][a-zA-Z\s]+)',   # "Quote" by Author Name (smart quotes)
]

found_quotes = []
for pattern in quote_patterns:
    matches = re.finditer(pattern, html_content)
    for match in matches:
        quote_context = match.group()
        author_name = match.group(1).strip()
        
        # Clean up author name (remove extra whitespace, common suffixes)
        author_name = re.sub(r'\s+', ' ', author_name)
        author_name = re.sub(r'(,.*$)', '', author_name)  # Remove everything after comma
        
        found_quotes.append({
            'quote_context': quote_context,
            'author_name': author_name,
            'pattern_used': pattern
        })

print(f"Found {len(found_quotes)} potential author quotes:")
for i, quote in enumerate(found_quotes, 1):
    print(f"  {i}. Author: {quote['author_name']}")
    print(f"     Context: {quote['quote_context'][:100]}...")
    print()

# Also search for more general author mentions
author_patterns = [
    r'—\s*([A-Z][a-zA-Z]+(?:\s+[A-Z][a-zA-Z]+)*)',  # — Author Name
    r'by\s+([A-Z][a-zA-Z]+(?:\s+[A-Z][a-zA-Z]+)*)',  # by Author Name
    r'wrote\s+([A-Z][a-zA-Z]+(?:\s+[A-Z][a-zA-Z]+)*)', # wrote Author Name
    r'according\s+to\s+([A-Z][a-zA-Z]+(?:\s+[A-Z][a-zA-Z]+)*)'  # according to Author Name
]

all_author_mentions = []
for pattern in author_patterns:
    matches = re.finditer(pattern, html_content)
    for match in matches:
        author_name = match.group(1).strip()
        # Filter out common false positives
        if len(author_name.split()) <= 4 and author_name not in ['Did You Know', 'Merriam Webster', 'Word Game']:
            context_start = max(0, match.start() - 100)
            context_end = min(len(html_content), match.end() + 100)
            context = html_content[context_start:context_end]
            
            all_author_mentions.append({
                'author_name': author_name,
                'context': context,
                'pattern_used': pattern
            })

print(f"\nFound {len(all_author_mentions)} additional author mentions:")
for i, mention in enumerate(all_author_mentions[:10], 1):  # Show first 10
    print(f"  {i}. Author: {mention['author_name']}")
    print(f"     Context: {mention['context'][:150]}...")
    print()

# Look specifically for example sentences or usage quotes
print("\n=== SEARCHING FOR USAGE EXAMPLES AND QUOTES ===")

# Find sections that might contain quoted examples
example_sections = soup.find_all(['div', 'p', 'section'], class_=re.compile(r'example|usage|quote|citation', re.I))
if not example_sections:
    # Try broader search
    example_sections = soup.find_all(['div', 'p'], string=re.compile(r'".*"', re.DOTALL))

print(f"Found {len(example_sections)} potential example sections")

for i, section in enumerate(example_sections[:5], 1):  # Show first 5
    section_text = section.get_text().strip()
    if len(section_text) > 50:  # Only show substantial content
        print(f"  {i}. Example section:")
        print(f"     {section_text[:200]}...")
        
        # Look for author names in this section
        for pattern in author_patterns:
            author_match = re.search(pattern, section_text)
            if author_match:
                print(f"     *** AUTHOR FOUND: {author_match.group(1)} ***")
        print()

# Extract the complete raw text for manual inspection of key sections
raw_text = soup.get_text()
print("\n=== ANALYZING COMPLETE TEXT FOR AUTHOR REFERENCES ===")

# Look for sentences containing quotes and author names
sentences_with_quotes = []
for sentence in raw_text.split('.'):
    if '"' in sentence and any(word in sentence.lower() for word in ['wrote', 'said', 'author', 'by']):
        sentences_with_quotes.append(sentence.strip())

print(f"Found {len(sentences_with_quotes)} sentences with quotes and author indicators:")
for i, sentence in enumerate(sentences_with_quotes[:3], 1):  # Show first 3
    print(f"  {i}. {sentence[:200]}...")
    print()

# Compile final results
wotd_analysis = {
    'extraction_date': '2024-12-19',
    'source_url': 'https://www.merriam-webster.com/word-of-the-day/jingoism-2022-06-27',
    'word_of_the_day': {
        'featured_word': featured_word,
        'date': wotd_date,
        'definition': definition,
        'etymology': etymology
    },
    'author_analysis': {
        'quoted_author_references': found_quotes,
        'general_author_mentions': all_author_mentions,
        'example_sections_count': len(example_sections),
        'sentences_with_quotes': sentences_with_quotes
    },
    'extraction_summary': {
        'html_file_size': os.path.getsize(html_file),
        'total_author_mentions': len(all_author_mentions),
        'quoted_references': len(found_quotes),
        'potential_authors': list(set([quote['author_name'] for quote in found_quotes] + [mention['author_name'] for mention in all_author_mentions]))
    }
}

# Save detailed analysis
analysis_file = os.path.join(workspace_dir, 'wotd_detailed_analysis.json')
with open(analysis_file, 'w', encoding='utf-8') as f:
    json.dump(wotd_analysis, f, indent=2, ensure_ascii=False)

print(f"\n=== EXTRACTION COMPLETE ===")
print(f"Word of the Day: {featured_word}")
print(f"Date: {wotd_date}")
print(f"Total potential authors identified: {len(wotd_analysis['extraction_summary']['potential_authors'])}")
print(f"Unique authors: {wotd_analysis['extraction_summary']['potential_authors']}")
print(f"\nDetailed analysis saved to: {analysis_file}")
print(f"\nNext: Manually inspect the HTML content or search for specific author attribution patterns")
```