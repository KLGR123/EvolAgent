### Development Step 5: Solve an anagram to reveal a famous 100-letter line from Shakespeareâ€™s Hamlet using all letters.

**Description**: Solve the anagram by rearranging the letters from 'in one of The Bard's best thought of tragedies are insistent hero Hamlet queries on two fronts about how life turns rotten' to find the original Shakespeare line from Hamlet that this phrase represents. Focus on identifying one of Shakespeare's most well-known lines from the tragedy, ensuring all 100 letters are used exactly once in the rearrangement.

**Use Cases**:
- Literary scholarship: Verifying the authenticity of Shakespearean quotes in historical manuscripts by matching anagrammed passages to original Hamlet lines.
- Digital humanities: Automating the identification and reconstruction of scrambled literary texts for archiving and digital restoration projects.
- Educational technology: Creating interactive classroom exercises where students solve anagrams to discover famous Shakespeare quotes, enhancing engagement in literature courses.
- Audio transcription QA: Cross-referencing transcribed audio files of Hamlet performances with original text by solving anagrams found in analysis reports to ensure accuracy.
- Escape room game design: Generating complex anagram puzzles based on classic literature for immersive, themed puzzle experiences.
- Publishing editorial review: Detecting and correcting misquoted or rearranged Shakespearean lines in submitted manuscripts using automated anagram-solving tools.
- Social media campaign: Designing viral challenges where users decode anagrammed Shakespeare quotes to promote literary awareness.
- Archival research automation: Assisting librarians and archivists in cataloging and authenticating fragmented or coded Shakespeare texts found in historical collections.

```
import os
import json
from collections import Counter
import itertools

print('=== ANAGRAM SOLVER - SHAKESPEARE HAMLET QUOTE ===')
print('Inspecting workspace files from previous audio analysis\n')

# First, let's inspect the workspace structure to understand what files we have
workspace_dirs = []
if os.path.exists('workspace'):
    print('Found workspace directory. Contents:')
    for item in os.listdir('workspace'):
        item_path = os.path.join('workspace', item)
        if os.path.isdir(item_path):
            workspace_dirs.append(item_path)
            print(f'  Directory: {item}')
            # List files in subdirectory
            for file in os.listdir(item_path):
                file_path = os.path.join(item_path, file)
                file_size = os.path.getsize(file_path)
                print(f'    - {file} ({file_size} bytes)')
        elif os.path.isfile(item_path):
            file_size = os.path.getsize(item_path)
            print(f'  File: {item} ({file_size} bytes)')
else:
    print('No workspace directory found')

# Look for analysis files
analysis_files = []
for root, dirs, files in os.walk('workspace'):
    for file in files:
        if file.endswith('.json') or 'anagram' in file.lower():
            file_path = os.path.join(root, file)
            analysis_files.append(file_path)
            print(f'Found analysis file: {file_path}')

print(f'\nFound {len(analysis_files)} relevant files')

# Inspect the JSON analysis file to understand its structure
json_files = [f for f in analysis_files if f.endswith('.json')]
if json_files:
    json_file = json_files[0]
    print(f'\n=== INSPECTING JSON FILE STRUCTURE ===')
    print(f'File: {json_file}')
    
    # Load and safely inspect the JSON structure
    with open(json_file, 'r', encoding='utf-8') as f:
        analysis_data = json.load(f)
    
    print(f'JSON keys: {list(analysis_data.keys())}')
    
    # Safely examine each key
    for key, value in analysis_data.items():
        if isinstance(value, str):
            print(f'  {key}: <string, length {len(value)}>')
            if len(value) < 200:  # Show short strings
                print(f'    Value: "{value}"')
            else:
                print(f'    Preview: "{value[:100]}..."')
        elif isinstance(value, dict):
            print(f'  {key}: <dict with keys: {list(value.keys())}>')
        elif isinstance(value, list):
            print(f'  {key}: <list with {len(value)} items>')
        else:
            print(f'  {key}: {value}')
    
    # Extract the anagram data
    print(f'\n=== EXTRACTING ANAGRAM DATA ===')
    
    anagram_phrase = analysis_data.get('anagram_phrase_clean', '')
    letters_only = analysis_data.get('letters_only', '')
    letter_frequency = analysis_data.get('letter_frequency', {})
    
    print(f'Anagram phrase: "{anagram_phrase}"')
    print(f'Letters only: "{letters_only}"')
    print(f'Letter count: {len(letters_only)}')
    print(f'Letter frequency: {letter_frequency}')
    
else:
    print('\nNo JSON file found. Using known anagram from HISTORY:')
    # From the HISTORY, we know the anagram phrase
    anagram_phrase = 'in one of The Bards best thought of tragedies are insistent hero Hamlet queries on two fronts about how life turns rotten'
    letters_only = ''.join(c.lower() for c in anagram_phrase if c.isalpha())
    letter_frequency = dict(Counter(letters_only))
    
    print(f'Anagram phrase: "{anagram_phrase}"')
    print(f'Letters only: "{letters_only}"')
    print(f'Letter count: {len(letters_only)}')
    print(f'Letter frequency: {letter_frequency}')

print(f'\n=== ANAGRAM SOLVING STRATEGY ===')
print('Task: Find the original Shakespeare line from Hamlet')
print('Context: One of The Bard\'s most well-known lines')
print('Constraint: Must use all 100 letters exactly once')

# Let's think about famous Hamlet quotes that might match
print(f'\n=== FAMOUS HAMLET QUOTES ANALYSIS ===')
print('Analyzing well-known Hamlet lines that could match our letter count...')

# List of famous Hamlet quotes to test
famous_hamlet_quotes = [
    'To be or not to be that is the question',
    'To be or not to be that is the question whether tis nobler in the mind to suffer the slings and arrows of outrageous fortune',
    'Neither a borrower nor a lender be',
    'This above all to thine own self be true',
    'There is nothing either good or bad but thinking makes it so',
    'The lady doth protest too much methinks',
    'Though this be madness yet there is method in it',
    'Brevity is the soul of wit',
    'Something is rotten in the state of Denmark',
    'Get thee to a nunnery',
    'The rest is silence',
    'What a piece of work is man',
    'Frailty thy name is woman'
]

print(f'Testing {len(famous_hamlet_quotes)} famous Hamlet quotes:')

for i, quote in enumerate(famous_hamlet_quotes, 1):
    # Clean the quote and count letters
    quote_letters = ''.join(c.lower() for c in quote if c.isalpha())
    quote_frequency = dict(Counter(quote_letters))
    
    print(f'\n{i}. "{quote}"')
    print(f'   Letters: {len(quote_letters)} - {quote_letters[:50]}...')
    
    # Check if letter counts match
    if len(quote_letters) == len(letters_only):
        print(f'   *** LENGTH MATCH! ({len(quote_letters)} letters) ***')
        
        # Check if letter frequencies match
        if quote_frequency == letter_frequency:
            print(f'   *** PERFECT ANAGRAM MATCH! ***')
            print(f'   SOLUTION FOUND: "{quote}"')
            
            # Save the solution
            solution_data = {
                'anagram_phrase': anagram_phrase,
                'solution': quote,
                'verification': {
                    'anagram_letters': letters_only,
                    'solution_letters': quote_letters,
                    'letter_count_match': len(quote_letters) == len(letters_only),
                    'frequency_match': quote_frequency == letter_frequency,
                    'anagram_frequency': letter_frequency,
                    'solution_frequency': quote_frequency
                }
            }
            
            with open('workspace/anagram_solution.json', 'w', encoding='utf-8') as f:
                json.dump(solution_data, f, indent=2)
            
            print(f'   Solution saved to: workspace/anagram_solution.json')
            break
        else:
            print(f'   Letter frequencies don\'t match')
            # Show differences
            missing_in_quote = {k: v for k, v in letter_frequency.items() if quote_frequency.get(k, 0) < v}
            extra_in_quote = {k: v for k, v in quote_frequency.items() if letter_frequency.get(k, 0) < v}
            if missing_in_quote:
                print(f'   Missing letters: {missing_in_quote}')
            if extra_in_quote:
                print(f'   Extra letters: {extra_in_quote}')
    else:
        print(f'   Length mismatch: {len(quote_letters)} vs {len(letters_only)}')

print(f'\n=== EXTENDED HAMLET QUOTE ANALYSIS ===')
print('Testing longer, complete versions of famous quotes...')

# Test longer versions of the most famous quote
longer_hamlet_quotes = [
    'To be or not to be that is the question whether tis nobler in the mind to suffer the slings and arrows of outrageous fortune or to take arms against a sea of troubles and by opposing end them',
    'To be or not to be that is the question whether tis nobler in the mind to suffer the slings and arrows of outrageous fortune or to take arms against a sea of troubles',
    'Neither a borrower nor a lender be for loan oft loses both itself and friend and borrowing dulls the edge of husbandry',
    'This above all to thine own self be true and it must follow as the night the day thou canst not then be false to any man',
    'There is nothing either good or bad but thinking makes it so to me it is a prison',
    'What a piece of work is man how noble in reason how infinite in faculty in form and moving how express and admirable in action how like an angel',
    'The lady doth protest too much methinks it is a knavish piece of work but what of that your majesty and we that have free souls it touches us not'
]

for i, quote in enumerate(longer_hamlet_quotes, 1):
    quote_letters = ''.join(c.lower() for c in quote if c.isalpha())
    quote_frequency = dict(Counter(quote_letters))
    
    print(f'\n{i}. "{quote[:60]}..."')
    print(f'   Letters: {len(quote_letters)}')
    
    if len(quote_letters) == len(letters_only):
        print(f'   *** LENGTH MATCH! ({len(quote_letters)} letters) ***')
        
        if quote_frequency == letter_frequency:
            print(f'   *** PERFECT ANAGRAM MATCH! ***')
            print(f'   SOLUTION FOUND: "{quote}"')
            
            # Save the solution
            solution_data = {
                'anagram_phrase': anagram_phrase,
                'solution': quote,
                'verification': {
                    'anagram_letters': letters_only,
                    'solution_letters': quote_letters,
                    'letter_count_match': len(quote_letters) == len(letters_only),
                    'frequency_match': quote_frequency == letter_frequency,
                    'anagram_frequency': letter_frequency,
                    'solution_frequency': quote_frequency
                }
            }
            
            with open('workspace/anagram_solution.json', 'w', encoding='utf-8') as f:
                json.dump(solution_data, f, indent=2)
            
            print(f'   Solution saved to: workspace/anagram_solution.json')
            break
    else:
        print(f'   Length: {len(quote_letters)} (need {len(letters_only)})')

print(f'\n=== ANALYSIS COMPLETE ===')
print('If no exact match found above, will need to try manual anagram solving approaches')
```